[
  {
    "testName": "counter",
    "provider": "OpenAI",
    "modelId": "o4-mini-2025-04-16",
    "numSamples": 10,
    "numCorrect": 10,
    "pass1": 1,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let count = $state(0);\n</script>\n\n<div class=\"counter\">\n  <button data-testid=\"decrement-button\" onclick={() => count--}>-</button>\n  <span data-testid=\"count-value\">{count}</span>\n  <button data-testid=\"increment-button\" onclick={() => count++}>+</button>\n</div>\n\n<style>\n  .counter {\n    display: inline-flex;\n    align-items: center;\n    gap: 0.5rem;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let count = $state(0);\n</script>\n\n<div class=\"counter\">\n  <button data-testid=\"decrement-button\" onclick={() => count--}>-</button>\n  <span data-testid=\"count-value\">{count}</span>\n  <button data-testid=\"increment-button\" onclick={() => count++}>+</button>\n</div>\n\n<style>\n  .counter {\n    display: inline-flex;\n    align-items: center;\n    gap: 0.5rem;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet count = $state(0);\n</script>\n\n<div class=\"counter\">\n\t<button data-testid=\"decrement-button\" onclick={() => count--}>-</button>\n\t<span data-testid=\"count-value\">{count}</span>\n\t<button data-testid=\"increment-button\" onclick={() => count++}>+</button>\n</div>\n\n<style>\n\t.counter {\n\t\tdisplay: flex;\n\t\talign-items: center;\n\t\tgap: 0.5rem;\n\t}\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet count = $state(0);\n</script>\n\n<div class=\"counter\">\n\t<button data-testid=\"decrement-button\" onclick={() => count--}>-</button>\n\t<span data-testid=\"count-value\">{count}</span>\n\t<button data-testid=\"increment-button\" onclick={() => count++}>+</button>\n</div>\n\n<style>\n\t.counter {\n\t\tdisplay: flex;\n\t\talign-items: center;\n\t\tgap: 0.5rem;\n\t}\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let count = $state(0);\n</script>\n\n<div class=\"counter\">\n  <button data-testid=\"decrement-button\" onclick={() => count--}>-</button>\n  <span data-testid=\"count-value\">{count}</span>\n  <button data-testid=\"increment-button\" onclick={() => count++}>+</button>\n</div>\n\n<style>\n  .counter {\n    display: flex;\n    align-items: center;\n    gap: 0.5rem;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet count = $state(0);\n</script>\n\n<div class=\"counter\">\n\t<button data-testid=\"decrement-button\" onclick={() => count--}>-</button>\n\t<span data-testid=\"count-value\">{count}</span>\n\t<button data-testid=\"increment-button\" onclick={() => count++}>+</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet count = $state(0);\n</script>\n\n<div class=\"counter\">\n\t<button data-testid=\"decrement-button\" onclick={() => count--}>-</button>\n\t<span data-testid=\"count-value\">{count}</span>\n\t<button data-testid=\"increment-button\" onclick={() => count++}>+</button>\n</div>\n\n<style>\n\t.counter {\n\t\tdisplay: inline-flex;\n\t\talign-items: center;\n\t\tgap: 0.5rem;\n\t}\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let count = $state(0);\n</script>\n\n<div class=\"counter\">\n  <button data-testid=\"decrement-button\" onclick={() => count--}>-</button>\n  <span data-testid=\"count-value\">{count}</span>\n  <button data-testid=\"increment-button\" onclick={() => count++}>+</button>\n</div>\n\n<style>\n  .counter {\n    display: inline-flex;\n    align-items: center;\n    gap: 0.5rem;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let count = $state(0);\n</script>\n\n<div class=\"counter\">\n  <button data-testid=\"decrement-button\" onclick={() => count--}>-</button>\n  <span data-testid=\"count-value\">{count}</span>\n  <button data-testid=\"increment-button\" onclick={() => count++}>+</button>\n</div>\n\n<style>\n  .counter {\n    display: flex;\n    align-items: center;\n    gap: 0.5rem;\n  }\n  .counter button {\n    width: 2rem;\n    height: 2rem;\n    font-size: 1rem;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet count = $state(0);\n</script>\n\n<div class=\"counter\">\n\t<button data-testid=\"decrement-button\" onclick={() => count--}>-</button>\n\t<span data-testid=\"count-value\">{count}</span>\n\t<button data-testid=\"increment-button\" onclick={() => count++}>+</button>\n</div>\n\n<style>\n\t.counter {\n\t\tdisplay: flex;\n\t\talign-items: center;\n\t\tgap: 0.5rem;\n\t}\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  },
  {
    "testName": "derived",
    "provider": "OpenAI",
    "modelId": "o4-mini-2025-04-16",
    "numSamples": 10,
    "numCorrect": 10,
    "pass1": 1,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $derived(number * 2);\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet number = $state(5);\n\tlet doubled = $derived(number * 2);\n</script>\n\n<div>\n\t<p data-testid=\"number-value\">Number: {number}</p>\n\t<p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n\t<button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet number = $state(5);\n\tlet doubled = $derived(number * 2);\n</script>\n<div>\n\t<p data-testid=\"number-value\">Number: {number}</p>\n\t<p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n\t<button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $derived(number * 2);\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  const doubled = $derived(number * 2);\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $derived(number * 2);\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $derived(number * 2);\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $derived(number * 2);\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5)\n  let doubled = $derived(number * 2)\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $derived(number * 2);\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  },
  {
    "testName": "derived-by",
    "provider": "OpenAI",
    "modelId": "o4-mini-2025-04-16",
    "numSamples": 10,
    "numCorrect": 10,
    "pass1": 1,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('');\n  const stats = $derived.by(() => {\n    const words = text.trim().split(/\\s+/).filter(Boolean).length;\n    const chars = text.length;\n    const isLong = words > 15;\n    return { words, chars, isLong };\n  });\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <button data-testid=\"clear-button\" onclick={() => text = ''}>Clear</button>\n  <div>\n    <p data-testid=\"word-count\">Words: {stats.words}</p>\n    <p data-testid=\"char-count\">Characters: {stats.chars}</p>\n    <p data-testid=\"length-indicator\">Status: {stats.isLong ? 'Long text' : 'Short text'}</p>\n  </div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('');\n  let stats = $derived.by(() => {\n    const words = text.trim().split(/\\s+/).filter(Boolean).length;\n    const chars = text.length;\n    const long = words > 15;\n    return { words, chars, long };\n  });\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <button data-testid=\"clear-button\" onclick={() => text = ''}>Clear</button>\n  <div>\n    <p data-testid=\"word-count\">Words: {stats.words}</p>\n    <p data-testid=\"char-count\">Characters: {stats.chars}</p>\n    <p data-testid=\"length-indicator\">Status: {stats.long ? 'Long text' : 'Short text'}</p>\n  </div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet text = $state('');\n\tlet wordCount = $derived.by(() => {\n\t\tconst trimmed = text.trim();\n\t\treturn trimmed ? trimmed.split(/\\s+/).length : 0;\n\t});\n\tlet charCount = $derived.by(() => text.length);\n\tlet isLong = $derived.by(() => wordCount > 15);\n</script>\n\n<div>\n\t<input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n\t<button data-testid=\"clear-button\" onclick={() => text = ''}>Clear</button>\n\t<div>\n\t\t<p data-testid=\"word-count\">Words: {wordCount}</p>\n\t\t<p data-testid=\"char-count\">Characters: {charCount}</p>\n\t\t<p data-testid=\"length-indicator\">Status: {isLong ? 'Long text' : 'Short text'}</p>\n\t</div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet text = $state(\"\");\n\tconst stats = $derived.by(() => {\n\t\tconst trimmed = text.trim();\n\t\tconst words = trimmed ? trimmed.split(/\\s+/) : [];\n\t\treturn {\n\t\t\twordCount: words.length,\n\t\t\tcharCount: text.length,\n\t\t\tisLong: words.length > 15\n\t\t};\n\t});\n</script>\n\n<div>\n\t<input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n\t<button data-testid=\"clear-button\" onclick={() => text = \"\"}>Clear</button>\n\t<div>\n\t\t<p data-testid=\"word-count\">Words: {stats.wordCount}</p>\n\t\t<p data-testid=\"char-count\">Characters: {stats.charCount}</p>\n\t\t<p data-testid=\"length-indicator\">Status: {stats.isLong ? \"Long text\" : \"Short text\"}</p>\n\t</div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('');\n  let wordCount = $derived.by(() => {\n    const trimmed = text.trim();\n    return trimmed ? trimmed.split(/\\s+/).length : 0;\n  });\n  let charCount = $derived.by(() => text.length);\n  let isLong = $derived.by(() => wordCount > 15);\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <button data-testid=\"clear-button\" onclick={() => text = ''}>Clear</button>\n  <div>\n    <p data-testid=\"word-count\">Words: {wordCount}</p>\n    <p data-testid=\"char-count\">Characters: {charCount}</p>\n    <p data-testid=\"length-indicator\">Status: {isLong ? 'Long text' : 'Short text'}</p>\n  </div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('');\n  let wordCount = $derived.by(() => {\n    const trimmed = text.trim();\n    return trimmed ? trimmed.split(/\\s+/).length : 0;\n  });\n  let charCount = $derived.by(() => text.length);\n  let isLong = $derived.by(() => wordCount > 15);\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <button data-testid=\"clear-button\" onclick={() => text = ''}>Clear</button>\n  <div>\n    <p data-testid=\"word-count\">Words: {wordCount}</p>\n    <p data-testid=\"char-count\">Characters: {charCount}</p>\n    <p data-testid=\"length-indicator\">Status: {isLong ? 'Long text' : 'Short text'}</p>\n  </div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('');\n  let wordCount = $derived.by(() => {\n    const trimmed = text.trim();\n    return trimmed ? trimmed.split(/\\s+/).length : 0;\n  });\n  let charCount = $derived.by(() => text.length);\n  let isLong = $derived.by(() => wordCount > 15);\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <button data-testid=\"clear-button\" onclick={() => text = ''}>Clear</button>\n  <div>\n    <p data-testid=\"word-count\">Words: {wordCount}</p>\n    <p data-testid=\"char-count\">Characters: {charCount}</p>\n    <p data-testid=\"length-indicator\">Status: {isLong ? 'Long text' : 'Short text'}</p>\n  </div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('');\n  let wordCount = $derived.by(() => {\n    const words = text.trim() ? text.trim().split(/\\s+/) : [];\n    return words.length;\n  });\n  let charCount = $derived.by(() => text.length);\n  let isLong = $derived.by(() => wordCount > 15);\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <button data-testid=\"clear-button\" onclick={() => text = ''}>Clear</button>\n  <div>\n    <p data-testid=\"word-count\">Words: {wordCount}</p>\n    <p data-testid=\"char-count\">Characters: {charCount}</p>\n    <p data-testid=\"length-indicator\">Status: {isLong ? 'Long text' : 'Short text'}</p>\n  </div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('');\n  let wordCount = $derived.by(() => {\n    const trimmed = text.trim();\n    return trimmed ? trimmed.split(/\\s+/).length : 0;\n  });\n  let charCount = $derived.by(() => text.length);\n  let isLong = $derived.by(() => wordCount > 15);\n  function clear() {\n    text = '';\n  }\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <button data-testid=\"clear-button\" onclick={clear}>Clear</button>\n  <div>\n    <p data-testid=\"word-count\">Words: {wordCount}</p>\n    <p data-testid=\"char-count\">Characters: {charCount}</p>\n    <p data-testid=\"length-indicator\">Status: {isLong ? 'Long text' : 'Short text'}</p>\n  </div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state(\"\");\n  let stats = $derived.by(() => {\n    const chars = text.length;\n    let words = 0;\n    const trimmed = text.trim();\n    if (trimmed) words = trimmed.split(/\\s+/).length;\n    const isLong = words > 15;\n    return { words, chars, isLong };\n  });\n\n  function clearText() {\n    text = \"\";\n  }\n</script>\n\n<div>\n  <input\n    data-testid=\"text-input\"\n    type=\"text\"\n    bind:value={text}\n  />\n  <button data-testid=\"clear-button\" onclick={clearText}>\n    Clear\n  </button>\n  <div>\n    <p data-testid=\"word-count\">Words: {stats.words}</p>\n    <p data-testid=\"char-count\">Characters: {stats.chars}</p>\n    <p data-testid=\"length-indicator\">\n      Status: {stats.isLong ? \"Long text\" : \"Short text\"}\n    </p>\n  </div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  },
  {
    "testName": "each",
    "provider": "OpenAI",
    "modelId": "o4-mini-2025-04-16",
    "numSamples": 10,
    "numCorrect": 10,
    "pass1": 1,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let characters = $state([\"Jerry\", \"Elaine\", \"Kramer\"]);\n</script>\n<div>\n  <ul data-testid=\"characters-list\">\n    {#each characters as character}\n      <li data-testid=\"character\">{character}</li>\n    {/each}\n  </ul>\n  <button data-testid=\"add-george-button\" onclick={() => characters.push(\"George\")}>\n    Add George\n  </button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet characters = $state([\"Jerry\", \"Elaine\", \"Kramer\"]);\n</script>\n\n<div>\n\t<ul data-testid=\"characters-list\">\n\t\t{#each characters as name}\n\t\t\t<li data-testid=\"character\">{name}</li>\n\t\t{/each}\n\t</ul>\n\t<button data-testid=\"add-george-button\" onclick={() => characters.push(\"George\")}>\n\t\tAdd George\n\t</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let characters = $state([\"Jerry\", \"Elaine\", \"Kramer\"]);\n</script>\n<div>\n  <ul data-testid=\"characters-list\">\n    {#each characters as char}\n      <li data-testid=\"character\">{char}</li>\n    {/each}\n  </ul>\n  <button data-testid=\"add-george-button\" onclick={() => characters.push(\"George\")}>\n    Add George\n  </button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let characters = $state([\"Jerry\", \"Elaine\", \"Kramer\"]);\n</script>\n\n<div>\n  <ul data-testid=\"characters-list\">\n    {#each characters as character}\n      <li data-testid=\"character\">{character}</li>\n    {/each}\n  </ul>\n  <button data-testid=\"add-george-button\" onclick={() => characters.push(\"George\")}>\n    Add George\n  </button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let characters = $state([\"Jerry\", \"Elaine\", \"Kramer\"]);\n  function addGeorge() {\n    characters.push(\"George\");\n  }\n</script>\n\n<div>\n  <ul data-testid=\"characters-list\">\n    {#each characters as char}\n      <li data-testid=\"character\">{char}</li>\n    {/each}\n  </ul>\n  <button data-testid=\"add-george-button\" onclick={addGeorge}>Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let characters = $state([\"Jerry\", \"Elaine\", \"Kramer\"]);\n</script>\n<div>\n  <ul data-testid=\"characters-list\">\n    {#each characters as name}\n      <li data-testid=\"character\">{name}</li>\n    {/each}\n  </ul>\n  <button data-testid=\"add-george-button\" onclick={() => characters.push(\"George\")}>\n    Add George\n  </button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let characters = $state(['Jerry', 'Elaine', 'Kramer']);\n</script>\n<div>\n  <ul data-testid=\"characters-list\">\n    {#each characters as character}\n      <li data-testid=\"character\">{character}</li>\n    {/each}\n  </ul>\n  <button data-testid=\"add-george-button\" onclick={() => characters.push('George')}>Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let characters = $state(['Jerry', 'Elaine', 'Kramer'])\n  function addGeorge() {\n    characters.push('George')\n  }\n</script>\n<div>\n  <ul data-testid=\"characters-list\">\n    {#each characters as character}\n      <li data-testid=\"character\">{character}</li>\n    {/each}\n  </ul>\n  <button data-testid=\"add-george-button\" onclick={addGeorge}>Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let characters = $state([\"Jerry\", \"Elaine\", \"Kramer\"]);\n  function addGeorge() {\n    characters.push(\"George\");\n  }\n</script>\n\n<div>\n  <ul data-testid=\"characters-list\">\n    {#each characters as char}\n      <li data-testid=\"character\">{char}</li>\n    {/each}\n  </ul>\n  <button data-testid=\"add-george-button\" onclick={addGeorge}>Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet characters = $state(['Jerry', 'Elaine', 'Kramer']);\n</script>\n<div>\n\t<ul data-testid=\"characters-list\">\n\t\t{#each characters as character}\n\t\t\t<li data-testid=\"character\">{character}</li>\n\t\t{/each}\n\t</ul>\n\t<button data-testid=\"add-george-button\" onclick={() => characters.push('George')}>Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  },
  {
    "testName": "effect",
    "provider": "OpenAI",
    "modelId": "o4-mini-2025-04-16",
    "numSamples": 10,
    "numCorrect": 10,
    "pass1": 1,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $state(0);\n  $effect(() => {\n    doubled = number * 2;\n  });\n</script>\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $state(0);\n  $effect(() => {\n    doubled = number * 2;\n  });\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $state(0);\n  $effect(() => {\n    doubled = number * 2;\n  });\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet number = $state(5);\n\tlet doubled = $state(0);\n\t$effect(() => {\n\t\tdoubled = number * 2;\n\t});\n</script>\n\n<div>\n\t<p data-testid=\"number-value\">Number: {number}</p>\n\t<p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n\t<button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $state(number * 2);\n  $effect(() => doubled = number * 2);\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $state(number * 2);\n\n  $effect(() => {\n    doubled = number * 2;\n  });\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $state(0);\n  $effect(() => {\n    doubled = number * 2;\n  });\n</script>\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $state(0);\n\n  $effect(() => {\n    doubled = number * 2;\n  });\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $state(0);\n\n  $effect(() => {\n    doubled = number * 2;\n  });\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $state(0);\n  $effect(() => {\n    doubled = number * 2;\n  });\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number += 1}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  },
  {
    "testName": "hello-world",
    "provider": "OpenAI",
    "modelId": "o4-mini-2025-04-16",
    "numSamples": 10,
    "numCorrect": 10,
    "pass1": 1,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n</script>\n\n<style>\n  .greeting {\n    color: blue;\n    text-align: center;\n    margin: 1rem;\n  }\n</style>\n\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>",
        "success": true,
        "errors": [],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<script>\n</script>\n\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>\n\n<style>\n  .greeting {\n    color: blue;\n    text-align: center;\n    margin: 1rem;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>\n\n<style>\n  .greeting {\n    color: blue;\n    text-align: center;\n    margin: 1rem;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<script>\n</script>\n\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>\n\n<style>\n  .greeting {\n    color: blue;\n    text-align: center;\n    margin: 1rem;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<script>\n</script>\n\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>\n\n<style>\n  .greeting {\n    color: blue;\n    text-align: center;\n    margin: 1rem;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<script>\n</script>\n\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>\n\n<style>\n  .greeting {\n    color: blue;\n    text-align: center;\n    margin: 1rem;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<script>\n</script>\n\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>\n\n<style>\n  .greeting {\n    color: blue;\n    text-align: center;\n    margin: 1rem;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<script>\n</script>\n\n<style>\n  .greeting {\n    color: blue;\n    text-align: center;\n    margin: 1rem;\n  }\n</style>\n\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<script>\n</script>\n\n<style>\n  .greeting {\n    color: blue;\n    text-align: center;\n    margin: 1rem;\n  }\n</style>\n\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<script>\n</script>\n\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>\n\n<style>\n  .greeting {\n    color: blue;\n    text-align: center;\n    margin: 1rem auto;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  },
  {
    "testName": "inspect",
    "provider": "OpenAI",
    "modelId": "o4-mini-2025-04-16",
    "numSamples": 10,
    "numCorrect": 0,
    "pass1": 0,
    "pass10": 0,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state(\"Hello world\");\n  const charCount = $derived(text.length);\n\n  $inspect(text);\n  $inspect(text).with(value => console.log(\"Custom inspect:\", value));\n  $effect(() => {\n    $inspect(text).trace();\n  });\n</script>\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <p data-testid=\"text-value\">Current text: {text}</p>\n  <p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "Cannot read properties of undefined (reading 'trace')\n\n\tin $effect\n\tin Component.svelte\n",
          "Cannot read properties of undefined (reading 'trace')\n\n\tin $effect\n\tin Component.svelte\n",
          "Cannot read properties of undefined (reading 'trace')\n\n\tin $effect\n\tin Component.svelte\n",
          "Cannot read properties of undefined (reading 'trace')\n\n\tin $effect\n\tin Component.svelte\n"
        ],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state(\"Hello world\");\n  $inspect(text);\n  const inspector = $inspect(text);\n  inspector.with(value => console.log(\"Input updated:\", value));\n  $effect(() => {\n    inspector.trace();\n  });\n  const charCount = $derived(text.length);\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <p data-testid=\"text-value\">Current text: {text}</p>\n  <p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "Cannot read properties of undefined (reading 'with')",
          "Cannot read properties of undefined (reading 'with')",
          "Cannot read properties of undefined (reading 'with')",
          "Cannot read properties of undefined (reading 'with')"
        ],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state(\"Hello world\");\n  $inspect(text);\n  $inspect(text).with(value => console.log(\"Text updated:\", value));\n  $effect(() => {\n    $inspect.trace();\n  });\n  const charCount = $derived(text.length);\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <p data-testid=\"text-value\">Current text: {text}</p>\n  <p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"Hello world\"\u001b[39m\nReceived:\n\u001b[31m  Current text: Hello world\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"Testing $inspect\"\u001b[39m\nReceived:\n\u001b[31m  Current text: Testing $inspect\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"!@#$%^&*()\"\u001b[39m\nReceived:\n\u001b[31m  Current text: !@#$%^&*()\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"\"\u001b[39m\nReceived:\n\u001b[31m  Current text:\u001b[39m"
        ],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet text = $state(\"Hello world\");\n\tlet charCount = $derived(text.length);\n\t$inspect(text);\n\t$inspect(text).with((value) => console.log(\"Text updated via inspect.with():\", value));\n\t$effect(() => {\n\t\t$inspect(text).trace();\n\t});\n</script>\n\n<div>\n\t<input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n\t<p data-testid=\"text-value\">Current text: {text}</p>\n\t<p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "Cannot read properties of undefined (reading 'trace')\n\n\tin $effect\n\tin Component.svelte\n",
          "Cannot read properties of undefined (reading 'trace')\n\n\tin $effect\n\tin Component.svelte\n",
          "Cannot read properties of undefined (reading 'trace')\n\n\tin $effect\n\tin Component.svelte\n",
          "Cannot read properties of undefined (reading 'trace')\n\n\tin $effect\n\tin Component.svelte\n"
        ],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet text = $state(\"Hello world\");\n\tconst charCount = $derived(text.length);\n\n\t$inspect(text);\n\t$inspect(text).with((value) => console.log(\"Input updated:\", value));\n\n\t$effect(() => {\n\t\t$inspect(text).trace();\n\t});\n</script>\n\n<div>\n\t<input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n\t<p data-testid=\"text-value\">Current text: {text}</p>\n\t<p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "Cannot read properties of undefined (reading 'trace')\n\n\tin $effect\n\tin Component.svelte\n",
          "Cannot read properties of undefined (reading 'trace')\n\n\tin $effect\n\tin Component.svelte\n",
          "Cannot read properties of undefined (reading 'trace')\n\n\tin $effect\n\tin Component.svelte\n",
          "Cannot read properties of undefined (reading 'trace')\n\n\tin $effect\n\tin Component.svelte\n"
        ],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state(\"Hello world\");\n  $inspect(text);\n  $inspect(text).with(value => console.log(\"Input changed to:\", value));\n  $effect(() => {\n    $inspect(text).trace();\n  });\n  let charCount = $derived(text.length);\n</script>\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <p data-testid=\"text-value\">Current text: {text}</p>\n  <p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "Cannot read properties of undefined (reading 'trace')\n\n\tin $effect\n\tin Component.svelte\n",
          "Cannot read properties of undefined (reading 'trace')\n\n\tin $effect\n\tin Component.svelte\n",
          "Cannot read properties of undefined (reading 'trace')\n\n\tin $effect\n\tin Component.svelte\n",
          "Cannot read properties of undefined (reading 'trace')\n\n\tin $effect\n\tin Component.svelte\n"
        ],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet text = $state(\"Hello world\");\n\tlet charCount = $derived(text.length);\n\n\t$inspect(text);\n\t$inspect(text).with(val => console.log(\"Value updated to:\", val));\n\n\t$effect(() => {\n\t\t$inspect.trace();\n\t});\n</script>\n\n<div>\n\t<input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n\t<p data-testid=\"text-value\">Current text: {text}</p>\n\t<p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"Hello world\"\u001b[39m\nReceived:\n\u001b[31m  Current text: Hello world\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"Testing $inspect\"\u001b[39m\nReceived:\n\u001b[31m  Current text: Testing $inspect\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"!@#$%^&*()\"\u001b[39m\nReceived:\n\u001b[31m  Current text: !@#$%^&*()\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"\"\u001b[39m\nReceived:\n\u001b[31m  Current text:\u001b[39m"
        ],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state(\"Hello world\");\n  $inspect(text);\n  $inspect(text).with((value) => console.log(\"Text updated:\", value));\n  $effect(() => {\n    $inspect.trace();\n  });\n  let charCount = $derived(text.length);\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <p data-testid=\"text-value\">Current text: {text}</p>\n  <p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"Hello world\"\u001b[39m\nReceived:\n\u001b[31m  Current text: Hello world\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"Testing $inspect\"\u001b[39m\nReceived:\n\u001b[31m  Current text: Testing $inspect\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"!@#$%^&*()\"\u001b[39m\nReceived:\n\u001b[31m  Current text: !@#$%^&*()\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"\"\u001b[39m\nReceived:\n\u001b[31m  Current text:\u001b[39m"
        ],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state(\"Hello world\");\n  $inspect(text);\n  $inspect(text).with(value => console.log(\"Text updated:\", value));\n  let charCount = $derived(text.length);\n  $effect(() => {\n    $inspect.trace();\n  });\n</script>\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <p data-testid=\"text-value\">Current text: {text}</p>\n  <p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"Hello world\"\u001b[39m\nReceived:\n\u001b[31m  Current text: Hello world\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"Testing $inspect\"\u001b[39m\nReceived:\n\u001b[31m  Current text: Testing $inspect\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"!@#$%^&*()\"\u001b[39m\nReceived:\n\u001b[31m  Current text: !@#$%^&*()\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"\"\u001b[39m\nReceived:\n\u001b[31m  Current text:\u001b[39m"
        ],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state(\"Hello world\");\n  const charCount = $derived(text.length);\n\n  $inspect(text);\n  $inspect(text).with(value => console.log(\"Custom inspect: text changed to\", value));\n  $effect(() => {\n    $inspect.trace(text);\n  });\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <p data-testid=\"text-value\">Current text: {text}</p>\n  <p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"Hello world\"\u001b[39m\nReceived:\n\u001b[31m  Current text: Hello world\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"Testing $inspect\"\u001b[39m\nReceived:\n\u001b[31m  Current text: Testing $inspect\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"!@#$%^&*()\"\u001b[39m\nReceived:\n\u001b[31m  Current text: !@#$%^&*()\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"\"\u001b[39m\nReceived:\n\u001b[31m  Current text:\u001b[39m"
        ],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  },
  {
    "testName": "props",
    "provider": "OpenAI",
    "modelId": "o4-mini-2025-04-16",
    "numSamples": 10,
    "numCorrect": 10,
    "pass1": 1,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let { name = \"World\", count = 0, showDetails = false } = $props();\n  let currentCount = $state(count);\n</script>\n\n<div>\n  <h1 data-testid=\"name-display\">Hello, {name}!</h1>\n  <p data-testid=\"count-display\">Count: {currentCount}</p>\n  <button data-testid=\"increment-button\" onclick={() => currentCount++}>Increment</button>\n  {#if showDetails}\n    <div data-testid=\"details\">\n      <p>Name is {name}</p>\n      <p>Count is {currentCount}</p>\n      <p>ShowDetails is true</p>\n    </div>\n  {/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let { name = 'World', count: initialCount = 0, showDetails = false } = $props();\n  let count = $state(initialCount);\n</script>\n\n<div>\n  <h1 data-testid=\"name-display\">Hello, {name}!</h1>\n  <p data-testid=\"count-display\">Count: {count}</p>\n  <button data-testid=\"increment-button\" onclick={() => count++}>Increment</button>\n  {#if showDetails}\n    <div data-testid=\"details\">\n      <p>Name is {name}</p>\n      <p>Count is {count}</p>\n      <p>ShowDetails is {showDetails}</p>\n    </div>\n  {/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let { name = \"World\", count: initialCount = 0, showDetails = false } = $props();\n  let count = $state(initialCount);\n</script>\n\n<div>\n  <h1 data-testid=\"name-display\">Hello, {name}!</h1>\n  <p data-testid=\"count-display\">Count: {count}</p>\n  <button data-testid=\"increment-button\" onclick={() => count++}>Increment</button>\n\n  {#if showDetails}\n    <div data-testid=\"details\">\n      <p>Name is {name}</p>\n      <p>Count is {count}</p>\n      <p>ShowDetails is {showDetails}</p>\n    </div>\n  {/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let { name = \"World\", count: initialCount = 0, showDetails = false } = $props();\n  let count = $state(initialCount);\n</script>\n<div>\n  <h1 data-testid=\"name-display\">Hello, {name}!</h1>\n  <p data-testid=\"count-display\">Count: {count}</p>\n  <button data-testid=\"increment-button\" onclick={() => count++}>Increment</button>\n  {#if showDetails}\n    <div data-testid=\"details\">\n      <p>Name is {name}</p>\n      <p>Count is {count}</p>\n      <p>ShowDetails is {showDetails}</p>\n    </div>\n  {/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let { name = \"World\", count: propCount = 0, showDetails = false } = $props();\n  let count = $state(propCount);\n</script>\n\n<div>\n  <h1 data-testid=\"name-display\">Hello, {name}!</h1>\n  <p data-testid=\"count-display\">Count: {count}</p>\n  <button data-testid=\"increment-button\" onclick={() => count++}>Increment</button>\n  {#if showDetails}\n    <div data-testid=\"details\">\n      <p>Name is {name}</p>\n      <p>Count is {count}</p>\n      <p>ShowDetails is {showDetails}</p>\n    </div>\n  {/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let { name = 'World', count = 0, showDetails = false } = $props();\n  let countState = $state(count);\n</script>\n\n<div>\n  <h1 data-testid=\"name-display\">Hello, {name}!</h1>\n  <p data-testid=\"count-display\">Count: {countState}</p>\n  <button data-testid=\"increment-button\" onclick={() => countState++}>Increment</button>\n  {#if showDetails}\n    <div data-testid=\"details\">\n      <p>Name is {name}</p>\n      <p>Count is {countState}</p>\n      <p>ShowDetails is {showDetails}</p>\n    </div>\n  {/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let { name = \"World\", count = 0, showDetails = false } = $props();\n  let currentCount = $state(count);\n</script>\n\n<div>\n  <h1 data-testid=\"name-display\">Hello, {name}!</h1>\n  <p data-testid=\"count-display\">Count: {currentCount}</p>\n  <button data-testid=\"increment-button\" onclick={() => currentCount++}>Increment</button>\n  {#if showDetails}\n    <div data-testid=\"details\">\n      <p>Name is {name}</p>\n      <p>Count is {currentCount}</p>\n      <p>ShowDetails is {showDetails}</p>\n    </div>\n  {/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let { name = \"World\", count: initialCount = 0, showDetails = false } = $props();\n  let count = $state(initialCount);\n</script>\n\n<div>\n  <h1 data-testid=\"name-display\">Hello, {name}!</h1>\n  <p data-testid=\"count-display\">Count: {count}</p>\n  <button data-testid=\"increment-button\" onclick={() => count++}>Increment</button>\n  {#if showDetails}\n    <div data-testid=\"details\">\n      <p>Name is {name}</p>\n      <p>Count is {count}</p>\n      <p>ShowDetails is {showDetails}</p>\n    </div>\n  {/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let { name = 'World', count = 0, showDetails = false } = $props();\n  let stateCount = $state(count);\n</script>\n\n<div>\n  <h1 data-testid=\"name-display\">Hello, {name}!</h1>\n  <p data-testid=\"count-display\">Count: {stateCount}</p>\n  <button data-testid=\"increment-button\" onclick={() => stateCount++}>Increment</button>\n  {#if showDetails}\n    <div data-testid=\"details\">\n      <p>Name is {name}</p>\n      <p>Count is {stateCount}</p>\n      <p>ShowDetails is {showDetails}</p>\n    </div>\n  {/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let { name = \"World\", count: initialCount = 0, showDetails = false } = $props();\n  let count = $state(initialCount);\n</script>\n\n<div>\n  <h1 data-testid=\"name-display\">Hello, {name}!</h1>\n  <p data-testid=\"count-display\">Count: {count}</p>\n  <button data-testid=\"increment-button\" onclick={() => count++}>Increment</button>\n  {#if showDetails}\n    <div data-testid=\"details\">\n      <p>Name is {name}</p>\n      <p>Count is {count}</p>\n      <p>ShowDetails is {showDetails}</p>\n    </div>\n  {/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  },
  {
    "testName": "snippets",
    "provider": "OpenAI",
    "modelId": "o4-mini-2025-04-16",
    "numSamples": 10,
    "numCorrect": 10,
    "pass1": 1,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let books = $state([\"The Lord of the Rings\", \"To Kill a Mockingbird\", \"1984\"]);\n</script>\n{#snippet title(book)}\n  <span data-testid=\"book-title\">{book}</span>\n{/snippet}\n<ul>\n  {#each books as book}\n    <li data-testid=\"book-item\">{@render title(book)}</li>\n  {/each}\n</ul>",
        "success": true,
        "errors": [],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet books = $state([\n\t\t\"The Lord of the Rings\",\n\t\t\"To Kill a Mockingbird\",\n\t\t\"1984\"\n\t]);\n</script>\n\n{#snippet title(book)}\n\t<span data-testid=\"book-title\">{book}</span>\n{/snippet}\n\n<ul>\n\t{#each books as book}\n\t\t<li data-testid=\"book-item\">\n\t\t\t{@render title(book)}\n\t\t</li>\n\t{/each}\n</ul>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let books = $state([\n    \"The Lord of the Rings\",\n    \"To Kill a Mockingbird\",\n    \"1984\"\n  ]);\n</script>\n\n{#snippet title(book)}\n  <span data-testid=\"book-title\">{book}</span>\n{/snippet}\n\n<ul>\n  {#each books as book}\n    <li data-testid=\"book-item\">\n      {@render title(book)}\n    </li>\n  {/each}\n</ul>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet books = $state([\n\t\t\"The Lord of the Rings\",\n\t\t\"To Kill a Mockingbird\",\n\t\t\"1984\"\n\t]);\n</script>\n\n{#snippet title(book)}\n\t<span data-testid=\"book-title\">{book}</span>\n{/snippet}\n\n<ul>\n\t{#each books as book}\n\t\t<li data-testid=\"book-item\">\n\t\t\t{@render title(book)}\n\t\t</li>\n\t{/each}\n</ul>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let books = $state([\n    \"The Lord of the Rings\",\n    \"To Kill a Mockingbird\",\n    \"1984\"\n  ]);\n</script>\n\n{#snippet title(bookTitle)}\n  <span data-testid=\"book-title\">{bookTitle}</span>\n{/snippet}\n\n<ul>\n  {#each books as book}\n    <li data-testid=\"book-item\">\n      {@render title(book)}\n    </li>\n  {/each}\n</ul>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let books = $state([\"The Lord of the Rings\", \"To Kill a Mockingbird\", \"1984\"]);\n</script>\n\n{#snippet title(text)}\n  <span data-testid=\"book-title\">{text}</span>\n{/snippet}\n\n<ul>\n  {#each books as book}\n    <li data-testid=\"book-item\">\n      {@render title(book)}\n    </li>\n  {/each}\n</ul>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let books = $state([\n    \"The Lord of the Rings\",\n    \"To Kill a Mockingbird\",\n    \"1984\"\n  ]);\n</script>\n\n{#snippet title(book)}\n  <span data-testid=\"book-title\">{book}</span>\n{/snippet}\n\n<ul>\n  {#each books as book}\n    <li data-testid=\"book-item\">\n      {@render title(book)}\n    </li>\n  {/each}\n</ul>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let books = $state(['The Lord of the Rings', 'To Kill a Mockingbird', '1984']);\n</script>\n\n{#snippet title(book)}\n  <span data-testid=\"book-title\">{book}</span>\n{/snippet}\n\n<ul>\n  {#each books as book}\n    <li data-testid=\"book-item\">\n      {@render title(book)}\n    </li>\n  {/each}\n</ul>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let books = $state([\n    \"The Lord of the Rings\",\n    \"To Kill a Mockingbird\",\n    \"1984\"\n  ]);\n</script>\n\n{#snippet title(book)}\n  <span data-testid=\"book-title\">{book}</span>\n{/snippet}\n\n<ul>\n  {#each books as book}\n    <li data-testid=\"book-item\">{@render title(book)}</li>\n  {/each}\n</ul>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet books = $state([\n\t\t\"The Lord of the Rings\",\n\t\t\"To Kill a Mockingbird\",\n\t\t\"1984\"\n\t]);\n</script>\n\n{#snippet title(book)}\n\t<span data-testid=\"book-title\">{book}</span>\n{/snippet}\n\n<ul>\n\t{#each books as book}\n\t\t<li data-testid=\"book-item\">{@render title(book)}</li>\n\t{/each}\n</ul>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  },
  {
    "testName": "counter",
    "provider": "OpenAI",
    "modelId": "o3-mini-2025-01-31",
    "numSamples": 10,
    "numCorrect": 10,
    "pass1": 1,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet count = $state(0);\n</script>\n\n<div class=\"counter\">\n\t<button data-testid=\"decrement-button\" onclick={() => count--}>-</button>\n\t<span data-testid=\"count-value\">{count}</span>\n\t<button data-testid=\"increment-button\" onclick={() => count++}>+</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet count = $state(0);\n</script>\n\n<div class=\"counter\">\n\t<button data-testid=\"decrement-button\" onclick={() => count--}>-</button>\n\t<span data-testid=\"count-value\">{count}</span>\n\t<button data-testid=\"increment-button\" onclick={() => count++}>+</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let count = $state(0);\n</script>\n\n<div class=\"counter\">\n  <button data-testid=\"decrement-button\" onclick={() => count--}>-</button>\n  <span data-testid=\"count-value\">{count}</span>\n  <button data-testid=\"increment-button\" onclick={() => count++}>+</button>\n</div>\n\n<style>\n  .counter {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet count = $state(0);\n</script>\n\n<div class=\"counter\">\n\t<button data-testid=\"decrement-button\" onclick={() => count -= 1}>-</button>\n\t<span data-testid=\"count-value\">{count}</span>\n\t<button data-testid=\"increment-button\" onclick={() => count += 1}>+</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let count = $state(0);\n</script>\n\n<div class=\"counter\">\n  <button data-testid=\"decrement-button\" onclick={() => count--}>-</button>\n  <span data-testid=\"count-value\">{count}</span>\n  <button data-testid=\"increment-button\" onclick={() => count++}>+</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let count = $state(0);\n</script>\n\n<div class=\"counter\">\n  <button data-testid=\"decrement-button\" onclick={() => count--}>-</button>\n  <span data-testid=\"count-value\">{count}</span>\n  <button data-testid=\"increment-button\" onclick={() => count++}>+</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet count = $state(0);\n</script>\n\n<div class=\"counter\">\n\t<button data-testid=\"decrement-button\" onclick={() => count--}>-</button>\n\t<span data-testid=\"count-value\">{count}</span>\n\t<button data-testid=\"increment-button\" onclick={() => count++}>+</button>\n</div>\n\n<style>\n\t.counter {\n\t\tdisplay: flex;\n\t\talign-items: center;\n\t\tgap: 1rem;\n\t}\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet count = $state(0);\n</script>\n\n<div class=\"counter\">\n\t<button data-testid=\"decrement-button\" onclick={() => count--}>-</button>\n\t<span data-testid=\"count-value\">{count}</span>\n\t<button data-testid=\"increment-button\" onclick={() => count++}>+</button>\n</div>\n\n<style>\n\t.counter {\n\t\tdisplay: flex;\n\t\talign-items: center;\n\t\tgap: 10px;\n\t}\n\tbutton {\n\t\tpadding: 5px 10px;\n\t\tfont-size: 16px;\n\t}\n\tspan {\n\t\tfont-size: 18px;\n\t}\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet count = $state(0);\n</script>\n\n<div class=\"counter\">\n\t<button data-testid=\"decrement-button\" onclick={() => count--}>-</button>\n\t<span data-testid=\"count-value\">{count}</span>\n\t<button data-testid=\"increment-button\" onclick={() => count++}>+</button>\n</div>\n\n<style>\n\t.counter {\n\t\tdisplay: flex;\n\t\talign-items: center;\n\t\tgap: 1rem;\n\t}\n\tbutton {\n\t\tfont-size: 1rem;\n\t\tpadding: 0.5rem 1rem;\n\t}\n\tspan {\n\t\tfont-size: 1.2rem;\n\t}\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet count = $state(0);\n</script>\n\n<div class=\"counter\">\n\t<button data-testid=\"decrement-button\" onclick={() => count--}>-</button>\n\t<span data-testid=\"count-value\">{count}</span>\n\t<button data-testid=\"increment-button\" onclick={() => count++}>+</button>\n</div>\n\n<style>\n\t.counter {\n\t\tdisplay: flex;\n\t\talign-items: center;\n\t}\n\t\n\t.counter button {\n\t\tfont-size: 1.5rem;\n\t\tpadding: 0.5rem;\n\t}\n\t\n\t.counter span {\n\t\tmargin: 0 1rem;\n\t\tfont-size: 1.5rem;\n\t}\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  },
  {
    "testName": "derived",
    "provider": "OpenAI",
    "modelId": "o3-mini-2025-01-31",
    "numSamples": 10,
    "numCorrect": 10,
    "pass1": 1,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet number = $state(5);\n\tlet doubled = $derived(number * 2);\n</script>\n\n<div>\n\t<p data-testid=\"number-value\">Number: {number}</p>\n\t<p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n\t<button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet number = $state(5);\n\tlet doubled = $derived(number * 2);\n</script>\n\n<div>\n\t<p data-testid=\"number-value\">Number: {number}</p>\n\t<p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n\t<button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $derived(number * 2);\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet number = $state(5);\n\tlet doubled = $derived(number * 2);\n</script>\n\n<div>\n\t<p data-testid=\"number-value\">Number: {number}</p>\n\t<p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n\t<button data-testid=\"increment-button\" onclick={() => number += 1}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet number = $state(5);\n\tlet doubled = $derived(number * 2);\n</script>\n\n<div>\n\t<p data-testid=\"number-value\">Number: {number}</p>\n\t<p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n\t<button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet number = $state(5);\n\tlet doubled = $derived(number * 2);\n</script>\n\n<div>\n\t<p data-testid=\"number-value\">Number: {number}</p>\n\t<p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n\t<button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet count = $state(5);\n\tlet doubled = $derived(count * 2);\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {count}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => count += 1}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet number = $state(5);\n\tlet doubled = $derived(number * 2);\n</script>\n\n<div>\n\t<p data-testid=\"number-value\">Number: {number}</p>\n\t<p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n\t<button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet number = $state(5);\n\tconst doubled = $derived(number * 2);\n</script>\n\n<div>\n\t<p data-testid=\"number-value\">Number: {number}</p>\n\t<p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n\t<button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet number = $state(5);\n\tlet doubled = $derived(number * 2);\n</script>\n\n<div>\n\t<p data-testid=\"number-value\">Number: {number}</p>\n\t<p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n\t<button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  },
  {
    "testName": "derived-by",
    "provider": "OpenAI",
    "modelId": "o3-mini-2025-01-31",
    "numSamples": 10,
    "numCorrect": 10,
    "pass1": 1,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet text = $state(\"\");\n\tconst stats = $derived.by(() => {\n\t\tconst trimmed = text.trim();\n\t\tconst words = trimmed ? trimmed.split(/\\s+/) : [];\n\t\treturn {\n\t\t\twordCount: words.length,\n\t\t\tcharCount: text.length,\n\t\t\tisLong: words.length > 15 ? \"Long text\" : \"Short text\"\n\t\t};\n\t});\n\tfunction clearText() {\n\t\ttext = \"\";\n\t}\n</script>\n\n<div>\n\t<input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n\t<button data-testid=\"clear-button\" onclick={clearText}>Clear</button>\n\t<div>\n\t\t<p data-testid=\"word-count\">Words: {stats.wordCount}</p>\n\t\t<p data-testid=\"char-count\">Characters: {stats.charCount}</p>\n\t\t<p data-testid=\"length-indicator\">Status: {stats.isLong}</p>\n\t</div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet text = $state('');\n\tlet stats = $derived.by(() => {\n\t\tconst trimmed = text.trim();\n\t\tconst wordCount = trimmed === '' ? 0 : trimmed.split(/\\s+/).length;\n\t\tconst charCount = text.length;\n\t\tconst isLong = wordCount > 15;\n\t\treturn { wordCount, charCount, isLong };\n\t});\n</script>\n\n<div>\n\t<input data-testid=\"text-input\" type=\"text\" value={text} oninput={e => text = e.target.value} />\n\t<button data-testid=\"clear-button\" onclick={() => text = ''}>Clear</button>\n\t<div>\n\t\t<p data-testid=\"word-count\">Words: {stats.wordCount}</p>\n\t\t<p data-testid=\"char-count\">Characters: {stats.charCount}</p>\n\t\t<p data-testid=\"length-indicator\">Status: {stats.isLong ? 'Long text' : 'Short text'}</p>\n\t</div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet text = $state(\"\");\n\tconst derivedData = $derived.by(() => {\n\t\tconst trimmed = text.trim();\n\t\tconst wordCount = trimmed ? trimmed.split(/\\s+/).length : 0;\n\t\tconst charCount = text.length;\n\t\tconst isLong = wordCount > 15;\n\t\treturn { wordCount, charCount, isLong };\n\t});\n\t\n\tfunction clearText() {\n\t\ttext = \"\";\n\t}\n</script>\n\n<div>\n\t<input\n\t\tdata-testid=\"text-input\"\n\t\ttype=\"text\"\n\t\tvalue={text}\n\t\toninput={e => text = e.target.value}\n\t/>\n\t<button data-testid=\"clear-button\" onclick={clearText}>Clear</button>\n\t<div>\n\t\t<p data-testid=\"word-count\">Words: {derivedData.wordCount}</p>\n\t\t<p data-testid=\"char-count\">Characters: {derivedData.charCount}</p>\n\t\t<p data-testid=\"length-indicator\">Status: {derivedData.isLong ? 'Long text' : 'Short text'}</p>\n\t</div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet text = $state(\"\");\n\tconst derivedData = $derived.by(() => {\n\t\tconst trimmed = text.trim();\n\t\tconst words = trimmed ? trimmed.split(/\\s+/) : [];\n\t\tconst wordCount = words.length;\n\t\tconst charCount = text.length;\n\t\tconst isLong = wordCount > 15;\n\t\treturn { wordCount, charCount, isLong };\n\t});\n</script>\n\n<div>\n\t<input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n\t<button data-testid=\"clear-button\" onclick={() => (text = \"\")}>Clear</button>\n\t<div>\n\t\t<p data-testid=\"word-count\">Words: {derivedData.wordCount}</p>\n\t\t<p data-testid=\"char-count\">Characters: {derivedData.charCount}</p>\n\t\t<p data-testid=\"length-indicator\">Status: {derivedData.isLong ? \"Long text\" : \"Short text\"}</p>\n\t</div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet text = $state('');\n\tconst stats = $derived.by(() => {\n\t\tconst trimmed = text.trim();\n\t\tconst words = trimmed ? trimmed.split(/\\s+/).length : 0;\n\t\tconst chars = text.length;\n\t\tconst isLong = words > 15;\n\t\treturn { words, chars, isLong };\n\t});\n</script>\n<div>\n\t<input data-testid=\"text-input\" type=\"text\" value={text} oninput={(e) => text = e.target.value} />\n\t<button data-testid=\"clear-button\" onclick={() => text = ''}>Clear</button>\n\t<div>\n\t\t<p data-testid=\"word-count\">Words: {stats.words}</p>\n\t\t<p data-testid=\"char-count\">Characters: {stats.chars}</p>\n\t\t<p data-testid=\"length-indicator\">Status: {stats.isLong ? 'Long text' : 'Short text'}</p>\n\t</div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet text = $state('');\n\t\n\tconst stats = $derived.by(() => {\n\t\tconst trimmed = text.trim();\n\t\tconst words = trimmed ? trimmed.split(/\\s+/).length : 0;\n\t\tconst chars = text.length;\n\t\tconst status = words > 15 ? \"Long text\" : \"Short text\";\n\t\treturn { wordCount: words, charCount: chars, status };\n\t});\n</script>\n\n<div>\n\t<input data-testid=\"text-input\" type=\"text\" value={text} oninput={e => text = e.target.value} />\n\t<button data-testid=\"clear-button\" onclick={() => text = ''}>Clear</button>\n\t<div>\n\t\t<p data-testid=\"word-count\">Words: {stats.wordCount}</p>\n\t\t<p data-testid=\"char-count\">Characters: {stats.charCount}</p>\n\t\t<p data-testid=\"length-indicator\">Status: {stats.status}</p>\n\t</div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet text = $state(\"\");\n\t\n\tconst stats = $derived.by(() => {\n\t\tconst trimmed = text.trim();\n\t\tconst words = trimmed ? trimmed.split(/\\s+/) : [];\n\t\tconst wordCount = words.length;\n\t\tconst charCount = text.length;\n\t\tconst longText = wordCount > 15;\n\t\treturn { wordCount, charCount, longText };\n\t});\n\t\n\tfunction clearText() {\n\t\ttext = \"\";\n\t}\n</script>\n\n<div>\n\t<input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n\t<button data-testid=\"clear-button\" onclick={clearText}>Clear</button>\n\t<div>\n\t\t<p data-testid=\"word-count\">Words: {stats.wordCount}</p>\n\t\t<p data-testid=\"char-count\">Characters: {stats.charCount}</p>\n\t\t<p data-testid=\"length-indicator\">\n\t\t\tStatus: {stats.longText ? \"Long text\" : \"Short text\"}\n\t\t</p>\n\t</div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('');\n  const stats = $derived.by(() => {\n    const trimmed = text.trim();\n    const words = trimmed ? trimmed.split(/\\s+/).length : 0;\n    const characters = text.length;\n    const longStatus = words > 15 ? \"Long text\" : \"Short text\";\n    return { words, characters, longStatus };\n  });\n  function clearText() {\n    text = '';\n  }\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <button data-testid=\"clear-button\" onclick={clearText}>Clear</button>\n  <div>\n    <p data-testid=\"word-count\">Words: {stats.words}</p>\n    <p data-testid=\"char-count\">Characters: {stats.characters}</p>\n    <p data-testid=\"length-indicator\">Status: {stats.longStatus}</p>\n  </div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet text = $state(\"\");\n\tlet stats = $derived.by(() => {\n\t\tconst trimmed = text.trim();\n\t\tconst words = trimmed === \"\" ? 0 : trimmed.split(/\\s+/).length;\n\t\tconst characters = text.length;\n\t\tconst isLong = words > 15;\n\t\treturn { words, characters, isLong };\n\t});\n</script>\n\n<div>\n\t<input data-testid=\"text-input\" type=\"text\" value={text} oninput={e => text = e.target.value} />\n\t<button data-testid=\"clear-button\" onclick={() => text = \"\"}>Clear</button>\n\t<div>\n\t\t<p data-testid=\"word-count\">Words: {stats.words}</p>\n\t\t<p data-testid=\"char-count\">Characters: {stats.characters}</p>\n\t\t<p data-testid=\"length-indicator\">Status: {stats.isLong ? \"Long text\" : \"Short text\"}</p>\n\t</div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet text = $state(\"\");\n\tconst { wordCount, charCount, isLong } = $derived.by(() => {\n\t\tconst trimmed = text.trim();\n\t\tconst words = trimmed === \"\" ? 0 : trimmed.split(/\\s+/).length;\n\t\tconst chars = text.length;\n\t\treturn { wordCount: words, charCount: chars, isLong: words > 15 };\n\t});\n\tfunction clearText() {\n\t\ttext = \"\";\n\t}\n</script>\n<div>\n\t<input data-testid=\"text-input\" type=\"text\" value={text} oninput={(e) => text = e.target.value} />\n\t<button data-testid=\"clear-button\" onclick={clearText}>Clear</button>\n\t<div>\n\t\t<p data-testid=\"word-count\">Words: {wordCount}</p>\n\t\t<p data-testid=\"char-count\">Characters: {charCount}</p>\n\t\t<p data-testid=\"length-indicator\">Status: {isLong ? \"Long text\" : \"Short text\"}</p>\n\t</div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  },
  {
    "testName": "each",
    "provider": "OpenAI",
    "modelId": "o3-mini-2025-01-31",
    "numSamples": 10,
    "numCorrect": 10,
    "pass1": 1,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet characters = $state([\"Jerry\", \"Elaine\", \"Kramer\"]);\n\tfunction addGeorge() {\n\t\tcharacters.push(\"George\");\n\t}\n</script>\n\n<div>\n\t<ul data-testid=\"characters-list\">\n\t\t{#each characters as character}\n\t\t\t<li data-testid=\"character\">{character}</li>\n\t\t{/each}\n\t</ul>\n\t<button data-testid=\"add-george-button\" onclick={addGeorge}>Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet characters = $state([\"Jerry\", \"Elaine\", \"Kramer\"]);\n\tfunction addGeorge() {\n\t\tcharacters.push(\"George\");\n\t}\n</script>\n\n<div>\n\t<ul data-testid=\"characters-list\">\n\t\t{#each characters as character}\n\t\t\t<li data-testid=\"character\">{character}</li>\n\t\t{/each}\n\t</ul>\n\t<button data-testid=\"add-george-button\" onclick={addGeorge}>Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet characters = $state([\"Jerry\", \"Elaine\", \"Kramer\"]);\n\tfunction addGeorge() {\n\t\tcharacters.push(\"George\");\n\t}\n</script>\n<div>\n\t<ul data-testid=\"characters-list\">\n\t\t{#each characters as character}\n\t\t\t<li data-testid=\"character\">{character}</li>\n\t\t{/each}\n\t</ul>\n\t<button data-testid=\"add-george-button\" onclick={addGeorge}>Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet characters = $state([\"Jerry\", \"Elaine\", \"Kramer\"]);\n\t\n\tfunction addGeorge() {\n\t\tcharacters.push(\"George\");\n\t}\n</script>\n\n<div>\n\t<ul data-testid=\"characters-list\">\n\t\t{#each characters as character}\n\t\t\t<li data-testid=\"character\">{character}</li>\n\t\t{/each}\n\t</ul>\n\t<button data-testid=\"add-george-button\" onclick={addGeorge}>Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet characters = $state([\"Jerry\", \"Elaine\", \"Kramer\"]);\n\t\n\tfunction addGeorge() {\n\t\tcharacters.push(\"George\");\n\t}\n</script>\n\n<div>\n\t<ul data-testid=\"characters-list\">\n\t\t{#each characters as character}\n\t\t\t<li data-testid=\"character\">{character}</li>\n\t\t{/each}\n\t</ul>\n\t<button data-testid=\"add-george-button\" onclick={addGeorge}>Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet characters = $state([\"Jerry\", \"Elaine\", \"Kramer\"]);\n\tconst addGeorge = () => {\n\t\tcharacters = [...characters, \"George\"];\n\t}\n</script>\n\n<div>\n\t<ul data-testid=\"characters-list\">\n\t\t{#each characters as character}\n\t\t\t<li data-testid=\"character\">{character}</li>\n\t\t{/each}\n\t</ul>\n\t<button data-testid=\"add-george-button\" onclick={addGeorge}>Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet characters = $state([\"Jerry\", \"Elaine\", \"Kramer\"]);\n\tfunction addGeorge() {\n\t\tcharacters = [...characters, \"George\"];\n\t}\n</script>\n\n<div>\n\t<ul data-testid=\"characters-list\">\n\t\t{#each characters as character}\n\t\t\t<li data-testid=\"character\">{character}</li>\n\t\t{/each}\n\t</ul>\n\t<button data-testid=\"add-george-button\" onclick={addGeorge}>Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet characters = $state([\"Jerry\", \"Elaine\", \"Kramer\"]);\n</script>\n<div>\n\t<ul data-testid=\"characters-list\">\n\t\t{#each characters as character}\n\t\t\t<li data-testid=\"character\">{character}</li>\n\t\t{/each}\n\t</ul>\n\t<button data-testid=\"add-george-button\" onclick={() => characters.push(\"George\")}>\n\t\tAdd George\n\t</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let characters = $state([\"Jerry\", \"Elaine\", \"Kramer\"]);\n  function addGeorge() {\n    characters.push(\"George\");\n  }\n</script>\n<div>\n  <ul data-testid=\"characters-list\">\n    {#each characters as character}\n      <li data-testid=\"character\">{character}</li>\n    {/each}\n  </ul>\n  <button data-testid=\"add-george-button\" onclick={addGeorge}>Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet characters = $state([\"Jerry\", \"Elaine\", \"Kramer\"]);\n\t\n\tfunction addGeorge() {\n\t\tcharacters.push(\"George\");\n\t}\n</script>\n\n<div>\n\t<ul data-testid=\"characters-list\">\n\t\t{#each characters as character}\n\t\t\t<li data-testid=\"character\">{character}</li>\n\t\t{/each}\n\t</ul>\n\t<button data-testid=\"add-george-button\" onclick={addGeorge}>Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  },
  {
    "testName": "effect",
    "provider": "OpenAI",
    "modelId": "o3-mini-2025-01-31",
    "numSamples": 10,
    "numCorrect": 9,
    "pass1": 0.9,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet number = $state(5);\n\tlet doubled = $state(10);\n\t$effect(() => {\n\t\tdoubled = number * 2;\n\t});\n</script>\n\n<div>\n\t<p data-testid=\"number-value\">Number: {number}</p>\n\t<p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n\t<button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet number = $state(5);\n\tlet doubled = $state(number * 2);\n\t$effect(() => {\n\t\tdoubled = number * 2;\n\t});\n</script>\n\n<div>\n\t<p data-testid=\"number-value\">Number: {number}</p>\n\t<p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n\t<button data-testid=\"increment-button\" onclick={() => number += 1}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet number = $state(5);\n\tlet doubled = $state(number * 2);\n\t$effect(() => {\n\t\tdoubled = number * 2;\n\t});\n</script>\n\n<div>\n\t<p data-testid=\"number-value\">Number: {number}</p>\n\t<p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n\t<button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet number = $state(5);\n\tlet doubled = $state(0);\n\t$effect(() => {\n\t\tdoubled = number * 2;\n\t});\n</script>\n\n<div>\n\t<p data-testid=\"number-value\">Number: {number}</p>\n\t<p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n\t<button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet number = $state(5);\n\tlet doubled = $state(10);\n\t$effect(() => {\n\t\tdoubled = number * 2;\n\t});\n</script>\n\n<div>\n\t<p data-testid=\"number-value\">Number: {number}</p>\n\t<p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n\t<button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet number = $state(5);\n\tlet doubled = 0;\n\t$effect(() => {\n\t\tdoubled = number * 2;\n\t});\n</script>\n<div>\n\t<p data-testid=\"number-value\">Number: {number}</p>\n\t<p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n\t<button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": false,
        "errors": [
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Doubled: 10\u001b[39m\nReceived:\n\u001b[31m  Doubled: 0\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Doubled: 12\u001b[39m\nReceived:\n\u001b[31m  Doubled: 0\u001b[39m"
        ],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet number = $state(5);\n\tlet doubled = $state(0);\n\t$effect(() => {\n\t\tdoubled = number * 2;\n\t});\n\tfunction increment() {\n\t\tnumber += 1;\n\t}\n</script>\n\n<div>\n\t<p data-testid=\"number-value\">Number: {number}</p>\n\t<p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n\t<button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet number = $state(5);\n\tlet doubled = $state(10);\n\t$effect(() => {\n\t\tdoubled = number * 2;\n\t});\n</script>\n\n<div>\n\t<p data-testid=\"number-value\">Number: {number}</p>\n\t<p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n\t<button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet number = $state(5);\n\tlet doubled = $state(0);\n\t$effect(() => {\n\t\tdoubled = number * 2;\n\t});\n\tfunction increment() {\n\t\tnumber += 1;\n\t}\n</script>\n\n<div>\n\t<p data-testid=\"number-value\">Number: {number}</p>\n\t<p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n\t<button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet number = $state(5);\n\tlet doubled = $state(0);\n\t$effect(() => {\n\t\tdoubled = number * 2;\n\t});\n</script>\n\n<div>\n\t<p data-testid=\"number-value\">Number: {number}</p>\n\t<p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n\t<button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  },
  {
    "testName": "hello-world",
    "provider": "OpenAI",
    "modelId": "o3-mini-2025-01-31",
    "numSamples": 10,
    "numCorrect": 10,
    "pass1": 1,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n  // No logic needed\n</script>\n\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>\n\n<style>\n  .greeting {\n    color: blue;\n    text-align: center;\n    margin: 10px;\n  }\n  \n  :global(body) {\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    height: 100vh;\n    margin: 0;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<script>\n</script>\n\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>\n\n<style>\n\t.greeting {\n\t\tcolor: blue;\n\t\ttext-align: center;\n\t\tmargin: 1rem;\n\t}\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<script>\n</script>\n\n<style>\n\t.greeting {\n\t\tcolor: blue;\n\t\ttext-align: center;\n\t\tmargin: 10px;\n\t}\n</style>\n\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet greeting = \"Hello, World!\";\n</script>\n\n<div data-testid=\"greeting\" class=\"greeting\">{greeting}</div>\n\n<style>\n\t.greeting {\n\t\tcolor: blue;\n\t\ttext-align: center;\n\t\tmargin: 1rem;\n\t}\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<script>\n</script>\n\n<style>\n  .greeting {\n    color: blue;\n    text-align: center;\n    margin: 10px;\n  }\n</style>\n\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<script>\n</script>\n\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>\n\n<style>\n\t.greeting {\n\t\tcolor: blue;\n\t\ttext-align: center;\n\t\tmargin: 10px;\n\t}\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<script>\n  // no script logic needed\n</script>\n\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>\n\n<style>\n  .greeting {\n    color: blue;\n    text-align: center;\n    margin: 1rem;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<script>\n</script>\n\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>\n\n<style>\n\t.greeting {\n\t\tcolor: blue;\n\t\ttext-align: center;\n\t\tmargin: 10px;\n\t}\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<script>\n  // No state logic needed\n</script>\n\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>\n\n<style>\n  .greeting {\n    color: blue;\n    text-align: center;\n    margin: 10px;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<script>\n</script>\n\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>\n\n<style>\n  .greeting {\n    color: blue;\n    text-align: center;\n    margin: 10px;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  },
  {
    "testName": "inspect",
    "provider": "OpenAI",
    "modelId": "o3-mini-2025-01-31",
    "numSamples": 10,
    "numCorrect": 0,
    "pass1": 0,
    "pass10": 0,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet text = $state(\"Hello world\");\n\tlet charCount = $derived(text.length);\n\n\t$inspect(text);\n\t$inspect(text).with((value) => {\n\t\tconsole.log(\"Custom callback: input changed to\", value);\n\t});\n\n\t$effect(() => {\n\t\t// Access text so that this effect runs on every update\n\t\tlet current = text;\n\t\t$inspect.trace();\n\t});\n</script>\n\n<div>\n\t<input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n\t<p data-testid=\"text-value\">Current text: {text}</p>\n\t<p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "tmp/openai/Component.svelte:15:2 `$inspect.trace(...)` must be the first statement of a function body\nhttps://svelte.dev/e/inspect_trace_invalid_placement"
        ],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet text = $state(\"Hello world\");\n\t\n\t$inspect(text);\n\t$inspect(text).with((value) => console.log(\"Custom callback:\", value));\n\t\n\tlet charCount = $derived(text.length);\n\t\n\t$effect(() => {\n\t\t$inspect.trace(text);\n\t});\n</script>\n\n<div>\n\t<input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n\t<p data-testid=\"text-value\">Current text: {text}</p>\n\t<p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"Hello world\"\u001b[39m\nReceived:\n\u001b[31m  Current text: Hello world\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"Testing $inspect\"\u001b[39m\nReceived:\n\u001b[31m  Current text: Testing $inspect\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"!@#$%^&*()\"\u001b[39m\nReceived:\n\u001b[31m  Current text: !@#$%^&*()\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"\"\u001b[39m\nReceived:\n\u001b[31m  Current text:\u001b[39m"
        ],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet text = $state(\"Hello world\");\n\t\n\t$inspect(text);\n\t\n\t$inspect(text).with(value => {\n\t\tconsole.log(\"Custom update:\", value);\n\t});\n\t\n\tconst charCount = $derived(text.length);\n\t\n\t$effect(() => {\n\t\t$inspect.trace(text);\n\t});\n</script>\n\n<div>\n\t<input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n\t<p data-testid=\"text-value\">Current text: {text}</p>\n\t<p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"Hello world\"\u001b[39m\nReceived:\n\u001b[31m  Current text: Hello world\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"Testing $inspect\"\u001b[39m\nReceived:\n\u001b[31m  Current text: Testing $inspect\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"!@#$%^&*()\"\u001b[39m\nReceived:\n\u001b[31m  Current text: !@#$%^&*()\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"\"\u001b[39m\nReceived:\n\u001b[31m  Current text:\u001b[39m"
        ],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet text = $state(\"Hello world\");\n\t$inspect(text);\n\t$inspect(text).with((newValue, oldValue) => {\n\t\tconsole.log(\"Input updated from\", oldValue, \"to\", newValue);\n\t});\n\tconst charCount = $derived(text.length);\n\t$effect(() => {\n\t\t$inspect.trace();\n\t});\n</script>\n\n<div>\n\t<input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n\t<p data-testid=\"text-value\">Current text: {text}</p>\n\t<p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"Hello world\"\u001b[39m\nReceived:\n\u001b[31m  Current text: Hello world\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"Testing $inspect\"\u001b[39m\nReceived:\n\u001b[31m  Current text: Testing $inspect\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"!@#$%^&*()\"\u001b[39m\nReceived:\n\u001b[31m  Current text: !@#$%^&*()\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"\"\u001b[39m\nReceived:\n\u001b[31m  Current text:\u001b[39m"
        ],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet text = $state(\"Hello world\");\n\n\t$inspect(text);\n\t$inspect(text).with(value => {\n\t\tconsole.log(\"Custom update:\", value);\n\t});\n\n\t$effect(() => {\n\t\t$inspect.trace();\n\t});\n\n\tconst charCount = $derived(text.length);\n</script>\n\n<div>\n\t<input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n\t<p data-testid=\"text-value\">Current text: {text}</p>\n\t<p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"Hello world\"\u001b[39m\nReceived:\n\u001b[31m  Current text: Hello world\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"Testing $inspect\"\u001b[39m\nReceived:\n\u001b[31m  Current text: Testing $inspect\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"!@#$%^&*()\"\u001b[39m\nReceived:\n\u001b[31m  Current text: !@#$%^&*()\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"\"\u001b[39m\nReceived:\n\u001b[31m  Current text:\u001b[39m"
        ],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet text = $state(\"Hello world\");\n\n\t$inspect(text);\n\t$inspect(text).with((val) => {\n\t\tconsole.log(\"Custom callback: text updated to\", val);\n\t});\n\n\t$effect(() => {\n\t\t$inspect.trace();\n\t});\n\n\tconst charCount = $derived(text.length);\n</script>\n\n<div>\n\t<input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n\t<p data-testid=\"text-value\">Current text: {text}</p>\n\t<p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"Hello world\"\u001b[39m\nReceived:\n\u001b[31m  Current text: Hello world\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"Testing $inspect\"\u001b[39m\nReceived:\n\u001b[31m  Current text: Testing $inspect\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"!@#$%^&*()\"\u001b[39m\nReceived:\n\u001b[31m  Current text: !@#$%^&*()\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"\"\u001b[39m\nReceived:\n\u001b[31m  Current text:\u001b[39m"
        ],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet text = $state(\"Hello world\");\n\tconst charCount = $derived(text.length);\n\n\t$inspect(text);\n\t$inspect(text).with(value => {\n\t\tconsole.log(\"Custom callback: new value:\", value);\n\t});\n\n\t$effect(() => {\n\t\t$inspect.trace();\n\t});\n</script>\n\n<div>\n\t<input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n\t<p data-testid=\"text-value\">Current text: {text}</p>\n\t<p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"Hello world\"\u001b[39m\nReceived:\n\u001b[31m  Current text: Hello world\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"Testing $inspect\"\u001b[39m\nReceived:\n\u001b[31m  Current text: Testing $inspect\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"!@#$%^&*()\"\u001b[39m\nReceived:\n\u001b[31m  Current text: !@#$%^&*()\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"\"\u001b[39m\nReceived:\n\u001b[31m  Current text:\u001b[39m"
        ],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet text = $state(\"Hello world\");\n\n\t$inspect(text);\n\t$inspect(text).with((val) => console.log(\"Updated text:\", val));\n\n\t$effect(() => {\n\t\t$inspect.trace(text);\n\t});\n\n\tlet charCount = $derived(text.length);\n</script>\n\n<div>\n\t<input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n\t<p data-testid=\"text-value\">Current text: {text}</p>\n\t<p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"Hello world\"\u001b[39m\nReceived:\n\u001b[31m  Current text: Hello world\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"Testing $inspect\"\u001b[39m\nReceived:\n\u001b[31m  Current text: Testing $inspect\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"!@#$%^&*()\"\u001b[39m\nReceived:\n\u001b[31m  Current text: !@#$%^&*()\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"\"\u001b[39m\nReceived:\n\u001b[31m  Current text:\u001b[39m"
        ],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet text = $state(\"Hello world\");\n\n\t$inspect(text);\n\t$inspect(text).with(value => console.log(\"Custom update callback:\", value));\n\n\t$effect(() => {\n\t\t$inspect.trace();\n\t\ttext;\n\t});\n</script>\n\n<div>\n\t<input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n\t<p data-testid=\"text-value\">Current text: {text}</p>\n\t<p data-testid=\"char-count\">Character count: {text.length}</p>\n</div>",
        "success": false,
        "errors": [
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"Hello world\"\u001b[39m\nReceived:\n\u001b[31m  Current text: Hello world\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"Testing $inspect\"\u001b[39m\nReceived:\n\u001b[31m  Current text: Testing $inspect\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"!@#$%^&*()\"\u001b[39m\nReceived:\n\u001b[31m  Current text: !@#$%^&*()\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"\"\u001b[39m\nReceived:\n\u001b[31m  Current text:\u001b[39m"
        ],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet text = $state(\"Hello world\");\n\t$inspect(text);\n\t$inspect(text).with(current => console.log(\"Custom callback: text updated to\", current));\n\tlet charCount = $derived(text.length);\n\t$effect(() => {\n\t\t$inspect.trace();\n\t});\n</script>\n\n<div>\n\t<input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n\t<p data-testid=\"text-value\">Current text: {text}</p>\n\t<p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"Hello world\"\u001b[39m\nReceived:\n\u001b[31m  Current text: Hello world\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"Testing $inspect\"\u001b[39m\nReceived:\n\u001b[31m  Current text: Testing $inspect\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"!@#$%^&*()\"\u001b[39m\nReceived:\n\u001b[31m  Current text: !@#$%^&*()\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"\"\u001b[39m\nReceived:\n\u001b[31m  Current text:\u001b[39m"
        ],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  },
  {
    "testName": "props",
    "provider": "OpenAI",
    "modelId": "o3-mini-2025-01-31",
    "numSamples": 10,
    "numCorrect": 10,
    "pass1": 1,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet { name = \"World\", count: initialCount = 0, showDetails = false } = $props();\n\tlet count = $state(initialCount);\n</script>\n<div>\n\t<h1 data-testid=\"name-display\">Hello, {name}!</h1>\n\t<p data-testid=\"count-display\">Count: {count}</p>\n\t<button data-testid=\"increment-button\" onclick={() => count++}>Increment</button>\n\t{#if showDetails}\n\t\t<div data-testid=\"details\">\n\t\t\t<p>Name is {name}</p>\n\t\t\t<p>Count is {count}</p>\n\t\t\t<p>ShowDetails is true</p>\n\t\t</div>\n\t{/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet { name = 'World', count: initialCount = 0, showDetails = false } = $props();\n\tlet count = $state(initialCount);\n</script>\n\n<div>\n\t<h1 data-testid=\"name-display\">Hello, {name}!</h1>\n\t<p data-testid=\"count-display\">Count: {count}</p>\n\t<button data-testid=\"increment-button\" onclick={() => count++}>Increment</button>\n\t{#if showDetails}\n\t\t<div data-testid=\"details\">\n\t\t\t<p>Name is {name}</p>\n\t\t\t<p>Count is {count}</p>\n\t\t\t<p>ShowDetails is true</p>\n\t\t</div>\n\t{/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet { name = \"World\", count = 0, showDetails = false } = $props();\n\tlet counter = $state(count);\n</script>\n<div>\n\t<h1 data-testid=\"name-display\">Hello, {name}!</h1>\n\t<p data-testid=\"count-display\">Count: {counter}</p>\n\t<button data-testid=\"increment-button\" onclick={() => counter++}>Increment</button>\n\t{#if showDetails}\n\t\t<div data-testid=\"details\">\n\t\t\t<p>Name is {name}</p>\n\t\t\t<p>Count is {counter}</p>\n\t\t\t<p>ShowDetails is true</p>\n\t\t</div>\n\t{/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet { name = \"World\", count: initialCount = 0, showDetails = false } = $props();\n\tlet count = $state(initialCount);\n</script>\n\n<div>\n\t<h1 data-testid=\"name-display\">Hello, {name}!</h1>\n\t<p data-testid=\"count-display\">Count: {count}</p>\n\t<button data-testid=\"increment-button\" onclick={() => count++}>Increment</button>\n\t{#if showDetails}\n\t\t<div data-testid=\"details\">\n\t\t\t<p>Name is {name}</p>\n\t\t\t<p>Count is {count}</p>\n\t\t\t<p>ShowDetails is true</p>\n\t\t</div>\n\t{/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet { name = \"World\", count: initialCount = 0, showDetails = false } = $props();\n\tlet count = $state(initialCount);\n</script>\n<div>\n\t<h1 data-testid=\"name-display\">Hello, {name}!</h1>\n\t<p data-testid=\"count-display\">Count: {count}</p>\n\t<button data-testid=\"increment-button\" onclick={() => count++}>Increment</button>\n\t{#if showDetails}\n\t\t<div data-testid=\"details\">\n\t\t\t<p>Name is {name}</p>\n\t\t\t<p>Count is {count}</p>\n\t\t\t<p>ShowDetails is true</p>\n\t\t</div>\n\t{/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let { name = \"World\", count = 0, showDetails = false } = $props();\n  let currentCount = $state(count);\n</script>\n\n<div>\n  <h1 data-testid=\"name-display\">Hello, {name}!</h1>\n  <p data-testid=\"count-display\">Count: {currentCount}</p>\n  <button data-testid=\"increment-button\" onclick={() => currentCount++}>Increment</button>\n  {#if showDetails}\n    <div data-testid=\"details\">\n      <p>Name is {name}</p>\n      <p>Count is {currentCount}</p>\n      <p>ShowDetails is true</p>\n    </div>\n  {/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet { name = \"World\", count: initialCount = 0, showDetails = false } = $props();\n\tlet count = $state(initialCount);\n</script>\n\n<div>\n\t<h1 data-testid=\"name-display\">Hello, {name}!</h1>\n\t<p data-testid=\"count-display\">Count: {count}</p>\n\t<button data-testid=\"increment-button\" onclick={() => count++}>Increment</button>\n\t{#if showDetails}\n\t\t<div data-testid=\"details\">\n\t\t\t<p>Name is {name}</p>\n\t\t\t<p>Count is {count}</p>\n\t\t\t<p>ShowDetails is true</p>\n\t\t</div>\n\t{/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let { name = \"World\", count: initialCount = 0, showDetails = false } = $props();\n  let count = $state(initialCount);\n</script>\n\n<div>\n  <h1 data-testid=\"name-display\">Hello, {name}!</h1>\n  <p data-testid=\"count-display\">Count: {count}</p>\n  <button data-testid=\"increment-button\" onclick={() => count++}>Increment</button>\n  {#if showDetails}\n    <div data-testid=\"details\">\n      <p>Name is {name}</p>\n      <p>Count is {count}</p>\n      <p>ShowDetails is true</p>\n    </div>\n  {/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let { name = \"World\", count: initialCount = 0, showDetails = false } = $props();\n  let count = $state(initialCount);\n</script>\n\n<div>\n  <h1 data-testid=\"name-display\">Hello, {name}!</h1>\n  <p data-testid=\"count-display\">Count: {count}</p>\n  <button data-testid=\"increment-button\" onclick={() => count++}>Increment</button>\n  {#if showDetails}\n    <div data-testid=\"details\">\n      <p>Name is {name}</p>\n      <p>Count is {count}</p>\n      <p>ShowDetails is true</p>\n    </div>\n  {/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let { name = \"World\", count: initialCount = 0, showDetails = false } = $props();\n  let count = $state(initialCount);\n</script>\n\n<div>\n  <h1 data-testid=\"name-display\">Hello, {name}!</h1>\n  <p data-testid=\"count-display\">Count: {count}</p>\n  <button data-testid=\"increment-button\" onclick={() => count++}>Increment</button>\n  {#if showDetails}\n    <div data-testid=\"details\">\n      <p>Name is {name}</p>\n      <p>Count is {count}</p>\n      <p>ShowDetails is true</p>\n    </div>\n  {/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  },
  {
    "testName": "snippets",
    "provider": "OpenAI",
    "modelId": "o3-mini-2025-01-31",
    "numSamples": 10,
    "numCorrect": 10,
    "pass1": 1,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tconst books = [\"The Lord of the Rings\", \"To Kill a Mockingbird\", \"1984\"];\n</script>\n\n{#snippet title(book)}\n\t<span data-testid=\"book-title\">{book}</span>\n{/snippet}\n\n<ul>\n\t{#each books as book}\n\t\t<li data-testid=\"book-item\">\n\t\t\t{@render title(book)}\n\t\t</li>\n\t{/each}\n</ul>",
        "success": true,
        "errors": [],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet books = [\"The Lord of the Rings\", \"To Kill a Mockingbird\", \"1984\"];\n</script>\n\n{#snippet title(book)}\n\t<span data-testid=\"book-title\">{book}</span>\n{/snippet}\n\n<ul>\n\t{#each books as book}\n\t\t<li data-testid=\"book-item\">\n\t\t\t{@render title(book)}\n\t\t</li>\n\t{/each}\n</ul>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet books = [\"The Lord of the Rings\", \"To Kill a Mockingbird\", \"1984\"];\n</script>\n\n{#snippet title(bookTitle)}\n\t<span data-testid=\"book-title\">{bookTitle}</span>\n{/snippet}\n\n<ul>\n\t{#each books as book}\n\t\t<li data-testid=\"book-item\">\n\t\t\t{@render title(book)}\n\t\t</li>\n\t{/each}\n</ul>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet books = [\"The Lord of the Rings\", \"To Kill a Mockingbird\", \"1984\"];\n</script>\n\n{#snippet title(book)}\n\t<span data-testid=\"book-title\">{book}</span>\n{/snippet}\n\n<ul>\n\t{#each books as book}\n\t\t<li data-testid=\"book-item\">\n\t\t\t{@render title(book)}\n\t\t</li>\n\t{/each}\n</ul>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet books = $state([\"The Lord of the Rings\", \"To Kill a Mockingbird\", \"1984\"]);\n</script>\n\n{#snippet title(book)}\n\t<span data-testid=\"book-title\">{book}</span>\n{/snippet}\n\n<ul>\n\t{#each books as book}\n\t\t<li data-testid=\"book-item\">\n\t\t\t{@render title(book)}\n\t\t</li>\n\t{/each}\n</ul>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet books = $state([\"The Lord of the Rings\", \"To Kill a Mockingbird\", \"1984\"]);\n</script>\n\n{#snippet title(book)}\n\t<span data-testid=\"book-title\">{book}</span>\n{/snippet}\n\n<ul>\n\t{#each books as book}\n\t\t<li data-testid=\"book-item\">\n\t\t\t{@render title(book)}\n\t\t</li>\n\t{/each}\n</ul>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet books = $state([\"The Lord of the Rings\", \"To Kill a Mockingbird\", \"1984\"]);\n</script>\n\n{#snippet title(book)}\n\t<span data-testid=\"book-title\">{book}</span>\n{/snippet}\n\n<ul>\n\t{#each books as book}\n\t\t<li data-testid=\"book-item\">\n\t\t\t{@render title(book)}\n\t\t</li>\n\t{/each}\n</ul>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<script>\n  const books = [\"The Lord of the Rings\", \"To Kill a Mockingbird\", \"1984\"];\n</script>\n\n{#snippet title(book)}\n  <span data-testid=\"book-title\">{book}</span>\n{/snippet}\n\n<ul>\n  {#each books as book}\n    <li data-testid=\"book-item\">\n      {@render title(book)}\n    </li>\n  {/each}\n</ul>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet books = $state([\"The Lord of the Rings\", \"To Kill a Mockingbird\", \"1984\"]);\n</script>\n\n{#snippet title(book)}\n\t<span data-testid=\"book-title\">{book}</span>\n{/snippet}\n\n<ul>\n\t{#each books as book}\n\t\t<li data-testid=\"book-item\">\n\t\t\t{@render title(book)}\n\t\t</li>\n\t{/each}\n</ul>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet books = $state([\"The Lord of the Rings\", \"To Kill a Mockingbird\", \"1984\"]);\n</script>\n\n{#snippet title(book)}\n\t<span data-testid=\"book-title\">{book}</span>\n{/snippet}\n\n<ul>\n\t{#each books as book}\n\t\t<li data-testid=\"book-item\">\n\t\t\t{@render title(book)}\n\t\t</li>\n\t{/each}\n</ul>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  },
  {
    "testName": "counter",
    "provider": "OpenAI",
    "modelId": "gpt-4o-2024-08-06",
    "numSamples": 10,
    "numCorrect": 10,
    "pass1": 1,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let count = $state(0);\n</script>\n\n<div class=\"counter\">\n  <button data-testid=\"decrement-button\" onclick={() => count--}>-</button>\n  <span data-testid=\"count-value\">{count}</span>\n  <button data-testid=\"increment-button\" onclick={() => count++}>+</button>\n</div>\n\n<style>\n  .counter {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let count = $state(0);\n</script>\n\n<div class=\"counter\">\n  <button data-testid=\"decrement-button\" onclick={() => count--}>-</button>\n  <span data-testid=\"count-value\">{count}</span>\n  <button data-testid=\"increment-button\" onclick={() => count++}>+</button>\n</div>\n\n<style>\n  .counter {\n    display: flex;\n    align-items: center;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let count = $state(0);\n</script>\n\n<div class=\"counter\">\n  <button data-testid=\"decrement-button\" onclick={() => count--}>-</button>\n  <span data-testid=\"count-value\">{count}</span>\n  <button data-testid=\"increment-button\" onclick={() => count++}>+</button>\n</div>\n\n<style>\n  .counter {\n    display: flex;\n    align-items: center;\n  }\n  .counter button {\n    margin: 0 10px;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let count = $state(0);\n</script>\n\n<div class=\"counter\">\n  <button data-testid=\"decrement-button\" onclick={() => count--}>-</button>\n  <span data-testid=\"count-value\">{count}</span>\n  <button data-testid=\"increment-button\" onclick={() => count++}>+</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let count = $state(0);\n</script>\n\n<div class=\"counter\">\n  <button data-testid=\"decrement-button\" onclick={() => count--}>-</button>\n  <span data-testid=\"count-value\">{count}</span>\n  <button data-testid=\"increment-button\" onclick={() => count++}>+</button>\n</div>\n\n<style>\n  .counter {\n    display: flex;\n    align-items: center;\n    gap: 1rem;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let count = $state(0);\n</script>\n\n<div class=\"counter\">\n  <button data-testid=\"decrement-button\" onclick={() => count--}>-</button>\n  <span data-testid=\"count-value\">{count}</span>\n  <button data-testid=\"increment-button\" onclick={() => count++}>+</button>\n</div>\n\n<style>\n  .counter {\n    display: flex;\n    align-items: center;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let count = $state(0);\n</script>\n\n<div class=\"counter\">\n  <button data-testid=\"decrement-button\" onclick={() => count--}>-</button>\n  <span data-testid=\"count-value\">{count}</span>\n  <button data-testid=\"increment-button\" onclick={() => count++}>+</button>\n</div>\n\n<style>\n  .counter {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let count = $state(0);\n</script>\n\n<div class=\"counter\">\n  <button data-testid=\"decrement-button\" onclick={() => count--}>-</button>\n  <span data-testid=\"count-value\">{count}</span>\n  <button data-testid=\"increment-button\" onclick={() => count++}>+</button>\n</div>\n\n<style>\n  .counter {\n    display: flex;\n    align-items: center;\n  }\n  button {\n    margin: 0 10px;\n    padding: 5px;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let count = $state(0);\n</script>\n\n<div class=\"counter\">\n  <button data-testid=\"decrement-button\" onclick={() => count--}>-</button>\n  <span data-testid=\"count-value\">{count}</span>\n  <button data-testid=\"increment-button\" onclick={() => count++}>+</button>\n</div>\n\n<style>\n  .counter {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let count = $state(0);\n</script>\n\n<div class=\"counter\">\n  <button data-testid=\"decrement-button\" onclick={() => count--}>-</button>\n  <span data-testid=\"count-value\">{count}</span>\n  <button data-testid=\"increment-button\" onclick={() => count++}>+</button>\n</div>\n\n<style>\n  .counter {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  },
  {
    "testName": "derived",
    "provider": "OpenAI",
    "modelId": "gpt-4o-2024-08-06",
    "numSamples": 10,
    "numCorrect": 10,
    "pass1": 1,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $derived(number * 2);\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $derived(number * 2);\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $derived(number * 2);\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $derived(number * 2);\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $derived(number * 2);\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $derived(number * 2);\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $derived(number * 2);\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $derived(number * 2);\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $derived(number * 2);\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $derived(number * 2);\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  },
  {
    "testName": "derived-by",
    "provider": "OpenAI",
    "modelId": "gpt-4o-2024-08-06",
    "numSamples": 10,
    "numCorrect": 10,
    "pass1": 1,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('');\n\n  const wordCount = $derived.by(() => {\n    return text.trim().split(/\\s+/).filter(Boolean).length;\n  });\n\n  const charCount = $derived.by(() => {\n    return text.length;\n  });\n\n  const isLongText = $derived.by(() => {\n    return wordCount > 15 ? 'Long text' : 'Short text';\n  });\n\n  function clearText() {\n    text = '';\n  }\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <button data-testid=\"clear-button\" onclick={clearText}>Clear</button>\n  <div>\n    <p data-testid=\"word-count\">Words: {wordCount}</p>\n    <p data-testid=\"char-count\">Characters: {charCount}</p>\n    <p data-testid=\"length-indicator\">Status: {isLongText}</p>\n  </div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('');\n\n  let wordCount = $derived.by(() => text.trim().split(/\\s+/).filter(Boolean).length);\n  let charCount = $derived.by(() => text.length);\n  let isLongText = $derived.by(() => wordCount > 15);\n\n  function clearText() {\n    text = '';\n  }\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <button data-testid=\"clear-button\" onclick={clearText}>Clear</button>\n  <div>\n    <p data-testid=\"word-count\">Words: {wordCount}</p>\n    <p data-testid=\"char-count\">Characters: {charCount}</p>\n    <p data-testid=\"length-indicator\">Status: {isLongText ? 'Long text' : 'Short text'}</p>\n  </div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('');\n\n  const wordCount = $derived.by(() => {\n    return text.trim().split(/\\s+/).filter(Boolean).length;\n  });\n\n  const charCount = $derived.by(() => {\n    return text.length;\n  });\n\n  const isLongText = $derived.by(() => {\n    return wordCount > 15;\n  });\n\n  function clearText() {\n    text = '';\n  }\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <button data-testid=\"clear-button\" onclick={clearText}>Clear</button>\n  <div>\n    <p data-testid=\"word-count\">Words: {wordCount}</p>\n    <p data-testid=\"char-count\">Characters: {charCount}</p>\n    <p data-testid=\"length-indicator\">Status: {isLongText ? 'Long text' : 'Short text'}</p>\n  </div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('');\n\n  let analysis = $derived.by(() => {\n    const words = text.trim().split(/\\s+/).filter(Boolean);\n    const wordCount = words.length;\n    const charCount = text.length;\n    const isLong = wordCount > 15;\n    return { wordCount, charCount, isLong };\n  });\n\n  function clearText() {\n    text = '';\n  }\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <button data-testid=\"clear-button\" onclick={clearText}>Clear</button>\n  <div>\n    <p data-testid=\"word-count\">Words: {analysis.wordCount}</p>\n    <p data-testid=\"char-count\">Characters: {analysis.charCount}</p>\n    <p data-testid=\"length-indicator\">\n      Status: {analysis.isLong ? 'Long text' : 'Short text'}\n    </p>\n  </div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('');\n\n  const wordCount = $derived.by(() => {\n    const words = text.trim().split(/\\s+/).filter(Boolean);\n    return words.length;\n  });\n\n  const charCount = $derived.by(() => {\n    return text.length;\n  });\n\n  const isLongText = $derived.by(() => {\n    return wordCount > 15;\n  });\n\n  function clearText() {\n    text = '';\n  }\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <button data-testid=\"clear-button\" onclick={clearText}>Clear</button>\n  <div>\n    <p data-testid=\"word-count\">Words: {wordCount}</p>\n    <p data-testid=\"char-count\">Characters: {charCount}</p>\n    <p data-testid=\"length-indicator\">\n      Status: {isLongText ? 'Long text' : 'Short text'}\n    </p>\n  </div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('');\n\n  const wordCount = $derived.by(() => {\n    let words = text.trim().split(/\\s+/).filter(word => word !== '');\n    return words.length;\n  });\n\n  const charCount = $derived.by(() => text.length);\n\n  const isLongText = $derived.by(() => wordCount > 15);\n\n  function clearText() {\n    text = '';\n  }\n</script>\n\n<div>\n  <input \n    data-testid=\"text-input\" \n    type=\"text\" \n    bind:value={text} \n  />\n  <button data-testid=\"clear-button\" onclick={clearText}>Clear</button>\n  <div>\n    <p data-testid=\"word-count\">Words: {wordCount}</p>\n    <p data-testid=\"char-count\">Characters: {charCount}</p>\n    <p data-testid=\"length-indicator\">\n      Status: {isLongText ? 'Long text' : 'Short text'}\n    </p>\n  </div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('');\n\n  let wordCount = $derived.by(() => {\n    return text.trim().split(/\\s+/).filter(Boolean).length;\n  });\n\n  let charCount = $derived.by(() => {\n    return text.length;\n  });\n\n  let isLongText = $derived.by(() => {\n    return wordCount > 15 ? 'Long text' : 'Short text';\n  });\n\n  function clearText() {\n    text = '';\n  }\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <button data-testid=\"clear-button\" onclick={clearText}>Clear</button>\n  <div>\n    <p data-testid=\"word-count\">Words: {wordCount}</p>\n    <p data-testid=\"char-count\">Characters: {charCount}</p>\n    <p data-testid=\"length-indicator\">Status: {isLongText}</p>\n  </div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('');\n\n  const wordCount = $derived.by(() => {\n    return text.trim() ? text.trim().split(/\\s+/).length : 0;\n  });\n\n  const charCount = $derived.by(() => {\n    return text.length;\n  });\n\n  const isLong = $derived.by(() => {\n    return wordCount > 15;\n  });\n\n  function clearText() {\n    text = '';\n  }\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <button data-testid=\"clear-button\" onclick={clearText}>Clear</button>\n  <div>\n    <p data-testid=\"word-count\">Words: {wordCount}</p>\n    <p data-testid=\"char-count\">Characters: {charCount}</p>\n    <p data-testid=\"length-indicator\">Status: {isLong ? 'Long text' : 'Short text'}</p>\n  </div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state(\"\");\n\n  let wordCount = $derived.by(() => {\n    return text.trim() === \"\" ? 0 : text.trim().split(/\\s+/).length;\n  });\n\n  let charCount = $derived.by(() => {\n    return text.length;\n  });\n\n  let isLongText = $derived.by(() => {\n    return wordCount > 15;\n  });\n\n  function clearText() {\n    text = \"\";\n  }\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <button data-testid=\"clear-button\" onclick={clearText}>Clear</button>\n  <div>\n    <p data-testid=\"word-count\">Words: {wordCount}</p>\n    <p data-testid=\"char-count\">Characters: {charCount}</p>\n    <p data-testid=\"length-indicator\">Status: {isLongText ? \"Long text\" : \"Short text\"}</p>\n  </div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('');\n\n  let wordCount = $derived.by(() => {\n    return text.trim().split(/\\s+/).filter(Boolean).length;\n  });\n\n  let charCount = $derived.by(() => text.length);\n\n  let isLong = $derived.by(() => wordCount > 15);\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <button data-testid=\"clear-button\" onclick={() => text = ''}>Clear</button>\n  <div>\n    <p data-testid=\"word-count\">Words: {wordCount}</p>\n    <p data-testid=\"char-count\">Characters: {charCount}</p>\n    <p data-testid=\"length-indicator\">Status: {isLong ? 'Long text' : 'Short text'}</p>\n  </div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  },
  {
    "testName": "each",
    "provider": "OpenAI",
    "modelId": "gpt-4o-2024-08-06",
    "numSamples": 10,
    "numCorrect": 10,
    "pass1": 1,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let characters = $state([\"Jerry\", \"Elaine\", \"Kramer\"]);\n\n  function addGeorge() {\n    characters.push(\"George\");\n  }\n</script>\n\n<div>\n  <ul data-testid=\"characters-list\">\n    {#each characters as character}\n      <li data-testid=\"character\">{character}</li>\n    {/each}\n  </ul>\n  <button data-testid=\"add-george-button\" onclick={addGeorge}>Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let characters = $state([\"Jerry\", \"Elaine\", \"Kramer\"]);\n\n  function addGeorge() {\n    characters.push(\"George\");\n  }\n</script>\n\n<div>\n  <ul data-testid=\"characters-list\">\n    {#each characters as character}\n      <li data-testid=\"character\">{character}</li>\n    {/each}\n  </ul>\n  <button data-testid=\"add-george-button\" onclick={addGeorge}>Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let characters = $state([\"Jerry\", \"Elaine\", \"Kramer\"]);\n\n  function addGeorge() {\n    characters.push(\"George\");\n  }\n</script>\n\n<div>\n  <ul data-testid=\"characters-list\">\n    {#each characters as character}\n      <li data-testid=\"character\">{character}</li>\n    {/each}\n  </ul>\n  <button data-testid=\"add-george-button\" onclick={addGeorge}>Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let characters = $state([\"Jerry\", \"Elaine\", \"Kramer\"]);\n\n  function addGeorge() {\n    characters.push(\"George\");\n  }\n</script>\n\n<div>\n  <ul data-testid=\"characters-list\">\n    {#each characters as character}\n      <li data-testid=\"character\">{character}</li>\n    {/each}\n  </ul>\n  <button data-testid=\"add-george-button\" onclick={addGeorge}>Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let characters = $state([\"Jerry\", \"Elaine\", \"Kramer\"]);\n\n  function addGeorge() {\n    characters.push(\"George\");\n  }\n</script>\n\n<div>\n  <ul data-testid=\"characters-list\">\n    {#each characters as character}\n      <li data-testid=\"character\">{character}</li>\n    {/each}\n  </ul>\n  <button data-testid=\"add-george-button\" onclick={addGeorge}>Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let characters = $state([\"Jerry\", \"Elaine\", \"Kramer\"]);\n\n  function addGeorge() {\n    characters = [...characters, \"George\"];\n  }\n</script>\n\n<div>\n  <ul data-testid=\"characters-list\">\n    {#each characters as character}\n      <li data-testid=\"character\">{character}</li>\n    {/each}\n  </ul>\n  <button data-testid=\"add-george-button\" onclick={addGeorge}>Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let characters = $state([\"Jerry\", \"Elaine\", \"Kramer\"]);\n\n  function addGeorge() {\n    characters = [...characters, \"George\"];\n  }\n</script>\n\n<div>\n  <ul data-testid=\"characters-list\">\n    {#each characters as character}\n      <li data-testid=\"character\">{character}</li>\n    {/each}\n  </ul>\n  <button data-testid=\"add-george-button\" onclick={addGeorge}>Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let characters = $state([\"Jerry\", \"Elaine\", \"Kramer\"]);\n\n  function addGeorge() {\n    characters = [...characters, \"George\"];\n  }\n</script>\n\n<div>\n  <ul data-testid=\"characters-list\">\n    {#each characters as character}\n      <li data-testid=\"character\">{character}</li>\n    {/each}\n  </ul>\n  <button data-testid=\"add-george-button\" onclick={addGeorge}>Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let characters = $state([\"Jerry\", \"Elaine\", \"Kramer\"]);\n  \n  function addCharacter() {\n    characters = [...characters, \"George\"];\n  }\n</script>\n\n<div>\n  <ul data-testid=\"characters-list\">\n    {#each characters as character}\n      <li data-testid=\"character\">{character}</li>\n    {/each}\n  </ul>\n  <button data-testid=\"add-george-button\" onclick={addCharacter}>Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let characters = $state([\"Jerry\", \"Elaine\", \"Kramer\"]);\n\n  function addCharacter() {\n    characters.push(\"George\");\n  }\n</script>\n\n<div>\n  <ul data-testid=\"characters-list\">\n    {#each characters as character}\n      <li data-testid=\"character\">{character}</li>\n    {/each}\n  </ul>\n  <button data-testid=\"add-george-button\" onclick={addCharacter}>Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  },
  {
    "testName": "effect",
    "provider": "OpenAI",
    "modelId": "gpt-4o-2024-08-06",
    "numSamples": 10,
    "numCorrect": 7,
    "pass1": 0.7,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $state(0);\n\n  $effect(() => {\n    doubled = number * 2;\n  });\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled;\n\n  $effect(() => {\n    doubled = number * 2;\n  });\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": false,
        "errors": [
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Doubled: 10\u001b[39m\nReceived:\n\u001b[31m  Doubled:\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Doubled: 12\u001b[39m\nReceived:\n\u001b[31m  Doubled:\u001b[39m"
        ],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled;\n\n  $effect(() => {\n    doubled = number * 2;\n  });\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number++}>\n    Increment\n  </button>\n</div>",
        "success": false,
        "errors": [
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Doubled: 10\u001b[39m\nReceived:\n\u001b[31m  Doubled:\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Doubled: 12\u001b[39m\nReceived:\n\u001b[31m  Doubled:\u001b[39m"
        ],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled;\n\n  $effect(() => {\n    doubled = number * 2;\n  });\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": false,
        "errors": [
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Doubled: 10\u001b[39m\nReceived:\n\u001b[31m  Doubled:\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Doubled: 12\u001b[39m\nReceived:\n\u001b[31m  Doubled:\u001b[39m"
        ],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $state(number * 2);\n\n  $effect(() => {\n    doubled = number * 2;\n  });\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $state(number * 2);\n\n  $effect(() => {\n    doubled = number * 2;\n  });\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $state(number * 2);\n\n  $effect(() => {\n    doubled = number * 2;\n  });\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $state(0);\n\n  $effect(() => {\n    doubled = number * 2;\n  });\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $state(0);\n\n  $effect(() => {\n    doubled = number * 2;\n  });\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $state(0);\n\n  $effect(() => {\n    doubled = number * 2;\n  });\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  },
  {
    "testName": "hello-world",
    "provider": "OpenAI",
    "modelId": "gpt-4o-2024-08-06",
    "numSamples": 10,
    "numCorrect": 10,
    "pass1": 1,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<style>\n  .greeting {\n    color: blue;\n    text-align: center;\n    margin: 10px;\n  }\n</style>\n\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>",
        "success": true,
        "errors": [],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<style>\n  .greeting {\n    color: blue;\n    text-align: center;\n    margin: 10px;\n  }\n</style>\n\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<style>\n  .greeting {\n    color: blue;\n    text-align: center;\n    margin: 10px;\n  }\n</style>\n\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<style>\n  .greeting {\n    color: blue;\n    margin: 10px;\n    text-align: center;\n  }\n</style>\n\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<style>\n  .greeting {\n    color: blue;\n    text-align: center;\n    margin: 10px;\n  }\n</style>\n\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<style>\n  .greeting {\n    color: blue;\n    text-align: center;\n    margin: 10px;\n  }\n</style>\n\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<script>\n  // No script needed for this component\n</script>\n\n<style>\n  .greeting {\n    color: blue;\n    text-align: center;\n    margin: 10px;\n  }\n</style>\n\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>\n\n<style>\n  .greeting {\n    color: blue;\n    text-align: center;\n    margin: 10px;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<style>\n  .greeting {\n    color: blue;\n    text-align: center;\n    margin: 10px;\n  }\n</style>\n\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>\n\n<style>\n  .greeting {\n    color: blue;\n    text-align: center;\n    margin: 10px;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  },
  {
    "testName": "inspect",
    "provider": "OpenAI",
    "modelId": "gpt-4o-2024-08-06",
    "numSamples": 10,
    "numCorrect": 0,
    "pass1": 0,
    "pass10": 0,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state(\"Hello world\");\n\n  $inspect(text);\n\n  $inspect(text).with((value) => {\n    console.log(\"Updated text:\", value);\n  });\n\n  $effect(() => {\n    $inspect.trace();\n  });\n\n  const charCount = $derived(text.length);\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <p data-testid=\"text-value\">Current text: {text}</p>\n  <p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"Hello world\"\u001b[39m\nReceived:\n\u001b[31m  Current text: Hello world\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"Testing $inspect\"\u001b[39m\nReceived:\n\u001b[31m  Current text: Testing $inspect\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"!@#$%^&*()\"\u001b[39m\nReceived:\n\u001b[31m  Current text: !@#$%^&*()\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"\"\u001b[39m\nReceived:\n\u001b[31m  Current text:\u001b[39m"
        ],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state(\"Hello world\");\n\n  $inspect(text);\n  \n  $inspect(text).with((newValue, oldValue) => {\n    console.log(\"Text updated from\", oldValue, \"to\", newValue);\n  });\n\n  $effect(() => {\n    $inspect.trace(text);\n  });\n\n  const charCount = $derived(text.length);\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <p data-testid=\"text-value\">Current text: {text}</p>\n  <p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"Hello world\"\u001b[39m\nReceived:\n\u001b[31m  Current text: Hello world\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"Testing $inspect\"\u001b[39m\nReceived:\n\u001b[31m  Current text: Testing $inspect\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"!@#$%^&*()\"\u001b[39m\nReceived:\n\u001b[31m  Current text: !@#$%^&*()\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"\"\u001b[39m\nReceived:\n\u001b[31m  Current text:\u001b[39m"
        ],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('Hello world');\n\n  $inspect(text);\n\n  $inspect(text).with((newVal, oldVal) => {\n    console.log(Input changed from \"${oldVal}\" to \"${newVal}\");\n  });\n\n  $effect(() => {\n    console.log($inspect.trace());\n  });\n\n  const charCount = $derived(text.length);\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <p data-testid=\"text-value\">Current text: {text}</p>\n  <p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "tmp/openai/Component.svelte:9:22 Unexpected token\nhttps://svelte.dev/e/js_parse_error"
        ],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state(\"Hello world\");\n\n  $inspect(text);\n\n  $inspect(text).with((newValue) => {\n    console.log(\"Input updated to:\", newValue);\n  });\n\n  $effect(() => {\n    $inspect.trace();\n  });\n\n  const charCount = $derived(text.length);\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <p data-testid=\"text-value\">Current text: {text}</p>\n  <p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"Hello world\"\u001b[39m\nReceived:\n\u001b[31m  Current text: Hello world\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"Testing $inspect\"\u001b[39m\nReceived:\n\u001b[31m  Current text: Testing $inspect\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"!@#$%^&*()\"\u001b[39m\nReceived:\n\u001b[31m  Current text: !@#$%^&*()\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"\"\u001b[39m\nReceived:\n\u001b[31m  Current text:\u001b[39m"
        ],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('Hello world');\n\n  $inspect(text).with((value) => {\n    console.log('Input updated to:', value);\n  });\n\n  $effect(() => {\n    $inspect.trace();\n  });\n\n  let charCount = $derived(text.length);\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value=\"{text}\" />\n  <p data-testid=\"text-value\">Current text: {text}</p>\n  <p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"Hello world\"\u001b[39m\nReceived:\n\u001b[31m  Current text: Hello world\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"Testing $inspect\"\u001b[39m\nReceived:\n\u001b[31m  Current text: Testing $inspect\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"!@#$%^&*()\"\u001b[39m\nReceived:\n\u001b[31m  Current text: !@#$%^&*()\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"\"\u001b[39m\nReceived:\n\u001b[31m  Current text:\u001b[39m"
        ],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state(\"Hello world\");\n\n  $inspect(text);\n\n  $inspect(text).with(value => {\n    console.log('Input updated to:', value);\n  });\n\n  let charCount = $derived(text.length);\n\n  $effect(() => {\n    $inspect.trace();\n  });\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value=\"{text}\" />\n  <p data-testid=\"text-value\">Current text: {text}</p>\n  <p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"Hello world\"\u001b[39m\nReceived:\n\u001b[31m  Current text: Hello world\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"Testing $inspect\"\u001b[39m\nReceived:\n\u001b[31m  Current text: Testing $inspect\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"!@#$%^&*()\"\u001b[39m\nReceived:\n\u001b[31m  Current text: !@#$%^&*()\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"\"\u001b[39m\nReceived:\n\u001b[31m  Current text:\u001b[39m"
        ],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state(\"Hello world\");\n\n  $inspect(text);\n  $inspect(text).with((value) => console.log(\"Updated value:\", value));\n  $effect(() => $inspect.trace());\n\n  const charCount = $derived(text.length);\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value=\"{text}\" />\n  <p data-testid=\"text-value\">Current text: {text}</p>\n  <p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "tmp/openai/Component.svelte:8:16 `$inspect.trace(...)` must be the first statement of a function body\nhttps://svelte.dev/e/inspect_trace_invalid_placement"
        ],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('Hello world');\n\n  $inspect(text);\n\n  $inspect(text).with((prev, next) => {\n    console.log(Text changed from \"${prev}\" to \"${next}\");\n  });\n\n  $effect(() => {\n    $inspect.trace();\n  });\n\n  const charCount = $derived(text.length);\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <p data-testid=\"text-value\">Current text: {text}</p>\n  <p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "tmp/openai/Component.svelte:9:21 Unexpected token\nhttps://svelte.dev/e/js_parse_error"
        ],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state(\"Hello world\");\n  $inspect(text);\n  $inspect(text).with(value => console.log('Updated value:', value));\n  $effect(() => {\n    $inspect.trace();\n  });\n  let charCount = $derived(text.length);\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <p data-testid=\"text-value\">Current text: {text}</p>\n  <p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"Hello world\"\u001b[39m\nReceived:\n\u001b[31m  Current text: Hello world\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"Testing $inspect\"\u001b[39m\nReceived:\n\u001b[31m  Current text: Testing $inspect\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"!@#$%^&*()\"\u001b[39m\nReceived:\n\u001b[31m  Current text: !@#$%^&*()\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"\"\u001b[39m\nReceived:\n\u001b[31m  Current text:\u001b[39m"
        ],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('Hello world');\n\n  $inspect(text);\n\n  $inspect(text).with((change) => {\n    console.log('Input updated:', change);\n  });\n\n  $effect(() => {\n    $inspect.trace();\n  });\n\n  const charCount = $derived(text.length);\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <p data-testid=\"text-value\">Current text: {text}</p>\n  <p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"Hello world\"\u001b[39m\nReceived:\n\u001b[31m  Current text: Hello world\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"Testing $inspect\"\u001b[39m\nReceived:\n\u001b[31m  Current text: Testing $inspect\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"!@#$%^&*()\"\u001b[39m\nReceived:\n\u001b[31m  Current text: !@#$%^&*()\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"\"\u001b[39m\nReceived:\n\u001b[31m  Current text:\u001b[39m"
        ],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  },
  {
    "testName": "props",
    "provider": "OpenAI",
    "modelId": "gpt-4o-2024-08-06",
    "numSamples": 10,
    "numCorrect": 10,
    "pass1": 1,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let { name = 'World', count = 0, showDetails = false } = $props();\n  let reactiveCount = $state(count);\n</script>\n\n<div>\n  <h1 data-testid=\"name-display\">Hello, {name}!</h1>\n  <p data-testid=\"count-display\">Count: {reactiveCount}</p>\n  <button data-testid=\"increment-button\" onclick={() => reactiveCount++}>Increment</button>\n\n  {#if showDetails}\n    <div data-testid=\"details\">\n      <p>Name is {name}</p>\n      <p>Count is {reactiveCount}</p>\n      <p>ShowDetails is {showDetails}</p>\n    </div>\n  {/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let { name = \"World\", count = 0, showDetails = false } = $props();\n  let reactiveCount = $state(count);\n</script>\n\n<div>\n  <h1 data-testid=\"name-display\">Hello, {name}!</h1>\n  <p data-testid=\"count-display\">Count: {reactiveCount}</p>\n  <button data-testid=\"increment-button\" onclick={() => reactiveCount++}>Increment</button>\n\n  {#if showDetails}\n    <div data-testid=\"details\">\n      <p>Name is {name}</p>\n      <p>Count is {reactiveCount}</p>\n      <p>ShowDetails is {showDetails}</p>\n    </div>\n  {/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let { name = \"World\", count = 0, showDetails = false } = $props();\n  let countState = $state(count);\n</script>\n\n<div>\n  <h1 data-testid=\"name-display\">Hello, {name}!</h1>\n  <p data-testid=\"count-display\">Count: {countState}</p>\n  <button data-testid=\"increment-button\" onclick={() => countState++}>Increment</button>\n\n  {#if showDetails}\n    <div data-testid=\"details\">\n      <p>Name is {name}</p>\n      <p>Count is {countState}</p>\n      <p>ShowDetails is {showDetails}</p>\n    </div>\n  {/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let { name = \"World\", count = 0, showDetails = false } = $props();\n  let reactiveCount = $state(count);\n</script>\n\n<div>\n  <h1 data-testid=\"name-display\">Hello, {name}!</h1>\n  <p data-testid=\"count-display\">Count: {reactiveCount}</p>\n  <button data-testid=\"increment-button\" onclick={() => reactiveCount++}>Increment</button>\n\n  {#if showDetails}\n    <div data-testid=\"details\">\n      <p>Name is {name}</p>\n      <p>Count is {reactiveCount}</p>\n      <p>ShowDetails is true</p>\n    </div>\n  {/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let { name = 'World', count = 0, showDetails = false } = $props();\n  let reactiveCount = $state(count);\n</script>\n\n<div>\n  <h1 data-testid=\"name-display\">Hello, {name}!</h1>\n  <p data-testid=\"count-display\">Count: {reactiveCount}</p>\n  <button data-testid=\"increment-button\" onclick={() => reactiveCount++}>Increment</button>\n  \n  {#if showDetails}\n    <div data-testid=\"details\">\n      <p>Name is {name}</p>\n      <p>Count is {reactiveCount}</p>\n      <p>ShowDetails is {showDetails}</p>\n    </div>\n  {/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let { name = \"World\", count = 0, showDetails = false } = $props();\n  let reactiveCount = $state(count);\n</script>\n\n<div>\n  <h1 data-testid=\"name-display\">Hello, {name}!</h1>\n  <p data-testid=\"count-display\">Count: {reactiveCount}</p>\n  <button data-testid=\"increment-button\" onclick={() => reactiveCount++}>Increment</button>\n\n  {#if showDetails}\n    <div data-testid=\"details\">\n      <p>Name is {name}</p>\n      <p>Count is {reactiveCount}</p>\n      <p>ShowDetails is true</p>\n    </div>\n  {/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let { name = 'World', count: initialCount = 0, showDetails = false } = $props();\n  let count = $state(initialCount);\n</script>\n\n<div>\n  <h1 data-testid=\"name-display\">Hello, {name}!</h1>\n  <p data-testid=\"count-display\">Count: {count}</p>\n  <button data-testid=\"increment-button\" onclick={() => count++}>Increment</button>\n\n  {#if showDetails}\n    <div data-testid=\"details\">\n      <p>Name is {name}</p>\n      <p>Count is {count}</p>\n      <p>ShowDetails is {showDetails}</p>\n    </div>\n  {/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let { name = \"World\", count = 0, showDetails = false } = $props();\n  let currentCount = $state(count);\n</script>\n\n<div>\n  <h1 data-testid=\"name-display\">Hello, {name}!</h1>\n  <p data-testid=\"count-display\">Count: {currentCount}</p>\n  <button data-testid=\"increment-button\" onclick={() => currentCount++}>Increment</button>\n\n  {#if showDetails}\n    <div data-testid=\"details\">\n      <p>Name is {name}</p>\n      <p>Count is {currentCount}</p>\n      <p>ShowDetails is {showDetails}</p>\n    </div>\n  {/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let { name = \"World\", count = 0, showDetails = false } = $props();\n  let currentCount = $state(count);\n</script>\n\n<div>\n  <h1 data-testid=\"name-display\">Hello, {name}!</h1>\n  <p data-testid=\"count-display\">Count: {currentCount}</p>\n  <button data-testid=\"increment-button\" onclick={() => currentCount++}>Increment</button>\n\n  {#if showDetails}\n    <div data-testid=\"details\">\n      <p>Name is {name}</p>\n      <p>Count is {currentCount}</p>\n      <p>ShowDetails is {showDetails}</p>\n    </div>\n  {/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let { name = \"World\", count = 0, showDetails = false } = $props();\n  let reactiveCount = $state(count);\n</script>\n\n<div>\n  <h1 data-testid=\"name-display\">Hello, {name}!</h1>\n  <p data-testid=\"count-display\">Count: {reactiveCount}</p>\n  <button data-testid=\"increment-button\" onclick={() => reactiveCount++}>Increment</button>\n\n  {#if showDetails}\n    <div data-testid=\"details\">\n      <p>Name is {name}</p>\n      <p>Count is {reactiveCount}</p>\n      <p>ShowDetails is {showDetails}</p>\n    </div>\n  {/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  },
  {
    "testName": "snippets",
    "provider": "OpenAI",
    "modelId": "gpt-4o-2024-08-06",
    "numSamples": 10,
    "numCorrect": 10,
    "pass1": 1,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let books = [\"The Lord of the Rings\", \"To Kill a Mockingbird\", \"1984\"];\n</script>\n\n<ul>\n  {#each books as book}\n    <li data-testid=\"book-item\">\n      {@render title(book)}\n    </li>\n  {/each}\n</ul>\n\n{#snippet title(bookTitle)}\n  <span data-testid=\"book-title\">{bookTitle}</span>\n{/snippet}",
        "success": true,
        "errors": [],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let books = [\"The Lord of the Rings\", \"To Kill a Mockingbird\", \"1984\"];\n</script>\n\n<ul>\n  {#each books as book}\n    <li data-testid=\"book-item\">\n      {@render title(book)}\n    </li>\n  {/each}\n</ul>\n\n{#snippet title(bookTitle)}\n  <span data-testid=\"book-title\">{bookTitle}</span>\n{/snippet}",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let books = [\"The Lord of the Rings\", \"To Kill a Mockingbird\", \"1984\"];\n</script>\n\n{#snippet title(book)}\n  <span data-testid=\"book-title\">{book}</span>\n{/snippet}\n\n<ul>\n  {#each books as book}\n    <li data-testid=\"book-item\">\n      {@render title(book)}\n    </li>\n  {/each}\n</ul>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let books = $state([\"The Lord of the Rings\", \"To Kill a Mockingbird\", \"1984\"]);\n</script>\n\n<ul>\n  {#each books as book}\n    <li data-testid=\"book-item\">\n      {@render title(book)}\n    </li>\n  {/each}\n</ul>\n\n{#snippet title(bookTitle)}\n  <span data-testid=\"book-title\">{bookTitle}</span>\n{/snippet}",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let bookTitles = [\"The Lord of the Rings\", \"To Kill a Mockingbird\", \"1984\"];\n</script>\n\n{#snippet title(bookTitle)}\n  <span data-testid=\"book-title\">{bookTitle}</span>\n{/snippet}\n\n<ul>\n  {#each bookTitles as bookTitle}\n    <li data-testid=\"book-item\">\n      {@render title(bookTitle)}\n    </li>\n  {/each}\n</ul>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let books = [\"The Lord of the Rings\", \"To Kill a Mockingbird\", \"1984\"];\n</script>\n\n<ul>\n  {#each books as book}\n    <li data-testid=\"book-item\">\n      {@render title(book)}\n    </li>\n  {/each}\n</ul>\n\n{#snippet title(bookTitle)}\n  <span data-testid=\"book-title\">{bookTitle}</span>\n{/snippet}",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let books = [\"The Lord of the Rings\", \"To Kill a Mockingbird\", \"1984\"];\n</script>\n\n<ul>\n  {#each books as book}\n    <li data-testid=\"book-item\">\n      {@render title(book)}\n    </li>\n  {/each}\n</ul>\n\n{#snippet title(bookTitle)}\n  <span data-testid=\"book-title\">{bookTitle}</span>\n{/snippet}",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let books = $state([\"The Lord of the Rings\", \"To Kill a Mockingbird\", \"1984\"]);\n</script>\n\n<ul>\n  {#each books as book}\n    <li data-testid=\"book-item\">\n      {@render title(book)}\n    </li>\n  {/each}\n</ul>\n\n{#snippet title(bookTitle)}\n  <span data-testid=\"book-title\">{bookTitle}</span>\n{/snippet}",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let books = [\"The Lord of the Rings\", \"To Kill a Mockingbird\", \"1984\"];\n</script>\n\n{#snippet title(bookTitle)}\n  <span data-testid=\"book-title\">{bookTitle}</span>\n{/snippet}\n\n<ul>\n  {#each books as book}\n    <li data-testid=\"book-item\">{@render title(book)}</li>\n  {/each}\n</ul>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let books = [\"The Lord of the Rings\", \"To Kill a Mockingbird\", \"1984\"];\n</script>\n\n<ul>\n  {#each books as book}\n    <li data-testid=\"book-item\">{@render title(book)}</li>\n  {/each}\n</ul>\n\n{#snippet title(bookTitle)}\n  <span data-testid=\"book-title\">{bookTitle}</span>\n{/snippet}",
        "success": true,
        "errors": [],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  },
  {
    "testName": "counter",
    "provider": "Anthropic",
    "modelId": "claude-3-7-sonnet-20250219",
    "numSamples": 10,
    "numCorrect": 10,
    "pass1": 1,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let count = $state(0);\n\n  function increment() {\n    count++;\n  }\n\n  function decrement() {\n    count--;\n  }\n</script>\n\n<div class=\"counter\">\n  <button data-testid=\"decrement-button\" onclick={decrement}>-</button>\n  <span data-testid=\"count-value\">{count}</span>\n  <button data-testid=\"increment-button\" onclick={increment}>+</button>\n</div>\n\n<style>\n  .counter {\n    display: flex;\n    align-items: center;\n    gap: 1rem;\n  }\n  \n  button {\n    padding: 0.5rem 1rem;\n    font-size: 1.2rem;\n    cursor: pointer;\n  }\n  \n  span {\n    font-size: 1.5rem;\n    min-width: 2rem;\n    text-align: center;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let count = $state(0);\n\n  function increment() {\n    count += 1;\n  }\n\n  function decrement() {\n    count -= 1;\n  }\n</script>\n\n<div class=\"counter\">\n  <button data-testid=\"decrement-button\" onclick={decrement}>-</button>\n  <span data-testid=\"count-value\">{count}</span>\n  <button data-testid=\"increment-button\" onclick={increment}>+</button>\n</div>\n\n<style>\n  .counter {\n    display: flex;\n    align-items: center;\n    gap: 1rem;\n  }\n  \n  button {\n    padding: 0.5rem 1rem;\n    font-size: 1.25rem;\n    cursor: pointer;\n  }\n  \n  span {\n    font-size: 1.5rem;\n    min-width: 2rem;\n    text-align: center;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let count = $state(0);\n  \n  function increment() {\n    count++;\n  }\n  \n  function decrement() {\n    count--;\n  }\n</script>\n\n<div class=\"counter\">\n  <button data-testid=\"decrement-button\" onclick={decrement}>-</button>\n  <span data-testid=\"count-value\">{count}</span>\n  <button data-testid=\"increment-button\" onclick={increment}>+</button>\n</div>\n\n<style>\n  .counter {\n    display: flex;\n    align-items: center;\n    gap: 1rem;\n    font-size: 1.5rem;\n  }\n  \n  button {\n    padding: 0.5rem 1rem;\n    font-size: 1.5rem;\n    cursor: pointer;\n    border-radius: 4px;\n    border: 1px solid #ccc;\n    background-color: #f5f5f5;\n  }\n  \n  button:hover {\n    background-color: #e0e0e0;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let count = $state(0);\n\n  function increment() {\n    count++;\n  }\n\n  function decrement() {\n    count--;\n  }\n</script>\n\n<div class=\"counter\">\n  <button data-testid=\"decrement-button\" onclick={decrement}>-</button>\n  <span data-testid=\"count-value\">{count}</span>\n  <button data-testid=\"increment-button\" onclick={increment}>+</button>\n</div>\n\n<style>\n  .counter {\n    display: flex;\n    align-items: center;\n    gap: 1rem;\n  }\n  \n  button {\n    padding: 0.5rem 1rem;\n    font-size: 1.25rem;\n    cursor: pointer;\n  }\n  \n  span {\n    font-size: 1.5rem;\n    min-width: 2rem;\n    text-align: center;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let count = $state(0);\n\n  function increment() {\n    count++;\n  }\n\n  function decrement() {\n    count--;\n  }\n</script>\n\n<div class=\"counter\">\n  <button data-testid=\"decrement-button\" onclick={decrement}>-</button>\n  <span data-testid=\"count-value\">{count}</span>\n  <button data-testid=\"increment-button\" onclick={increment}>+</button>\n</div>\n\n<style>\n  .counter {\n    display: flex;\n    align-items: center;\n    gap: 1rem;\n    padding: 1rem;\n  }\n  \n  button {\n    padding: 0.5rem 1rem;\n    font-size: 1.25rem;\n    cursor: pointer;\n  }\n  \n  span {\n    font-size: 1.5rem;\n    font-weight: bold;\n    min-width: 2rem;\n    text-align: center;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let count = $state(0);\n\n  function increment() {\n    count++;\n  }\n\n  function decrement() {\n    count--;\n  }\n</script>\n\n<div class=\"counter\">\n  <button data-testid=\"decrement-button\" onclick={decrement}>-</button>\n  <span data-testid=\"count-value\">{count}</span>\n  <button data-testid=\"increment-button\" onclick={increment}>+</button>\n</div>\n\n<style>\n  .counter {\n    display: flex;\n    align-items: center;\n    gap: 1rem;\n  }\n  \n  button {\n    padding: 0.5rem 1rem;\n    font-size: 1.2rem;\n    cursor: pointer;\n  }\n  \n  span {\n    font-size: 1.5rem;\n    min-width: 2rem;\n    text-align: center;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let count = $state(0);\n\n  function increment() {\n    count++;\n  }\n\n  function decrement() {\n    count--;\n  }\n</script>\n\n<div class=\"counter\">\n  <button data-testid=\"decrement-button\" onclick={decrement}>-</button>\n  <span data-testid=\"count-value\">{count}</span>\n  <button data-testid=\"increment-button\" onclick={increment}>+</button>\n</div>\n\n<style>\n  .counter {\n    display: flex;\n    align-items: center;\n    gap: 1rem;\n  }\n  \n  button {\n    padding: 0.5rem 1rem;\n    font-size: 1.2rem;\n    cursor: pointer;\n  }\n  \n  span {\n    font-size: 1.5rem;\n    min-width: 2rem;\n    text-align: center;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let count = $state(0);\n\n  function increment() {\n    count++;\n  }\n\n  function decrement() {\n    count--;\n  }\n</script>\n\n<div class=\"counter\">\n  <button data-testid=\"decrement-button\" onclick={decrement}>-</button>\n  <span data-testid=\"count-value\">{count}</span>\n  <button data-testid=\"increment-button\" onclick={increment}>+</button>\n</div>\n\n<style>\n  .counter {\n    display: flex;\n    align-items: center;\n    gap: 1rem;\n  }\n  \n  button {\n    padding: 0.5rem 1rem;\n    font-size: 1.25rem;\n    cursor: pointer;\n  }\n  \n  span {\n    font-size: 1.5rem;\n    min-width: 2rem;\n    text-align: center;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let count = $state(0);\n\n  function increment() {\n    count++;\n  }\n\n  function decrement() {\n    count--;\n  }\n</script>\n\n<div class=\"counter\">\n  <button data-testid=\"decrement-button\" onclick={decrement}>-</button>\n  <span data-testid=\"count-value\">{count}</span>\n  <button data-testid=\"increment-button\" onclick={increment}>+</button>\n</div>\n\n<style>\n  .counter {\n    display: flex;\n    align-items: center;\n    gap: 1rem;\n  }\n  \n  button {\n    padding: 0.5rem 1rem;\n    font-size: 1.25rem;\n    cursor: pointer;\n  }\n  \n  span {\n    font-size: 1.5rem;\n    min-width: 2rem;\n    text-align: center;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let count = $state(0);\n\n  function increment() {\n    count += 1;\n  }\n\n  function decrement() {\n    count -= 1;\n  }\n</script>\n\n<div class=\"counter\">\n  <button data-testid=\"decrement-button\" onclick={decrement}>-</button>\n  <span data-testid=\"count-value\">{count}</span>\n  <button data-testid=\"increment-button\" onclick={increment}>+</button>\n</div>\n\n<style>\n  .counter {\n    display: flex;\n    align-items: center;\n    gap: 1rem;\n  }\n  \n  button {\n    padding: 0.5rem 1rem;\n    font-size: 1.25rem;\n    cursor: pointer;\n  }\n  \n  span {\n    font-size: 1.5rem;\n    min-width: 2rem;\n    text-align: center;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  },
  {
    "testName": "derived",
    "provider": "Anthropic",
    "modelId": "claude-3-7-sonnet-20250219",
    "numSamples": 10,
    "numCorrect": 10,
    "pass1": 1,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $derived(number * 2);\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $derived(number * 2);\n  \n  function increment() {\n    number += 1;\n  }\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $derived(number * 2);\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $derived(number * 2);\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet number = $state(5);\n\tlet doubled = $derived(number * 2);\n\t\n\tfunction increment() {\n\t\tnumber += 1;\n\t}\n</script>\n\n<div>\n\t<p data-testid=\"number-value\">Number: {number}</p>\n\t<p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n\t<button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $derived(number * 2);\n\n  function increment() {\n    number += 1;\n  }\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $derived(number * 2);\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $derived(number * 2);\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $derived(number * 2);\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $derived(number * 2);\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  },
  {
    "testName": "derived-by",
    "provider": "Anthropic",
    "modelId": "claude-3-7-sonnet-20250219",
    "numSamples": 10,
    "numCorrect": 10,
    "pass1": 1,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('');\n  \n  let stats = $derived.by(() => {\n    const wordCount = text.trim() === '' ? 0 : text.trim().split(/\\s+/).length;\n    const charCount = text.length;\n    const isLong = wordCount > 15;\n    \n    return {\n      wordCount,\n      charCount,\n      isLong\n    };\n  });\n  \n  function clearText() {\n    text = '';\n  }\n</script>\n\n<div>\n  <input \n    data-testid=\"text-input\" \n    type=\"text\" \n    bind:value={text} \n  />\n  <button \n    data-testid=\"clear-button\" \n    onclick={clearText}\n  >\n    Clear\n  </button>\n  <div>\n    <p data-testid=\"word-count\">Words: {stats.wordCount}</p>\n    <p data-testid=\"char-count\">Characters: {stats.charCount}</p>\n    <p data-testid=\"length-indicator\">Status: {stats.isLong ? 'Long text' : 'Short text'}</p>\n  </div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('');\n  \n  let stats = $derived.by(() => {\n    const wordCount = text.trim() === '' ? 0 : text.trim().split(/\\s+/).length;\n    const charCount = text.length;\n    const isLong = wordCount > 15;\n    \n    return {\n      wordCount,\n      charCount,\n      isLong\n    };\n  });\n  \n  function clearText() {\n    text = '';\n  }\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <button data-testid=\"clear-button\" onclick={clearText}>Clear</button>\n  <div>\n    <p data-testid=\"word-count\">Words: {stats.wordCount}</p>\n    <p data-testid=\"char-count\">Characters: {stats.charCount}</p>\n    <p data-testid=\"length-indicator\">Status: {stats.isLong ? 'Long text' : 'Short text'}</p>\n  </div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('');\n  \n  let stats = $derived.by(() => {\n    const trimmedText = text.trim();\n    const wordCount = trimmedText === '' ? 0 : trimmedText.split(/\\s+/).length;\n    const charCount = text.length;\n    const isLong = wordCount > 15;\n    \n    return {\n      wordCount,\n      charCount,\n      isLong\n    };\n  });\n  \n  function clearText() {\n    text = '';\n  }\n</script>\n\n<div>\n  <input \n    data-testid=\"text-input\" \n    type=\"text\" \n    bind:value={text} \n  />\n  <button \n    data-testid=\"clear-button\" \n    onclick={clearText}\n  >\n    Clear\n  </button>\n  <div>\n    <p data-testid=\"word-count\">Words: {stats.wordCount}</p>\n    <p data-testid=\"char-count\">Characters: {stats.charCount}</p>\n    <p data-testid=\"length-indicator\">Status: {stats.isLong ? 'Long text' : 'Short text'}</p>\n  </div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('');\n\n  let stats = $derived.by(() => {\n    const wordCount = text.trim() === '' ? 0 : text.trim().split(/\\s+/).length;\n    const charCount = text.length;\n    const isLong = wordCount > 15;\n    \n    return {\n      wordCount,\n      charCount,\n      isLong\n    };\n  });\n\n  function clearText() {\n    text = '';\n  }\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <button data-testid=\"clear-button\" onclick={clearText}>Clear</button>\n  <div>\n    <p data-testid=\"word-count\">Words: {stats.wordCount}</p>\n    <p data-testid=\"char-count\">Characters: {stats.charCount}</p>\n    <p data-testid=\"length-indicator\">Status: {stats.isLong ? 'Long text' : 'Short text'}</p>\n  </div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('');\n  \n  let stats = $derived.by(() => {\n    const wordCount = text.trim() === '' ? 0 : text.trim().split(/\\s+/).length;\n    const charCount = text.length;\n    const isLong = wordCount > 15;\n    \n    return {\n      wordCount,\n      charCount,\n      isLong\n    };\n  });\n  \n  function clearText() {\n    text = '';\n  }\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <button data-testid=\"clear-button\" onclick={clearText}>Clear</button>\n  <div>\n    <p data-testid=\"word-count\">Words: {stats.wordCount}</p>\n    <p data-testid=\"char-count\">Characters: {stats.charCount}</p>\n    <p data-testid=\"length-indicator\">Status: {stats.isLong ? 'Long text' : 'Short text'}</p>\n  </div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('');\n  \n  let stats = $derived.by(() => {\n    const wordCount = text.trim() === '' ? 0 : text.trim().split(/\\s+/).length;\n    const charCount = text.length;\n    const isLong = wordCount > 15;\n    \n    return {\n      wordCount,\n      charCount,\n      isLong\n    };\n  });\n  \n  function clearText() {\n    text = '';\n  }\n</script>\n\n<div>\n  <input \n    data-testid=\"text-input\" \n    type=\"text\" \n    bind:value={text}\n  />\n  <button \n    data-testid=\"clear-button\" \n    onclick={clearText}\n  >\n    Clear\n  </button>\n  <div>\n    <p data-testid=\"word-count\">Words: {stats.wordCount}</p>\n    <p data-testid=\"char-count\">Characters: {stats.charCount}</p>\n    <p data-testid=\"length-indicator\">Status: {stats.isLong ? 'Long text' : 'Short text'}</p>\n  </div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('');\n  \n  let stats = $derived.by(() => {\n    const words = text.trim() === '' ? 0 : text.trim().split(/\\s+/).length;\n    const chars = text.length;\n    const isLong = words > 15;\n    \n    return { words, chars, isLong };\n  });\n  \n  function clearText() {\n    text = '';\n  }\n</script>\n\n<div>\n  <input \n    data-testid=\"text-input\" \n    type=\"text\" \n    bind:value={text} \n  />\n  <button \n    data-testid=\"clear-button\" \n    onclick={clearText}\n  >\n    Clear\n  </button>\n  <div>\n    <p data-testid=\"word-count\">Words: {stats.words}</p>\n    <p data-testid=\"char-count\">Characters: {stats.chars}</p>\n    <p data-testid=\"length-indicator\">Status: {stats.isLong ? 'Long text' : 'Short text'}</p>\n  </div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('');\n  \n  let stats = $derived.by(() => {\n    const words = text.trim() === '' ? 0 : text.trim().split(/\\s+/).length;\n    const chars = text.length;\n    const isLong = words > 15;\n    \n    return { words, chars, isLong };\n  });\n  \n  function clearText() {\n    text = '';\n  }\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <button data-testid=\"clear-button\" onclick={clearText}>Clear</button>\n  <div>\n    <p data-testid=\"word-count\">Words: {stats.words}</p>\n    <p data-testid=\"char-count\">Characters: {stats.chars}</p>\n    <p data-testid=\"length-indicator\">Status: {stats.isLong ? 'Long text' : 'Short text'}</p>\n  </div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state(\"\");\n  \n  let stats = $derived.by(() => {\n    const wordCount = text.trim() === \"\" ? 0 : text.trim().split(/\\s+/).length;\n    const charCount = text.length;\n    const isLong = wordCount > 15;\n    \n    return {\n      wordCount,\n      charCount,\n      isLong\n    };\n  });\n  \n  function clearText() {\n    text = \"\";\n  }\n</script>\n\n<div>\n  <input \n    data-testid=\"text-input\" \n    type=\"text\" \n    bind:value={text} \n  />\n  <button \n    data-testid=\"clear-button\" \n    onclick={clearText}\n  >\n    Clear\n  </button>\n  <div>\n    <p data-testid=\"word-count\">Words: {stats.wordCount}</p>\n    <p data-testid=\"char-count\">Characters: {stats.charCount}</p>\n    <p data-testid=\"length-indicator\">Status: {stats.isLong ? 'Long text' : 'Short text'}</p>\n  </div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('');\n  \n  let stats = $derived.by(() => {\n    const wordCount = text.trim() === '' ? 0 : text.trim().split(/\\s+/).length;\n    const charCount = text.length;\n    const isLong = wordCount > 15;\n    \n    return { wordCount, charCount, isLong };\n  });\n  \n  function clearText() {\n    text = '';\n  }\n</script>\n\n<div>\n  <input \n    data-testid=\"text-input\" \n    type=\"text\" \n    bind:value={text} \n  />\n  <button \n    data-testid=\"clear-button\" \n    onclick={clearText}\n  >\n    Clear\n  </button>\n  <div>\n    <p data-testid=\"word-count\">Words: {stats.wordCount}</p>\n    <p data-testid=\"char-count\">Characters: {stats.charCount}</p>\n    <p data-testid=\"length-indicator\">Status: {stats.isLong ? 'Long text' : 'Short text'}</p>\n  </div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  },
  {
    "testName": "each",
    "provider": "Anthropic",
    "modelId": "claude-3-7-sonnet-20250219",
    "numSamples": 10,
    "numCorrect": 10,
    "pass1": 1,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let characters = $state([\"Jerry\", \"Elaine\", \"Kramer\"]);\n  \n  function addGeorge() {\n    characters = [...characters, \"George\"];\n  }\n</script>\n\n<div>\n  <ul data-testid=\"characters-list\">\n    {#each characters as character}\n      <li data-testid=\"character\">{character}</li>\n    {/each}\n  </ul>\n  <button data-testid=\"add-george-button\" onclick={addGeorge}>Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let characters = $state([\"Jerry\", \"Elaine\", \"Kramer\"]);\n\n  function addGeorge() {\n    characters = [...characters, \"George\"];\n  }\n</script>\n\n<div>\n  <ul data-testid=\"characters-list\">\n    {#each characters as character}\n      <li data-testid=\"character\">{character}</li>\n    {/each}\n  </ul>\n  <button data-testid=\"add-george-button\" onclick={addGeorge}>Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let characters = $state(['Jerry', 'Elaine', 'Kramer']);\n  \n  function addGeorge() {\n    characters = [...characters, 'George'];\n  }\n</script>\n\n<div>\n  <ul data-testid=\"characters-list\">\n    {#each characters as character}\n      <li data-testid=\"character\">{character}</li>\n    {/each}\n  </ul>\n  <button data-testid=\"add-george-button\" onclick={addGeorge}>Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let characters = $state([\"Jerry\", \"Elaine\", \"Kramer\"]);\n  \n  function addGeorge() {\n    characters = [...characters, \"George\"];\n  }\n</script>\n\n<div>\n  <ul data-testid=\"characters-list\">\n    {#each characters as character}\n      <li data-testid=\"character\">{character}</li>\n    {/each}\n  </ul>\n  <button data-testid=\"add-george-button\" onclick={addGeorge}>Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let characters = $state([\"Jerry\", \"Elaine\", \"Kramer\"]);\n  \n  function addGeorge() {\n    characters = [...characters, \"George\"];\n  }\n</script>\n\n<div>\n  <ul data-testid=\"characters-list\">\n    {#each characters as character}\n      <li data-testid=\"character\">{character}</li>\n    {/each}\n  </ul>\n  <button data-testid=\"add-george-button\" onclick={addGeorge}>Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let characters = $state([\"Jerry\", \"Elaine\", \"Kramer\"]);\n  \n  function addGeorge() {\n    characters = [...characters, \"George\"];\n  }\n</script>\n\n<div>\n  <ul data-testid=\"characters-list\">\n    {#each characters as character}\n      <li data-testid=\"character\">{character}</li>\n    {/each}\n  </ul>\n  <button data-testid=\"add-george-button\" onclick={addGeorge}>Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let characters = $state([\"Jerry\", \"Elaine\", \"Kramer\"]);\n  \n  function addGeorge() {\n    characters = [...characters, \"George\"];\n  }\n</script>\n\n<div>\n  <ul data-testid=\"characters-list\">\n    {#each characters as character}\n      <li data-testid=\"character\">{character}</li>\n    {/each}\n  </ul>\n  <button data-testid=\"add-george-button\" onclick={addGeorge}>Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let characters = $state(['Jerry', 'Elaine', 'Kramer']);\n  \n  function addGeorge() {\n    characters = [...characters, 'George'];\n  }\n</script>\n\n<div>\n  <ul data-testid=\"characters-list\">\n    {#each characters as character}\n      <li data-testid=\"character\">{character}</li>\n    {/each}\n  </ul>\n  <button data-testid=\"add-george-button\" onclick={addGeorge}>Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let characters = $state([\"Jerry\", \"Elaine\", \"Kramer\"]);\n  \n  function addGeorge() {\n    characters = [...characters, \"George\"];\n  }\n</script>\n\n<div>\n  <ul data-testid=\"characters-list\">\n    {#each characters as character}\n      <li data-testid=\"character\">{character}</li>\n    {/each}\n  </ul>\n  <button data-testid=\"add-george-button\" onclick={addGeorge}>Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let characters = $state([\"Jerry\", \"Elaine\", \"Kramer\"]);\n\n  function addGeorge() {\n    characters = [...characters, \"George\"];\n  }\n</script>\n\n<div>\n  <ul data-testid=\"characters-list\">\n    {#each characters as character}\n      <li data-testid=\"character\">{character}</li>\n    {/each}\n  </ul>\n  <button data-testid=\"add-george-button\" onclick={addGeorge}>Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  },
  {
    "testName": "effect",
    "provider": "Anthropic",
    "modelId": "claude-3-7-sonnet-20250219",
    "numSamples": 10,
    "numCorrect": 10,
    "pass1": 1,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $state(0);\n  \n  $effect(() => {\n    doubled = number * 2;\n  });\n  \n  function increment() {\n    number += 1;\n  }\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $state(10);\n  \n  $effect(() => {\n    doubled = number * 2;\n  });\n  \n  function increment() {\n    number += 1;\n  }\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $state(10);\n  \n  $effect(() => {\n    doubled = number * 2;\n  });\n  \n  function increment() {\n    number += 1;\n  }\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $state(0);\n  \n  $effect(() => {\n    doubled = number * 2;\n  });\n  \n  function increment() {\n    number += 1;\n  }\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $state(0);\n  \n  $effect(() => {\n    doubled = number * 2;\n  });\n  \n  function increment() {\n    number += 1;\n  }\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $state(0);\n  \n  $effect(() => {\n    doubled = number * 2;\n  });\n  \n  function increment() {\n    number += 1;\n  }\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $state(10);\n  \n  $effect(() => {\n    doubled = number * 2;\n  });\n  \n  function increment() {\n    number += 1;\n  }\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $state(0);\n  \n  $effect(() => {\n    doubled = number * 2;\n  });\n  \n  function increment() {\n    number += 1;\n  }\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $state(0);\n  \n  $effect(() => {\n    doubled = number * 2;\n  });\n  \n  function increment() {\n    number += 1;\n  }\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $state(0);\n  \n  $effect(() => {\n    doubled = number * 2;\n  });\n  \n  function increment() {\n    number += 1;\n  }\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  },
  {
    "testName": "hello-world",
    "provider": "Anthropic",
    "modelId": "claude-3-7-sonnet-20250219",
    "numSamples": 10,
    "numCorrect": 10,
    "pass1": 1,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>\n\n<style>\n  .greeting {\n    color: blue;\n    text-align: center;\n    margin: 1rem;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>\n\n<style>\n  .greeting {\n    color: blue;\n    text-align: center;\n    margin: 1rem;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>\n\n<style>\n  .greeting {\n    color: blue;\n    text-align: center;\n    margin: 1rem;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>\n\n<style>\n  .greeting {\n    color: blue;\n    text-align: center;\n    margin: 1rem;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>\n\n<style>\n  .greeting {\n    color: blue;\n    text-align: center;\n    margin: 20px;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>\n\n<style>\n  .greeting {\n    color: blue;\n    text-align: center;\n    margin: 20px;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>\n\n<style>\n  .greeting {\n    color: blue;\n    text-align: center;\n    margin: 1rem;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>\n\n<style>\n  .greeting {\n    color: blue;\n    text-align: center;\n    margin: 10px;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>\n\n<style>\n  .greeting {\n    color: blue;\n    text-align: center;\n    margin: 1rem;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>\n\n<style>\n  .greeting {\n    color: blue;\n    text-align: center;\n    margin: 1em;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  },
  {
    "testName": "inspect",
    "provider": "Anthropic",
    "modelId": "claude-3-7-sonnet-20250219",
    "numSamples": 10,
    "numCorrect": 0,
    "pass1": 0,
    "pass10": 0,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state(\"Hello world\");\n  \n  // Basic $inspect to log the input value\n  $inspect(text);\n  \n  // Custom callback with $inspect.with\n  $inspect(text).with((value, previous) => {\n    console.log(Text changed from \"${previous}\" to \"${value}\");\n  });\n  \n  // Using $effect with $inspect.trace()\n  $effect(() => {\n    $inspect.trace();\n    console.log(Effect triggered by text: ${text});\n  });\n  \n  // Character count is derived from text\n  const charCount = $derived(text.length);\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <p data-testid=\"text-value\">Current text: {text}</p>\n  <p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "tmp/anthropic/Component.svelte:11:21 Unexpected token\nhttps://svelte.dev/e/js_parse_error"
        ],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state(\"Hello world\");\n  \n  // Basic $inspect to log the input value\n  $inspect(text);\n  \n  // Custom tracking with $inspect(...).with\n  $inspect(text).with((value, previous) => {\n    console.log(Text changed from \"${previous}\" to \"${value}\");\n  });\n  \n  // Using $effect with $inspect.trace()\n  $effect(() => {\n    $inspect.trace();\n    console.log(Effect running for text: ${text});\n  });\n  \n  // Character count is derived from text\n  const charCount = $derived(text.length);\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <p data-testid=\"text-value\">Current text: {text}</p>\n  <p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "tmp/anthropic/Component.svelte:11:21 Unexpected token\nhttps://svelte.dev/e/js_parse_error"
        ],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state(\"Hello world\");\n  \n  // Basic $inspect\n  $inspect(text);\n  \n  // $inspect with custom callback\n  $inspect(text).with((value, previous) => {\n    console.log(Text changed from \"${previous}\" to \"${value}\");\n  });\n  \n  // Using $inspect.trace() in an effect\n  $effect(() => {\n    $inspect.trace();\n    console.log(Current text: ${text});\n  });\n  \n  // Derived value for character count\n  let charCount = $derived(text.length);\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <p data-testid=\"text-value\">Current text: {text}</p>\n  <p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "tmp/anthropic/Component.svelte:11:21 Unexpected token\nhttps://svelte.dev/e/js_parse_error"
        ],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state(\"Hello world\");\n  \n  // Basic $inspect to log value\n  $inspect(text);\n  \n  // Using custom callback with $inspect.with\n  $inspect(text).with((value, previous) => {\n    console.log(Text changed from \"${previous}\" to \"${value}\");\n  });\n  \n  // Character count as derived value\n  let charCount = $derived(text.length);\n  \n  // Using $inspect.trace in an effect\n  $effect(() => {\n    $inspect.trace();\n    console.log(Effect triggered: text is now \"${text}\");\n  });\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <p data-testid=\"text-value\">Current text: {text}</p>\n  <p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "tmp/anthropic/Component.svelte:11:21 Unexpected token\nhttps://svelte.dev/e/js_parse_error"
        ],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state(\"Hello world\");\n  \n  // Basic $inspect usage\n  $inspect(text);\n  \n  // Using $inspect.with to track updates with custom callback\n  $inspect(text).with((value, previous) => {\n    console.log(Text changed from \"${previous}\" to \"${value}\");\n  });\n  \n  // Using $inspect.trace in an effect\n  $effect(() => {\n    $inspect.trace();\n    console.log(Text is now: ${text});\n  });\n  \n  // Derived value for character count\n  const charCount = $derived(text.length);\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <p data-testid=\"text-value\">Current text: {text}</p>\n  <p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "tmp/anthropic/Component.svelte:11:21 Unexpected token\nhttps://svelte.dev/e/js_parse_error"
        ],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state(\"Hello world\");\n  let count = $derived(text.length);\n\n  $inspect(text);\n  $inspect(text).with((value, previous) => {\n    console.log(Text changed from \"${previous}\" to \"${value}\");\n  });\n\n  $effect(() => {\n    $inspect.trace();\n    console.log(Current text length: ${count});\n  });\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <p data-testid=\"text-value\">Current text: {text}</p>\n  <p data-testid=\"char-count\">Character count: {count}</p>\n</div>",
        "success": false,
        "errors": [
          "tmp/anthropic/Component.svelte:9:21 Unexpected token\nhttps://svelte.dev/e/js_parse_error"
        ],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state(\"Hello world\");\n  \n  // Basic $inspect rune to log input value\n  $inspect(text);\n  \n  // Using $inspect.with to track updates with custom callback\n  $inspect(text).with((value, previous) => {\n    console.log(Text changed from \"${previous}\" to \"${value}\");\n  });\n  \n  // Using $effect with $inspect.trace() to trace when the effect runs\n  $effect(() => {\n    $inspect.trace();\n    console.log(Effect running for text: ${text});\n  });\n  \n  // Derived value for character count\n  const charCount = $derived(text.length);\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <p data-testid=\"text-value\">Current text: {text}</p>\n  <p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "tmp/anthropic/Component.svelte:11:21 Unexpected token\nhttps://svelte.dev/e/js_parse_error"
        ],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state(\"Hello world\");\n  \n  // Basic $inspect to log the input value\n  $inspect(text);\n  \n  // Custom callback with $inspect.with\n  $inspect(text).with((value, prev) => {\n    console.log(Text changed from \"${prev}\" to \"${value}\");\n  });\n  \n  // Using $effect with $inspect.trace\n  $effect(() => {\n    if (text.length > 20) {\n      $inspect.trace();\n      console.warn(\"Text is getting long!\");\n    }\n  });\n  \n  // Derived value for character count\n  const charCount = $derived(text.length);\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <p data-testid=\"text-value\">Current text: {text}</p>\n  <p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "tmp/anthropic/Component.svelte:11:21 Unexpected token\nhttps://svelte.dev/e/js_parse_error"
        ],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state(\"Hello world\");\n  let charCount = $derived(text.length);\n  \n  $inspect(text);\n  \n  $inspect(text).with((value, label) => {\n    console.log(${label} updated to: \"${value}\");\n  });\n  \n  $effect(() => {\n    $inspect.trace();\n    console.log(Text changed to: ${text});\n  });\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <p data-testid=\"text-value\">Current text: {text}</p>\n  <p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "tmp/anthropic/Component.svelte:10:17 Unexpected token\nhttps://svelte.dev/e/js_parse_error"
        ],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state(\"Hello world\");\n  \n  // Basic $inspect usage to log the value\n  $inspect(text);\n  \n  // Using $inspect.with to track updates with custom callback\n  $inspect(text).with((value, previous) => {\n    console.log(Text changed from \"${previous}\" to \"${value}\");\n  });\n  \n  // Using $effect with $inspect.trace() to log the dependency tree\n  $effect(() => {\n    console.log(Current text: ${text});\n    $inspect.trace();\n  });\n  \n  // Derived value for character count\n  let charCount = $derived(text.length);\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <p data-testid=\"text-value\">Current text: {text}</p>\n  <p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "tmp/anthropic/Component.svelte:11:21 Unexpected token\nhttps://svelte.dev/e/js_parse_error"
        ],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  },
  {
    "testName": "props",
    "provider": "Anthropic",
    "modelId": "claude-3-7-sonnet-20250219",
    "numSamples": 10,
    "numCorrect": 9,
    "pass1": 0.9,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let { name = \"World\", count = 0, showDetails = false } = $props();\n  \n  let counter = $state(count);\n  \n  function increment() {\n    counter++;\n  }\n</script>\n\n<div>\n  <h1 data-testid=\"name-display\">Hello, {name}!</h1>\n  <p data-testid=\"count-display\">Count: {counter}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n\n  {#if showDetails}\n    <div data-testid=\"details\">\n      <p>Name is {name}</p>\n      <p>Count is {counter}</p>\n      <p>ShowDetails is {showDetails}</p>\n    </div>\n  {/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let { name = \"World\", count = 0, showDetails = false } = $props();\n  \n  let counter = $state(count);\n  \n  function increment() {\n    counter++;\n  }\n</script>\n\n<div>\n  <h1 data-testid=\"name-display\">Hello, {name}!</h1>\n  <p data-testid=\"count-display\">Count: {counter}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n  \n  {#if showDetails}\n    <div data-testid=\"details\">\n      <p>Name is {name}</p>\n      <p>Count is {counter}</p>\n      <p>ShowDetails is {showDetails}</p>\n    </div>\n  {/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let { name = \"World\", count = 0, showDetails = false } = $props();\n  \n  let counter = $state(count);\n  \n  function increment() {\n    counter++;\n  }\n</script>\n\n<div>\n  <h1 data-testid=\"name-display\">Hello, {name}!</h1>\n  <p data-testid=\"count-display\">Count: {counter}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n\n  {#if showDetails}\n    <div data-testid=\"details\">\n      <p>Name is {name}</p>\n      <p>Count is {counter}</p>\n      <p>ShowDetails is {showDetails}</p>\n    </div>\n  {/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let { name = \"World\", count = 0, showDetails = false } = $props();\n  \n  let counter = $state(count);\n  \n  function increment() {\n    counter++;\n  }\n</script>\n\n<div>\n  <h1 data-testid=\"name-display\">Hello, {name}!</h1>\n  <p data-testid=\"count-display\">Count: {counter}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n\n  {#if showDetails}\n    <div data-testid=\"details\">\n      <p>Name is {name}</p>\n      <p>Count is {counter}</p>\n      <p>ShowDetails is {showDetails}</p>\n    </div>\n  {/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let { name = \"World\", count = 0, showDetails = false } = $props();\n  \n  let counter = $state(count);\n  \n  function increment() {\n    counter++;\n  }\n</script>\n\n<div>\n  <h1 data-testid=\"name-display\">Hello, {name}!</h1>\n  <p data-testid=\"count-display\">Count: {counter}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n\n  {#if showDetails}\n    <div data-testid=\"details\">\n      <p>Name is {name}</p>\n      <p>Count is {counter}</p>\n      <p>ShowDetails is {showDetails}</p>\n    </div>\n  {/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let { name = \"World\", count = 0, showDetails = false } = $props();\n  let counter = $state(count);\n\n  function increment() {\n    counter++;\n  }\n</script>\n\n<div>\n  <h1 data-testid=\"name-display\">Hello, {name}!</h1>\n  <p data-testid=\"count-display\">Count: {counter}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n\n  {#if showDetails}\n    <div data-testid=\"details\">\n      <p>Name is {name}</p>\n      <p>Count is {counter}</p>\n      <p>ShowDetails is {showDetails}</p>\n    </div>\n  {/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let { name = \"World\", count = 0, showDetails = false } = $props();\n  \n  // Make count reactive with $state\n  count = $state(count);\n  \n  function increment() {\n    count += 1;\n  }\n</script>\n\n<div>\n  <h1 data-testid=\"name-display\">Hello, {name}!</h1>\n  <p data-testid=\"count-display\">Count: {count}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n\n  {#if showDetails}\n    <div data-testid=\"details\">\n      <p>Name is {name}</p>\n      <p>Count is {count}</p>\n      <p>ShowDetails is {showDetails}</p>\n    </div>\n  {/if}\n</div>",
        "success": false,
        "errors": [
          "tmp/anthropic/Component.svelte:7:10 `$state(...)` can only be used as a variable declaration initializer or a class field\nhttps://svelte.dev/e/state_invalid_placement"
        ],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let { name = \"World\", count = 0, showDetails = false } = $props();\n  \n  let counter = $state(count);\n  \n  function increment() {\n    counter++;\n  }\n</script>\n\n<div>\n  <h1 data-testid=\"name-display\">Hello, {name}!</h1>\n  <p data-testid=\"count-display\">Count: {counter}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n\n  {#if showDetails}\n    <div data-testid=\"details\">\n      <p>Name is {name}</p>\n      <p>Count is {counter}</p>\n      <p>ShowDetails is {showDetails}</p>\n    </div>\n  {/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let { name = \"World\", count = 0, showDetails = false } = $props();\n  \n  // Create a reactive state variable initialized with the count prop value\n  let counter = $state(count);\n  \n  function increment() {\n    counter += 1;\n  }\n</script>\n\n<div>\n  <h1 data-testid=\"name-display\">Hello, {name}!</h1>\n  <p data-testid=\"count-display\">Count: {counter}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n\n  {#if showDetails}\n    <div data-testid=\"details\">\n      <p>Name is {name}</p>\n      <p>Count is {counter}</p>\n      <p>ShowDetails is {showDetails}</p>\n    </div>\n  {/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let { name = \"World\", count = 0, showDetails = false } = $props();\n  \n  let counter = $state(count);\n  \n  function increment() {\n    counter++;\n  }\n</script>\n\n<div>\n  <h1 data-testid=\"name-display\">Hello, {name}!</h1>\n  <p data-testid=\"count-display\">Count: {counter}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n\n  {#if showDetails}\n    <div data-testid=\"details\">\n      <p>Name is {name}</p>\n      <p>Count is {counter}</p>\n      <p>ShowDetails is {showDetails}</p>\n    </div>\n  {/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  },
  {
    "testName": "snippets",
    "provider": "Anthropic",
    "modelId": "claude-3-7-sonnet-20250219",
    "numSamples": 10,
    "numCorrect": 6,
    "pass1": 0.5999999999999999,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let books = $state([\"The Lord of the Rings\", \"To Kill a Mockingbird\", \"1984\"]);\n</script>\n\n<ul>\n  {#each books as book}\n    <li data-testid=\"book-item\">\n      {@render title(book)}\n    </li>\n  {/each}\n</ul>\n\n{#snippet title(bookTitle)}\n  <span data-testid=\"book-title\">{bookTitle}</span>\n{/snippet}",
        "success": true,
        "errors": [],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let books = $state([\"The Lord of the Rings\", \"To Kill a Mockingbird\", \"1984\"]);\n  \n  {#snippet title(bookTitle)}\n    <span data-testid=\"book-title\">{bookTitle}</span>\n  {/snippet}\n</script>\n\n<ul>\n  {#each books as book}\n    <li data-testid=\"book-item\">\n      {@render title(book)}\n    </li>\n  {/each}\n</ul>",
        "success": false,
        "errors": [
          "tmp/anthropic/Component.svelte:6:3 Unexpected token\nhttps://svelte.dev/e/js_parse_error"
        ],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let books = $state([\"The Lord of the Rings\", \"To Kill a Mockingbird\", \"1984\"]);\n</script>\n\n{#snippet title(bookTitle)}\n  <span data-testid=\"book-title\">{bookTitle}</span>\n{/snippet}\n\n<ul>\n  {#each books as book}\n    <li data-testid=\"book-item\">{@render title(book)}</li>\n  {/each}\n</ul>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<script>\n  const books = $state([\"The Lord of the Rings\", \"To Kill a Mockingbird\", \"1984\"]);\n\n  {#snippet title(bookTitle)}\n    <span data-testid=\"book-title\">{bookTitle}</span>\n  {/snippet}\n</script>\n\n<ul>\n  {#each books as book}\n    <li data-testid=\"book-item\">{@render title(book)}</li>\n  {/each}\n</ul>",
        "success": false,
        "errors": [
          "tmp/anthropic/Component.svelte:6:3 Unexpected token\nhttps://svelte.dev/e/js_parse_error"
        ],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let books = $state([\"The Lord of the Rings\", \"To Kill a Mockingbird\", \"1984\"]);\n  \n  {#snippet title(bookTitle)}\n    <span data-testid=\"book-title\">{bookTitle}</span>\n  {/snippet}\n</script>\n\n<ul>\n  {#each books as book}\n    <li data-testid=\"book-item\">{@render title(book)}</li>\n  {/each}\n</ul>",
        "success": false,
        "errors": [
          "tmp/anthropic/Component.svelte:6:3 Unexpected token\nhttps://svelte.dev/e/js_parse_error"
        ],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let books = $state([\"The Lord of the Rings\", \"To Kill a Mockingbird\", \"1984\"]);\n  \n  {#snippet title(bookTitle)}\n    <span data-testid=\"book-title\">{bookTitle}</span>\n  {/snippet}\n</script>\n\n<ul>\n  {#each books as book}\n    <li data-testid=\"book-item\">\n      {@render title(book)}\n    </li>\n  {/each}\n</ul>",
        "success": false,
        "errors": [
          "tmp/anthropic/Component.svelte:6:3 Unexpected token\nhttps://svelte.dev/e/js_parse_error"
        ],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let books = $state([\"The Lord of the Rings\", \"To Kill a Mockingbird\", \"1984\"]);\n</script>\n\n<ul>\n  {#each books as book}\n    <li data-testid=\"book-item\">\n      {@render title(book)}\n    </li>\n  {/each}\n</ul>\n\n{#snippet title(bookTitle)}\n  <span data-testid=\"book-title\">{bookTitle}</span>\n{/snippet}",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let books = $state([\"The Lord of the Rings\", \"To Kill a Mockingbird\", \"1984\"]);\n</script>\n\n<ul>\n  {#each books as book}\n    <li data-testid=\"book-item\">\n      {@render title(book)}\n    </li>\n  {/each}\n</ul>\n\n{#snippet title(bookTitle)}\n  <span data-testid=\"book-title\">{bookTitle}</span>\n{/snippet}",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<script>\n  const books = $state([\"The Lord of the Rings\", \"To Kill a Mockingbird\", \"1984\"]);\n</script>\n\n{#snippet title(bookTitle)}\n  <span data-testid=\"book-title\">{bookTitle}</span>\n{/snippet}\n\n<ul>\n  {#each books as book}\n    <li data-testid=\"book-item\">{@render title(book)}</li>\n  {/each}\n</ul>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let books = $state([\"The Lord of the Rings\", \"To Kill a Mockingbird\", \"1984\"]);\n</script>\n\n<ul>\n  {#each books as book}\n    <li data-testid=\"book-item\">\n      {@render title(book)}\n    </li>\n  {/each}\n</ul>\n\n{#snippet title(bookTitle)}\n  <span data-testid=\"book-title\">{bookTitle}</span>\n{/snippet}",
        "success": true,
        "errors": [],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  },
  {
    "testName": "counter",
    "provider": "Anthropic",
    "modelId": "claude-3-5-haiku-20241022",
    "numSamples": 10,
    "numCorrect": 10,
    "pass1": 1,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let count = $state(0);\n</script>\n\n<div class=\"counter\">\n  <button \n    data-testid=\"decrement-button\" \n    onclick={() => count--}\n  >\n    -\n  </button>\n  <span data-testid=\"count-value\">{count}</span>\n  <button \n    data-testid=\"increment-button\" \n    onclick={() => count++}\n  >\n    +\n  </button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let count = $state(0);\n</script>\n\n<div class=\"counter\">\n  <button data-testid=\"decrement-button\" onclick={() => count--}>-</button>\n  <span data-testid=\"count-value\">{count}</span>\n  <button data-testid=\"increment-button\" onclick={() => count++}>+</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let count = $state(0);\n</script>\n\n<div class=\"counter\">\n  <button \n    data-testid=\"decrement-button\" \n    onclick={() => count--}\n  >\n    -\n  </button>\n  <span data-testid=\"count-value\">{count}</span>\n  <button \n    data-testid=\"increment-button\" \n    onclick={() => count++}\n  >\n    +\n  </button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let count = $state(0);\n</script>\n\n<div class=\"counter\">\n  <button \n    data-testid=\"decrement-button\"\n    onclick={() => count--}\n  >\n    -\n  </button>\n  <span data-testid=\"count-value\">{count}</span>\n  <button \n    data-testid=\"increment-button\"\n    onclick={() => count++}\n  >\n    +\n  </button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<script>\n    let count = $state(0);\n</script>\n\n<div class=\"counter\">\n    <button data-testid=\"decrement-button\" onclick={() => count--}>-</button>\n    <span data-testid=\"count-value\">{count}</span>\n    <button data-testid=\"increment-button\" onclick={() => count++}>+</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let count = $state(0);\n</script>\n\n<div class=\"counter\">\n  <button data-testid=\"decrement-button\" onclick={() => count--}>-</button>\n  <span data-testid=\"count-value\">{count}</span>\n  <button data-testid=\"increment-button\" onclick={() => count++}>+</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<script>\n    let count = $state(0);\n</script>\n\n<div class=\"counter\">\n    <button data-testid=\"decrement-button\" onclick={() => count--}>-</button>\n    <span data-testid=\"count-value\">{count}</span>\n    <button data-testid=\"increment-button\" onclick={() => count++}>+</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let count = $state(0);\n</script>\n\n<div class=\"counter\">\n  <button \n    data-testid=\"decrement-button\" \n    onclick={() => count--}\n  >\n    -\n  </button>\n  <span data-testid=\"count-value\">{count}</span>\n  <button \n    data-testid=\"increment-button\" \n    onclick={() => count++}\n  >\n    +\n  </button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<script>\n    let count = $state(0);\n</script>\n\n<div class=\"counter\">\n    <button data-testid=\"decrement-button\" onclick={() => count--}>-</button>\n    <span data-testid=\"count-value\">{count}</span>\n    <button data-testid=\"increment-button\" onclick={() => count++}>+</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let count = $state(0);\n</script>\n\n<div class=\"counter\">\n  <button data-testid=\"decrement-button\" onclick={() => count--}>-</button>\n  <span data-testid=\"count-value\">{count}</span>\n  <button data-testid=\"increment-button\" onclick={() => count++}>+</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  },
  {
    "testName": "derived",
    "provider": "Anthropic",
    "modelId": "claude-3-5-haiku-20241022",
    "numSamples": 10,
    "numCorrect": 10,
    "pass1": 1,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  const doubled = $derived(number * 2);\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number += 1}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  const doubled = $derived(number * 2);\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number += 1}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  const doubled = $derived(number * 2);\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number += 1}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<script>\n    let number = $state(5);\n    const doubled = $derived(number * 2);\n</script>\n\n<div>\n    <p data-testid=\"number-value\">Number: {number}</p>\n    <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n    <button data-testid=\"increment-button\" onclick={() => number += 1}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<script>\n    let number = $state(5);\n    const doubled = $derived(number * 2);\n</script>\n\n<div>\n    <p data-testid=\"number-value\">Number: {number}</p>\n    <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n    <button data-testid=\"increment-button\" onclick={() => number += 1}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  const doubled = $derived(number * 2);\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number += 1}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet number = $state(5);\n\tconst doubled = $derived(number * 2);\n</script>\n\n<div>\n\t<p data-testid=\"number-value\">Number: {number}</p>\n\t<p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n\t<button data-testid=\"increment-button\" onclick={() => number += 1}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  const doubled = $derived(number * 2);\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number += 1}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<script>\n    let number = $state(5);\n    const doubled = $derived(number * 2);\n</script>\n\n<div>\n    <p data-testid=\"number-value\">Number: {number}</p>\n    <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n    <button data-testid=\"increment-button\" onclick={() => number += 1}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  const doubled = $derived(number * 2);\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number += 1}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  },
  {
    "testName": "derived-by",
    "provider": "Anthropic",
    "modelId": "claude-3-5-haiku-20241022",
    "numSamples": 10,
    "numCorrect": 10,
    "pass1": 1,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('');\n\n  const wordCount = $derived.by(() => {\n    return text.trim().split(/\\s+/).filter(word => word.length > 0).length;\n  });\n\n  const charCount = $derived.by(() => {\n    return text.length;\n  });\n\n  const isLongText = $derived.by(() => {\n    return wordCount > 15;\n  });\n\n  function clearText() {\n    text = '';\n  }\n</script>\n\n<div>\n  <input \n    data-testid=\"text-input\" \n    type=\"text\" \n    bind:value={text} \n  />\n  <button \n    data-testid=\"clear-button\"\n    onclick={clearText}\n  >\n    Clear\n  </button>\n  <div>\n    <p data-testid=\"word-count\">Words: {wordCount}</p>\n    <p data-testid=\"char-count\">Characters: {charCount}</p>\n    <p data-testid=\"length-indicator\">\n      Status: {isLongText ? 'Long text' : 'Short text'}\n    </p>\n  </div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('');\n\n  const wordCount = $derived.by(() => {\n    return text.trim().split(/\\s+/).filter(word => word.length > 0).length;\n  });\n\n  const charCount = $derived.by(() => {\n    return text.length;\n  });\n\n  const isLongText = $derived.by(() => {\n    return wordCount > 15;\n  });\n\n  function clearText() {\n    text = '';\n  }\n</script>\n\n<div>\n  <input \n    data-testid=\"text-input\" \n    type=\"text\" \n    bind:value={text} \n  />\n  <button \n    data-testid=\"clear-button\"\n    onclick={clearText}\n  >\n    Clear\n  </button>\n  <div>\n    <p data-testid=\"word-count\">Words: {wordCount}</p>\n    <p data-testid=\"char-count\">Characters: {charCount}</p>\n    <p data-testid=\"length-indicator\">\n      Status: {isLongText ? 'Long text' : 'Short text'}\n    </p>\n  </div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('');\n\n  const wordCount = $derived.by(() => {\n    return text.trim() === '' ? 0 : text.trim().split(/\\s+/).length;\n  });\n\n  const charCount = $derived.by(() => {\n    return text.length;\n  });\n\n  const isLongText = $derived.by(() => {\n    return wordCount > 15;\n  });\n\n  function clearText() {\n    text = '';\n  }\n</script>\n\n<div>\n  <input \n    data-testid=\"text-input\" \n    type=\"text\" \n    bind:value={text} \n  />\n  <button \n    data-testid=\"clear-button\"\n    onclick={clearText}\n  >\n    Clear\n  </button>\n  <div>\n    <p data-testid=\"word-count\">Words: {wordCount}</p>\n    <p data-testid=\"char-count\">Characters: {charCount}</p>\n    <p data-testid=\"length-indicator\">\n      Status: {isLongText ? 'Long text' : 'Short text'}\n    </p>\n  </div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('');\n\n  const stats = $derived.by(() => {\n    const trimmedText = text.trim();\n    const words = trimmedText ? trimmedText.split(/\\s+/) : [];\n    return {\n      wordCount: words.length,\n      charCount: text.length,\n      isLong: words.length > 15\n    };\n  });\n\n  function clearText() {\n    text = '';\n  }\n</script>\n\n<div>\n  <input \n    data-testid=\"text-input\" \n    type=\"text\" \n    bind:value={text} \n  />\n  <button \n    data-testid=\"clear-button\"\n    onclick={clearText}\n  >\n    Clear\n  </button>\n  <div>\n    <p data-testid=\"word-count\">Words: {stats.wordCount}</p>\n    <p data-testid=\"char-count\">Characters: {stats.charCount}</p>\n    <p data-testid=\"length-indicator\">\n      Status: {stats.isLong ? 'Long text' : 'Short text'}\n    </p>\n  </div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('');\n\n  const wordCount = $derived.by(() => {\n    return text.trim().split(/\\s+/).filter(word => word.length > 0).length;\n  });\n\n  const charCount = $derived.by(() => {\n    return text.length;\n  });\n\n  const isLongText = $derived.by(() => {\n    return wordCount > 15;\n  });\n\n  function clearText() {\n    text = '';\n  }\n</script>\n\n<div>\n  <input \n    data-testid=\"text-input\" \n    type=\"text\" \n    bind:value={text} \n  />\n  <button \n    data-testid=\"clear-button\"\n    onclick={clearText}\n  >\n    Clear\n  </button>\n  <div>\n    <p data-testid=\"word-count\">Words: {wordCount}</p>\n    <p data-testid=\"char-count\">Characters: {charCount}</p>\n    <p data-testid=\"length-indicator\">\n      Status: {isLongText ? 'Long text' : 'Short text'}\n    </p>\n  </div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('');\n\n  const wordCount = $derived.by(() => {\n    return text.trim().split(/\\s+/).filter(word => word.length > 0).length;\n  });\n\n  const charCount = $derived.by(() => {\n    return text.length;\n  });\n\n  const isLongText = $derived.by(() => {\n    return wordCount > 15;\n  });\n\n  function clearText() {\n    text = '';\n  }\n</script>\n\n<div>\n  <input \n    data-testid=\"text-input\" \n    type=\"text\" \n    bind:value={text} \n  />\n  <button \n    data-testid=\"clear-button\"\n    onclick={clearText}\n  >\n    Clear\n  </button>\n  <div>\n    <p data-testid=\"word-count\">Words: {wordCount}</p>\n    <p data-testid=\"char-count\">Characters: {charCount}</p>\n    <p data-testid=\"length-indicator\">\n      Status: {isLongText ? 'Long text' : 'Short text'}\n    </p>\n  </div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('');\n  \n  const textStats = $derived.by(() => {\n    const words = text.trim().split(/\\s+/).filter(word => word.length > 0);\n    const chars = text.length;\n    const isLong = words.length > 15;\n    \n    return {\n      wordCount: words.length,\n      charCount: chars,\n      isLong\n    };\n  });\n\n  function clearText() {\n    text = '';\n  }\n</script>\n\n<div>\n  <input \n    data-testid=\"text-input\" \n    type=\"text\" \n    bind:value={text} \n  />\n  <button \n    data-testid=\"clear-button\"\n    onclick={clearText}\n  >\n    Clear\n  </button>\n  <div>\n    <p data-testid=\"word-count\">Words: {textStats.wordCount}</p>\n    <p data-testid=\"char-count\">Characters: {textStats.charCount}</p>\n    <p data-testid=\"length-indicator\">\n      Status: {textStats.isLong ? 'Long text' : 'Short text'}\n    </p>\n  </div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('');\n\n  const wordCount = $derived.by(() => {\n    return text.trim().split(/\\s+/).filter(word => word.length > 0).length;\n  });\n\n  const charCount = $derived.by(() => {\n    return text.length;\n  });\n\n  const isLongText = $derived.by(() => {\n    return wordCount > 15;\n  });\n\n  function clearText() {\n    text = '';\n  }\n</script>\n\n<div>\n  <input \n    data-testid=\"text-input\" \n    type=\"text\" \n    bind:value={text} \n  />\n  <button \n    data-testid=\"clear-button\"\n    onclick={clearText}\n  >\n    Clear\n  </button>\n  <div>\n    <p data-testid=\"word-count\">Words: {wordCount}</p>\n    <p data-testid=\"char-count\">Characters: {charCount}</p>\n    <p data-testid=\"length-indicator\">\n      Status: {isLongText ? 'Long text' : 'Short text'}\n    </p>\n  </div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('');\n\n  const wordCount = $derived.by(() => {\n    return text.trim().split(/\\s+/).filter(word => word.length > 0).length;\n  });\n\n  const charCount = $derived.by(() => {\n    return text.length;\n  });\n\n  const isLongText = $derived.by(() => {\n    return wordCount > 15;\n  });\n\n  function clearText() {\n    text = '';\n  }\n</script>\n\n<div>\n  <input \n    data-testid=\"text-input\" \n    type=\"text\" \n    bind:value={text} \n  />\n  <button \n    data-testid=\"clear-button\"\n    onclick={clearText}\n  >\n    Clear\n  </button>\n  <div>\n    <p data-testid=\"word-count\">Words: {wordCount}</p>\n    <p data-testid=\"char-count\">Characters: {charCount}</p>\n    <p data-testid=\"length-indicator\">\n      Status: {isLongText ? 'Long text' : 'Short text'}\n    </p>\n  </div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('');\n\n  const wordCount = $derived.by(() => {\n    return text.trim().split(/\\s+/).filter(word => word.length > 0).length;\n  });\n\n  const charCount = $derived.by(() => {\n    return text.length;\n  });\n\n  const isLongText = $derived.by(() => {\n    return wordCount > 15;\n  });\n\n  function clearText() {\n    text = '';\n  }\n</script>\n\n<div>\n  <input \n    data-testid=\"text-input\" \n    type=\"text\" \n    bind:value={text} \n  />\n  <button \n    data-testid=\"clear-button\"\n    onclick={clearText}\n  >\n    Clear\n  </button>\n  <div>\n    <p data-testid=\"word-count\">Words: {wordCount}</p>\n    <p data-testid=\"char-count\">Characters: {charCount}</p>\n    <p data-testid=\"length-indicator\">\n      Status: {isLongText ? 'Long text' : 'Short text'}\n    </p>\n  </div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  },
  {
    "testName": "each",
    "provider": "Anthropic",
    "modelId": "claude-3-5-haiku-20241022",
    "numSamples": 10,
    "numCorrect": 10,
    "pass1": 1,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let characters = $state([\"Jerry\", \"Elaine\", \"Kramer\"]);\n\n  function addGeorge() {\n    if (!characters.includes(\"George\")) {\n      characters.push(\"George\");\n    }\n  }\n</script>\n\n<div>\n  <ul data-testid=\"characters-list\">\n    {#each characters as character}\n      <li data-testid=\"character\">{character}</li>\n    {/each}\n  </ul>\n  <button data-testid=\"add-george-button\" onclick={addGeorge}>Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let characters = $state([\"Jerry\", \"Elaine\", \"Kramer\"]);\n\n  function addGeorge() {\n    if (!characters.includes(\"George\")) {\n      characters.push(\"George\");\n    }\n  }\n</script>\n\n<div>\n  <ul data-testid=\"characters-list\">\n    {#each characters as character}\n      <li data-testid=\"character\">{character}</li>\n    {/each}\n  </ul>\n  <button data-testid=\"add-george-button\" onclick={addGeorge}>Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<script>\n    let characters = $state([\"Jerry\", \"Elaine\", \"Kramer\"]);\n\n    function addGeorge() {\n        if (!characters.includes(\"George\")) {\n            characters.push(\"George\");\n        }\n    }\n</script>\n\n<div>\n    <ul data-testid=\"characters-list\">\n        {#each characters as character}\n            <li data-testid=\"character\">{character}</li>\n        {/each}\n    </ul>\n    <button data-testid=\"add-george-button\" onclick={addGeorge}>Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let characters = $state(['Jerry', 'Elaine', 'Kramer']);\n\n  function addGeorge() {\n    if (!characters.includes('George')) {\n      characters = [...characters, 'George'];\n    }\n  }\n</script>\n\n<div>\n  <ul data-testid=\"characters-list\">\n    {#each characters as character}\n      <li data-testid=\"character\">{character}</li>\n    {/each}\n  </ul>\n  <button data-testid=\"add-george-button\" onclick={addGeorge}>Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let characters = $state([\"Jerry\", \"Elaine\", \"Kramer\"]);\n\n  function addGeorge() {\n    if (!characters.includes(\"George\")) {\n      characters.push(\"George\");\n    }\n  }\n</script>\n\n<div>\n  <ul data-testid=\"characters-list\">\n    {#each characters as character}\n      <li data-testid=\"character\">{character}</li>\n    {/each}\n  </ul>\n  <button data-testid=\"add-george-button\" onclick={addGeorge}>Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let characters = $state(['Jerry', 'Elaine', 'Kramer']);\n  \n  function addGeorge() {\n    if (!characters.includes('George')) {\n      characters.push('George');\n    }\n  }\n</script>\n\n<div>\n  <ul data-testid=\"characters-list\">\n    {#each characters as character}\n      <li data-testid=\"character\">{character}</li>\n    {/each}\n  </ul>\n  <button data-testid=\"add-george-button\" onclick={addGeorge}>Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let characters = $state(['Jerry', 'Elaine', 'Kramer']);\n\n  function addGeorge() {\n    if (!characters.includes('George')) {\n      characters.push('George');\n    }\n  }\n</script>\n\n<div>\n  <ul data-testid=\"characters-list\">\n    {#each characters as character}\n      <li data-testid=\"character\">{character}</li>\n    {/each}\n  </ul>\n  <button data-testid=\"add-george-button\" onclick={addGeorge}>Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let characters = $state(['Jerry', 'Elaine', 'Kramer']);\n\n  function addGeorge() {\n    if (!characters.includes('George')) {\n      characters = [...characters, 'George'];\n    }\n  }\n</script>\n\n<div>\n  <ul data-testid=\"characters-list\">\n    {#each characters as character}\n      <li data-testid=\"character\">{character}</li>\n    {/each}\n  </ul>\n  <button data-testid=\"add-george-button\" onclick={addGeorge}>Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let characters = $state([\"Jerry\", \"Elaine\", \"Kramer\"]);\n\n  function addGeorge() {\n    if (!characters.includes(\"George\")) {\n      characters.push(\"George\");\n    }\n  }\n</script>\n\n<div>\n  <ul data-testid=\"characters-list\">\n    {#each characters as character}\n      <li data-testid=\"character\">{character}</li>\n    {/each}\n  </ul>\n  <button data-testid=\"add-george-button\" onclick={addGeorge}>Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let characters = $state([\"Jerry\", \"Elaine\", \"Kramer\"]);\n\n  function addGeorge() {\n    characters.push(\"George\");\n  }\n</script>\n\n<div>\n  <ul data-testid=\"characters-list\">\n    {#each characters as character}\n      <li data-testid=\"character\">{character}</li>\n    {/each}\n  </ul>\n  <button data-testid=\"add-george-button\" onclick={addGeorge}>Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  },
  {
    "testName": "effect",
    "provider": "Anthropic",
    "modelId": "claude-3-5-haiku-20241022",
    "numSamples": 10,
    "numCorrect": 10,
    "pass1": 1,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n    let number = $state(5);\n    let doubled = $derived(number * 2);\n</script>\n\n<div>\n    <p data-testid=\"number-value\">Number: {number}</p>\n    <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n    <button data-testid=\"increment-button\" onclick={() => number += 1}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  const doubled = $derived(number * 2);\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number += 1}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $derived(number * 2);\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number += 1}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $derived(number * 2);\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number += 1}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  const doubled = $derived(number * 2);\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number += 1}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $derived(number * 2);\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number += 1}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<script>\n    let number = $state(5);\n    let doubled = $derived(number * 2);\n</script>\n\n<div>\n    <p data-testid=\"number-value\">Number: {number}</p>\n    <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n    <button data-testid=\"increment-button\" onclick={() => number += 1}>\n        Increment\n    </button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<script>\n    let number = $state(5);\n    let doubled = $derived(number * 2);\n</script>\n\n<div>\n    <p data-testid=\"number-value\">Number: {number}</p>\n    <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n    <button data-testid=\"increment-button\" onclick={() => number += 1}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  const doubled = $derived(number * 2);\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number += 1}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  const doubled = $derived(number * 2);\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number += 1}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  },
  {
    "testName": "hello-world",
    "provider": "Anthropic",
    "modelId": "claude-3-5-haiku-20241022",
    "numSamples": 10,
    "numCorrect": 9,
    "pass1": 0.9,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let greeting = $state('Hello, World!');\n</script>\n\n<div data-testid=\"greeting\" class=\"greeting\">{greeting}</div>\n\n<style>\n  .greeting {\n    color: blue;\n    text-align: center;\n    margin: 20px;\n    font-size: 24px;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<script>\n</script>\n\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>\n\n<style>\n    .greeting {\n        color: blue;\n        text-align: center;\n        margin: 20px;\n    }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet greeting = $state('Hello, World!');\n</script>\n\n<style>\n\t.greeting {\n\t\tcolor: blue;\n\t\ttext-align: center;\n\t\tmargin: 20px;\n\t\tfont-size: 24px;\n\t}\n</style>\n\n<div data-testid=\"greeting\" class=\"greeting\">{greeting}</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<script>\nlet message = $state('Hello, World!');\n</script>\n\n<div data-testid=\"greeting\" class=\"greeting\">{message}</div>\n\n<style>\n.greeting {\n    color: blue;\n    text-align: center;\n    margin: 20px;\n}\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<script>\n  const greeting = $state('Hello, World!');\n</script>\n\n<div data-testid=\"greeting\" class=\"greeting\">{greeting}</div>\n\n<style>\n  .greeting {\n    color: blue;\n    text-align: center;\n    margin: 20px;\n    font-size: 24px;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<script>\n  import './hello-world.css';\n</script>\n\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>\n\n<style>\n  .greeting {\n    color: blue;\n    text-align: center;\n    margin: 20px;\n    font-size: 24px;\n  }\n</style>",
        "success": false,
        "errors": [
          "Failed to resolve import \"./hello-world.css\" from \"tmp/anthropic/Component.svelte\". Does the file exist?"
        ],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet message = $state('Hello, World!');\n</script>\n\n<style>\n\t.greeting {\n\t\tcolor: blue;\n\t\ttext-align: center;\n\t\tmargin: 20px;\n\t\tfont-size: 24px;\n\t}\n</style>\n\n<div data-testid=\"greeting\" class=\"greeting\">{message}</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<script>\n    let message = $state('Hello, World!');\n</script>\n\n<div data-testid=\"greeting\" class=\"greeting\">{message}</div>\n\n<style>\n    .greeting {\n        color: blue;\n        text-align: center;\n        margin: 20px;\n        font-size: 24px;\n    }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<script>\n</script>\n\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>\n\n<style>\n    .greeting {\n        color: blue;\n        text-align: center;\n        margin: 20px;\n    }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<script>\n  const greeting = $state('Hello, World!');\n</script>\n\n<div \n  data-testid=\"greeting\" \n  class=\"greeting\"\n>\n  {greeting}\n</div>\n\n<style>\n  .greeting {\n    color: blue;\n    text-align: center;\n    margin: 20px;\n    font-size: 24px;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  },
  {
    "testName": "inspect",
    "provider": "Anthropic",
    "modelId": "claude-3-5-haiku-20241022",
    "numSamples": 10,
    "numCorrect": 0,
    "pass1": 0,
    "pass10": 0,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('Hello world');\n\n  $inspect(text);\n\n  $inspect(text).with((value) => {\n    console.log('Custom tracking:', value);\n  });\n\n  $effect(() => {\n    $inspect.trace(text);\n  });\n\n  const charCount = $derived(text.length);\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <p data-testid=\"text-value\">Current text: {text}</p>\n  <p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"Hello world\"\u001b[39m\nReceived:\n\u001b[31m  Current text: Hello world\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"Testing $inspect\"\u001b[39m\nReceived:\n\u001b[31m  Current text: Testing $inspect\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"!@#$%^&*()\"\u001b[39m\nReceived:\n\u001b[31m  Current text: !@#$%^&*()\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"\"\u001b[39m\nReceived:\n\u001b[31m  Current text:\u001b[39m"
        ],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('Hello world');\n\n  $inspect(text).with((value) => {\n    console.log('Input updated:', value);\n  });\n\n  $inspect.trace(text, () => {\n    console.trace('Text input trace');\n  });\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <p data-testid=\"text-value\">Current text: {text}</p>\n  <p data-testid=\"char-count\">Character count: {text.length}</p>\n</div>",
        "success": false,
        "errors": [
          "tmp/anthropic/Component.svelte:10:2 `$inspect.trace` must be called with zero or one arguments\nhttps://svelte.dev/e/rune_invalid_arguments_length"
        ],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('Hello world');\n\n  $inspect(text);\n\n  $inspect(text).with((value) => {\n    console.log('Text updated:', value);\n  });\n\n  $effect(() => {\n    $inspect.trace(text);\n  });\n\n  const charCount = $derived(text.length);\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <p data-testid=\"text-value\">Current text: {text}</p>\n  <p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"Hello world\"\u001b[39m\nReceived:\n\u001b[31m  Current text: Hello world\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"Testing $inspect\"\u001b[39m\nReceived:\n\u001b[31m  Current text: Testing $inspect\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"!@#$%^&*()\"\u001b[39m\nReceived:\n\u001b[31m  Current text: !@#$%^&*()\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"\"\u001b[39m\nReceived:\n\u001b[31m  Current text:\u001b[39m"
        ],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('Hello world');\n\n  $inspect(text);\n  \n  $inspect(text).with((value) => {\n    console.log('Value updated to:', value);\n  });\n\n  $effect(() => {\n    $inspect.trace(text);\n  });\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <p data-testid=\"text-value\">Current text: {text}</p>\n  <p data-testid=\"char-count\">Character count: {text.length}</p>\n</div>",
        "success": false,
        "errors": [
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"Hello world\"\u001b[39m\nReceived:\n\u001b[31m  Current text: Hello world\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"Testing $inspect\"\u001b[39m\nReceived:\n\u001b[31m  Current text: Testing $inspect\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"!@#$%^&*()\"\u001b[39m\nReceived:\n\u001b[31m  Current text: !@#$%^&*()\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"\"\u001b[39m\nReceived:\n\u001b[31m  Current text:\u001b[39m"
        ],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('Hello world');\n\n  $inspect(text);\n\n  $inspect(text).with((value) => {\n    console.log('Value updated:', value);\n  });\n\n  $effect(() => {\n    $inspect.trace(text);\n  });\n\n  const charCount = $derived(text.length);\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <p data-testid=\"text-value\">Current text: {text}</p>\n  <p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"Hello world\"\u001b[39m\nReceived:\n\u001b[31m  Current text: Hello world\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"Testing $inspect\"\u001b[39m\nReceived:\n\u001b[31m  Current text: Testing $inspect\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"!@#$%^&*()\"\u001b[39m\nReceived:\n\u001b[31m  Current text: !@#$%^&*()\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"\"\u001b[39m\nReceived:\n\u001b[31m  Current text:\u001b[39m"
        ],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('Hello world');\n\n  $inspect(text);\n\n  $inspect(text).with((value, prev) => {\n    console.log(Text changed from \"${prev}\" to \"${value}\");\n  });\n\n  $effect(() => {\n    $inspect.trace(text);\n  });\n\n  const charCount = $derived(text.length);\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <p data-testid=\"text-value\">Current text: {text}</p>\n  <p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "tmp/anthropic/Component.svelte:9:21 Unexpected token\nhttps://svelte.dev/e/js_parse_error"
        ],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('Hello world');\n\n  $inspect(text);\n\n  $inspect(text).with((value, previous) => {\n    console.log(Text changed from \"${previous}\" to \"${value}\");\n  });\n\n  $effect(() => {\n    $inspect.trace(text);\n  });\n\n  const charCount = $derived(text.length);\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <p data-testid=\"text-value\">Current text: {text}</p>\n  <p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "tmp/anthropic/Component.svelte:9:21 Unexpected token\nhttps://svelte.dev/e/js_parse_error"
        ],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('Hello world');\n\n  $inspect(text);\n\n  $inspect(text).with((value) => {\n    console.log('Text updated with:', value);\n  });\n\n  $effect(() => {\n    $inspect.trace(text);\n  });\n\n  const charCount = $derived(text.length);\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <p data-testid=\"text-value\">Current text: {text}</p>\n  <p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"Hello world\"\u001b[39m\nReceived:\n\u001b[31m  Current text: Hello world\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"Testing $inspect\"\u001b[39m\nReceived:\n\u001b[31m  Current text: Testing $inspect\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"!@#$%^&*()\"\u001b[39m\nReceived:\n\u001b[31m  Current text: !@#$%^&*()\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"\"\u001b[39m\nReceived:\n\u001b[31m  Current text:\u001b[39m"
        ],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('Hello world');\n\n  $inspect(text);\n\n  $inspect(text).with((value) => {\n    console.log('Text updated:', value);\n  });\n\n  $effect(() => {\n    $inspect.trace(text);\n  });\n\n  let charCount = $derived(text.length);\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <p data-testid=\"text-value\">Current text: {text}</p>\n  <p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"Hello world\"\u001b[39m\nReceived:\n\u001b[31m  Current text: Hello world\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"Testing $inspect\"\u001b[39m\nReceived:\n\u001b[31m  Current text: Testing $inspect\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"!@#$%^&*()\"\u001b[39m\nReceived:\n\u001b[31m  Current text: !@#$%^&*()\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"\"\u001b[39m\nReceived:\n\u001b[31m  Current text:\u001b[39m"
        ],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('Hello world');\n\n  $inspect(text);\n\n  $inspect(text).with((current, previous) => {\n    console.log(Changed from ${previous} to ${current});\n  });\n\n  $effect(() => {\n    $inspect.trace(text);\n  });\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <p data-testid=\"text-value\">Current text: {text}</p>\n  <p data-testid=\"char-count\">Character count: {text.length}</p>\n</div>",
        "success": false,
        "errors": [
          "tmp/anthropic/Component.svelte:9:24 Unexpected token\nhttps://svelte.dev/e/js_parse_error"
        ],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  },
  {
    "testName": "props",
    "provider": "Anthropic",
    "modelId": "claude-3-5-haiku-20241022",
    "numSamples": 10,
    "numCorrect": 10,
    "pass1": 1,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let { \n    name = \"World\", \n    count = 0, \n    showDetails = false \n  } = $props();\n\n  let localCount = $state(count);\n\n  function incrementCount() {\n    localCount += 1;\n  }\n</script>\n\n<div>\n  <h1 data-testid=\"name-display\">Hello, {name}!</h1>\n  <p data-testid=\"count-display\">Count: {localCount}</p>\n  <button data-testid=\"increment-button\" onclick={incrementCount}>Increment</button>\n\n  {#if showDetails}\n    <div data-testid=\"details\">\n      <p>Name is {name}</p>\n      <p>Count is {localCount}</p>\n      <p>ShowDetails is {showDetails}</p>\n    </div>\n  {/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let { \n    name = \"World\", \n    count = 0, \n    showDetails = false \n  } = $props();\n\n  let localCount = $state(count);\n\n  function incrementCount() {\n    localCount += 1;\n  }\n</script>\n\n<div>\n  <h1 data-testid=\"name-display\">Hello, {name}!</h1>\n  <p data-testid=\"count-display\">Count: {localCount}</p>\n  <button data-testid=\"increment-button\" onclick={incrementCount}>Increment</button>\n\n  {#if showDetails}\n    <div data-testid=\"details\">\n      <p>Name is {name}</p>\n      <p>Count is {localCount}</p>\n      <p>ShowDetails is {showDetails}</p>\n    </div>\n  {/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let { \n    name = \"World\", \n    count = 0, \n    showDetails = false \n  } = $props();\n\n  let localCount = $state(count);\n\n  function incrementCount() {\n    localCount += 1;\n  }\n</script>\n\n<div>\n  <h1 data-testid=\"name-display\">Hello, {name}!</h1>\n  <p data-testid=\"count-display\">Count: {localCount}</p>\n  <button data-testid=\"increment-button\" onclick={incrementCount}>Increment</button>\n\n  {#if showDetails}\n    <div data-testid=\"details\">\n      <p>Name is {name}</p>\n      <p>Count is {localCount}</p>\n      <p>ShowDetails is {showDetails}</p>\n    </div>\n  {/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let { \n    name = \"World\", \n    count = 0, \n    showDetails = false \n  } = $props();\n\n  let localCount = $state(count);\n\n  function incrementCount() {\n    localCount += 1;\n  }\n</script>\n\n<div>\n  <h1 data-testid=\"name-display\">Hello, {name}!</h1>\n  <p data-testid=\"count-display\">Count: {localCount}</p>\n  <button data-testid=\"increment-button\" onclick={incrementCount}>Increment</button>\n\n  {#if showDetails}\n    <div data-testid=\"details\">\n      <p>Name is {name}</p>\n      <p>Count is {localCount}</p>\n      <p>ShowDetails is {showDetails}</p>\n    </div>\n  {/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let { \n    name = \"World\", \n    count = 0, \n    showDetails = false \n  } = $props();\n\n  let localCount = $state(count);\n\n  function incrementCount() {\n    localCount += 1;\n  }\n</script>\n\n<div>\n  <h1 data-testid=\"name-display\">Hello, {name}!</h1>\n  <p data-testid=\"count-display\">Count: {localCount}</p>\n  <button data-testid=\"increment-button\" onclick={incrementCount}>Increment</button>\n\n  {#if showDetails}\n    <div data-testid=\"details\">\n      <p>Name is {name}</p>\n      <p>Count is {localCount}</p>\n      <p>ShowDetails is true</p>\n    </div>\n  {/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let { \n    name = \"World\", \n    count = 0, \n    showDetails = false \n  } = $props();\n\n  let localCount = $state(count);\n\n  function incrementCount() {\n    localCount += 1;\n  }\n</script>\n\n<div>\n  <h1 data-testid=\"name-display\">Hello, {name}!</h1>\n  <p data-testid=\"count-display\">Count: {localCount}</p>\n  <button data-testid=\"increment-button\" onclick={incrementCount}>Increment</button>\n\n  {#if showDetails}\n    <div data-testid=\"details\">\n      <p>Name is {name}</p>\n      <p>Count is {localCount}</p>\n      <p>ShowDetails is {showDetails}</p>\n    </div>\n  {/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<script>\n    let { name = \"World\", count = 0, showDetails = false } = $props();\n    let localCount = $state(count);\n</script>\n\n<div>\n    <h1 data-testid=\"name-display\">Hello, {name}!</h1>\n    <p data-testid=\"count-display\">Count: {localCount}</p>\n    <button data-testid=\"increment-button\" onclick={() => localCount++}>Increment</button>\n\n    {#if showDetails}\n        <div data-testid=\"details\">\n            <p>Name is {name}</p>\n            <p>Count is {localCount}</p>\n            <p>ShowDetails is {showDetails}</p>\n        </div>\n    {/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let { \n    name = \"World\", \n    count = 0, \n    showDetails = false \n  } = $props();\n\n  let localCount = $state(count);\n\n  function incrementCount() {\n    localCount += 1;\n  }\n</script>\n\n<div>\n  <h1 data-testid=\"name-display\">Hello, {name}!</h1>\n  <p data-testid=\"count-display\">Count: {localCount}</p>\n  <button data-testid=\"increment-button\" onclick={incrementCount}>Increment</button>\n\n  {#if showDetails}\n    <div data-testid=\"details\">\n      <p>Name is {name}</p>\n      <p>Count is {localCount}</p>\n      <p>ShowDetails is {showDetails}</p>\n    </div>\n  {/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let { \n    name = \"World\", \n    count = 0, \n    showDetails = false \n  } = $props();\n\n  let localCount = $state(count);\n\n  function incrementCount() {\n    localCount += 1;\n  }\n</script>\n\n<div>\n  <h1 data-testid=\"name-display\">Hello, {name}!</h1>\n  <p data-testid=\"count-display\">Count: {localCount}</p>\n  <button data-testid=\"increment-button\" onclick={incrementCount}>Increment</button>\n\n  {#if showDetails}\n    <div data-testid=\"details\">\n      <p>Name is {name}</p>\n      <p>Count is {localCount}</p>\n      <p>ShowDetails is {showDetails}</p>\n    </div>\n  {/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let { \n    name = \"World\", \n    count = 0, \n    showDetails = false \n  } = $props();\n\n  let localCount = $state(count);\n\n  function incrementCount() {\n    localCount += 1;\n  }\n</script>\n\n<div>\n  <h1 data-testid=\"name-display\">Hello, {name}!</h1>\n  <p data-testid=\"count-display\">Count: {localCount}</p>\n  <button data-testid=\"increment-button\" onclick={incrementCount}>Increment</button>\n\n  {#if showDetails}\n    <div data-testid=\"details\">\n      <p>Name is {name}</p>\n      <p>Count is {localCount}</p>\n      <p>ShowDetails is {showDetails}</p>\n    </div>\n  {/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  },
  {
    "testName": "snippets",
    "provider": "Anthropic",
    "modelId": "claude-3-5-haiku-20241022",
    "numSamples": 10,
    "numCorrect": 0,
    "pass1": 0,
    "pass10": 0,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n  const books = [\n    'The Lord of the Rings', \n    'To Kill a Mockingbird', \n    '1984'\n  ];\n\n  {#snippet title(book)}\n    <span data-testid=\"book-title\">{book}</span>\n  {/snippet}\n</script>\n\n<ul>\n  {#each books as book}\n    <li data-testid=\"book-item\">\n      {@render title(book)}\n    </li>\n  {/each}\n</ul>",
        "success": false,
        "errors": [
          "tmp/anthropic/Component.svelte:10:3 Unexpected token\nhttps://svelte.dev/e/js_parse_error"
        ],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<script>\n  const books = ['The Lord of the Rings', 'To Kill a Mockingbird', '1984'];\n\n  {#snippet title(book)}\n    <span data-testid=\"book-title\">{book}</span>\n  {/snippet}\n</script>\n\n<ul>\n  {#each books as book}\n    <li data-testid=\"book-item\">\n      {@render title(book)}\n    </li>\n  {/each}\n</ul>",
        "success": false,
        "errors": [
          "tmp/anthropic/Component.svelte:6:3 Unexpected token\nhttps://svelte.dev/e/js_parse_error"
        ],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tconst books = $state([\n\t\t'The Lord of the Rings',\n\t\t'To Kill a Mockingbird', \n\t\t'1984'\n\t]);\n\n\t{#snippet title(book)}\n\t\t<span data-testid=\"book-title\">{book}</span>\n\t{/snippet}\n</script>\n\n<ul>\n\t{#each books as book}\n\t\t<li data-testid=\"book-item\">\n\t\t\t{@render title(book)}\n\t\t</li>\n\t{/each}\n</ul>",
        "success": false,
        "errors": [
          "tmp/anthropic/Component.svelte:10:2 Unexpected token\nhttps://svelte.dev/e/js_parse_error"
        ],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<script>\n    const books = $state([\n        \"The Lord of the Rings\",\n        \"To Kill a Mockingbird\", \n        \"1984\"\n    ]);\n\n    {#snippet title(book)}\n        <span data-testid=\"book-title\">{book}</span>\n    {/snippet}\n</script>\n\n<ul>\n    {#each books as book}\n        <li data-testid=\"book-item\">\n            {@render title(book)}\n        </li>\n    {/each}\n</ul>",
        "success": false,
        "errors": [
          "tmp/anthropic/Component.svelte:10:5 Unexpected token\nhttps://svelte.dev/e/js_parse_error"
        ],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<script>\n  const books = [\n    \"The Lord of the Rings\", \n    \"To Kill a Mockingbird\", \n    \"1984\"\n  ];\n\n  {#snippet title(book)}\n    <span data-testid=\"book-title\">{book}</span>\n  {/snippet}\n</script>\n\n<ul>\n  {#each books as book}\n    <li data-testid=\"book-item\">\n      {@render title(book)}\n    </li>\n  {/each}\n</ul>",
        "success": false,
        "errors": [
          "tmp/anthropic/Component.svelte:10:3 Unexpected token\nhttps://svelte.dev/e/js_parse_error"
        ],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<script>\n  const books = [\n    'The Lord of the Rings', \n    'To Kill a Mockingbird', \n    '1984'\n  ];\n\n  {#snippet title(book)}\n    <span data-testid=\"book-title\">{book}</span>\n  {/snippet}\n</script>\n\n<ul>\n  {#each books as book}\n    <li data-testid=\"book-item\">\n      {@render title(book)}\n    </li>\n  {/each}\n</ul>",
        "success": false,
        "errors": [
          "tmp/anthropic/Component.svelte:10:3 Unexpected token\nhttps://svelte.dev/e/js_parse_error"
        ],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tconst books = $state([\n\t\t'The Lord of the Rings', \n\t\t'To Kill a Mockingbird', \n\t\t'1984'\n\t]);\n\n\t{#snippet title(book)}\n\t\t<span data-testid=\"book-title\">{book}</span>\n\t{/snippet}\n</script>\n\n<ul>\n\t{#each books as book}\n\t\t<li data-testid=\"book-item\">\n\t\t\t{@render title(book)}\n\t\t</li>\n\t{/each}\n</ul>",
        "success": false,
        "errors": [
          "tmp/anthropic/Component.svelte:10:2 Unexpected token\nhttps://svelte.dev/e/js_parse_error"
        ],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<script>\n  const books = ['The Lord of the Rings', 'To Kill a Mockingbird', '1984'];\n\n  {#snippet title(book)}\n    <span data-testid=\"book-title\">{book}</span>\n  {/snippet}\n</script>\n\n<ul>\n  {#each books as book}\n    <li data-testid=\"book-item\">\n      {@render title(book)}\n    </li>\n  {/each}\n</ul>",
        "success": false,
        "errors": [
          "tmp/anthropic/Component.svelte:6:3 Unexpected token\nhttps://svelte.dev/e/js_parse_error"
        ],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<script>\n  const books = ['The Lord of the Rings', 'To Kill a Mockingbird', '1984'];\n\n  {#snippet title(book)}\n    <span data-testid=\"book-title\">{book}</span>\n  {/snippet}\n</script>\n\n<ul>\n  {#each books as book}\n    <li data-testid=\"book-item\">\n      {@render title(book)}\n    </li>\n  {/each}\n</ul>",
        "success": false,
        "errors": [
          "tmp/anthropic/Component.svelte:6:3 Unexpected token\nhttps://svelte.dev/e/js_parse_error"
        ],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<script>\n  const books = ['The Lord of the Rings', 'To Kill a Mockingbird', '1984'];\n\n  {#snippet title(book)}\n    <span data-testid=\"book-title\">{book}</span>\n  {/snippet}\n</script>\n\n<ul>\n  {#each books as book}\n    <li data-testid=\"book-item\">\n      {@render title(book)}\n    </li>\n  {/each}\n</ul>",
        "success": false,
        "errors": [
          "tmp/anthropic/Component.svelte:6:3 Unexpected token\nhttps://svelte.dev/e/js_parse_error"
        ],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  },
  {
    "testName": "counter",
    "provider": "Google",
    "modelId": "gemini-2.5-pro-preview-03-25",
    "numSamples": 10,
    "numCorrect": 10,
    "pass1": 1,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let count = $state(0);\n\n  function increment() {\n    count += 1;\n  }\n\n  function decrement() {\n    count -= 1;\n  }\n</script>\n\n<div class=\"counter\">\n  <button data-testid=\"decrement-button\" onclick={decrement}>-</button>\n  <span data-testid=\"count-value\">{count}</span>\n  <button data-testid=\"increment-button\" onclick={increment}>+</button>\n</div>\n\n<style>\n  .counter {\n    display: flex;\n    align-items: center;\n    gap: 8px; /* Example style */\n    font-family: sans-serif;\n  }\n  button {\n    padding: 4px 8px;\n  }\n  span {\n    min-width: 20px;\n    text-align: center;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let count = $state(0);\n\n  function increment() {\n    count += 1;\n  }\n\n  function decrement() {\n    count -= 1;\n  }\n</script>\n\n<div class=\"counter\">\n  <button data-testid=\"decrement-button\" onclick={decrement}>-</button>\n  <span data-testid=\"count-value\">{count}</span>\n  <button data-testid=\"increment-button\" onclick={increment}>+</button>\n</div>\n\n<style>\n  .counter {\n    /* Basic styling for demonstration */\n    display: inline-flex;\n    align-items: center;\n    gap: 0.5rem;\n    padding: 0.5rem;\n    border: 1px solid #ccc;\n    border-radius: 4px;\n  }\n\n  button {\n    min-width: 2rem;\n    padding: 0.25rem 0.5rem;\n  }\n\n  span {\n    min-width: 1rem;\n    text-align: center;\n    font-weight: bold;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let count = $state(0);\n\n  function increment() {\n    count += 1;\n  }\n\n  function decrement() {\n    count -= 1;\n  }\n</script>\n\n<div class=\"counter\">\n  <button data-testid=\"decrement-button\" onclick={decrement}>-</button>\n  <span data-testid=\"count-value\">{count}</span>\n  <button data-testid=\"increment-button\" onclick={increment}>+</button>\n</div>\n\n<style>\n  .counter {\n    /* Add styles if needed */\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let count = $state(0);\n\n  function increment() {\n    count += 1;\n  }\n\n  function decrement() {\n    count -= 1;\n  }\n</script>\n\n<div class=\"counter\">\n  <button data-testid=\"decrement-button\" onclick={decrement}>-</button>\n  <span data-testid=\"count-value\">{count}</span>\n  <button data-testid=\"increment-button\" onclick={increment}>+</button>\n</div>\n\n<style>\n  .counter {\n    /* Add styles for the counter container if needed */\n    display: flex;\n    align-items: center;\n    gap: 0.5rem;\n  }\n  span {\n      min-width: 2ch; /* Ensure space for multi-digit numbers */\n      text-align: center;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let count = $state(0);\n\n  function increment() {\n    count += 1;\n  }\n\n  function decrement() {\n    count -= 1;\n  }\n</script>\n\n<div class=\"counter\">\n  <button data-testid=\"decrement-button\" onclick={decrement}>-</button>\n  <span data-testid=\"count-value\">{count}</span>\n  <button data-testid=\"increment-button\" onclick={increment}>+</button>\n</div>\n\n<style>\n  .counter {\n    display: flex;\n    align-items: center;\n    gap: 0.5rem;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let count = $state(0);\n\n  function increment() {\n    count += 1;\n  }\n\n  function decrement() {\n    count -= 1;\n  }\n</script>\n\n<div class=\"counter\">\n  <button data-testid=\"decrement-button\" onclick={decrement}>-</button>\n  <span data-testid=\"count-value\">{count}</span>\n  <button data-testid=\"increment-button\" onclick={increment}>+</button>\n</div>\n\n<style>\n  .counter {\n    /* Basic styling for demonstration */\n    display: inline-flex;\n    align-items: center;\n    gap: 8px;\n    padding: 8px;\n    border: 1px solid #ccc;\n    border-radius: 4px;\n  }\n\n  button {\n    padding: 4px 8px;\n  }\n\n  span {\n    min-width: 20px;\n    text-align: center;\n    font-weight: bold;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let count = $state(0);\n\n  function increment() {\n    count += 1;\n  }\n\n  function decrement() {\n    count -= 1;\n  }\n</script>\n\n<div class=\"counter\">\n  <button data-testid=\"decrement-button\" onclick={decrement}>-</button>\n  <span data-testid=\"count-value\">{count}</span>\n  <button data-testid=\"increment-button\" onclick={increment}>+</button>\n</div>\n\n<style>\n  .counter {\n    display: flex;\n    align-items: center;\n    gap: 1rem;\n    font-family: sans-serif;\n  }\n\n  button {\n    padding: 0.5rem 1rem;\n    font-size: 1rem;\n    cursor: pointer;\n  }\n\n  span {\n    font-size: 1.2rem;\n    font-weight: bold;\n    min-width: 2ch;\n    text-align: center;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let count = $state(0);\n\n  function decrement() {\n    count--;\n  }\n\n  function increment() {\n    count++;\n  }\n</script>\n\n<div class=\"counter\">\n  <button data-testid=\"decrement-button\" onclick={decrement}>-</button>\n  <span data-testid=\"count-value\">{count}</span>\n  <button data-testid=\"increment-button\" onclick={increment}>+</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let count = $state(0);\n\n  function increment() {\n    count += 1;\n  }\n\n  function decrement() {\n    count -= 1;\n  }\n</script>\n\n<div class=\"counter\">\n  <button data-testid=\"decrement-button\" onclick={decrement}>-</button>\n  <span data-testid=\"count-value\">{count}</span>\n  <button data-testid=\"increment-button\" onclick={increment}>+</button>\n</div>\n\n<style>\n  .counter {\n    display: flex;\n    align-items: center;\n    gap: 0.5rem;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let count = $state(0);\n\n  function increment() {\n    count += 1;\n  }\n\n  function decrement() {\n    count -= 1;\n  }\n</script>\n\n<div class=\"counter\">\n  <button data-testid=\"decrement-button\" onclick={decrement}>-</button>\n  <span data-testid=\"count-value\">{count}</span>\n  <button data-testid=\"increment-button\" onclick={increment}>+</button>\n</div>\n\n<style>\n  .counter {\n    display: flex;\n    align-items: center;\n    gap: 8px; /* Optional: Add some space between elements */\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  },
  {
    "testName": "derived",
    "provider": "Google",
    "modelId": "gemini-2.5-pro-preview-03-25",
    "numSamples": 10,
    "numCorrect": 10,
    "pass1": 1,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  const doubled = $derived(number * 2);\n\n  function increment() {\n    number += 1;\n  }\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  const doubled = $derived(number * 2);\n\n  function increment() {\n    number += 1;\n  }\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  const doubled = $derived(number * 2);\n\n  function increment() {\n    number += 1;\n  }\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  const doubled = $derived(number * 2);\n\n  function increment() {\n    number += 1;\n  }\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  const doubled = $derived(number * 2);\n\n  function increment() {\n    number += 1;\n  }\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  const doubled = $derived(number * 2);\n\n  function increment() {\n    number += 1;\n  }\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  const doubled = $derived(number * 2);\n\n  function increment() {\n    number += 1;\n  }\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  const doubled = $derived(number * 2);\n\n  function increment() {\n    number += 1;\n  }\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  const doubled = $derived(number * 2);\n\n  function increment() {\n    number += 1;\n  }\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>\n    Increment\n  </button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  const doubled = $derived(number * 2);\n\n  function increment() {\n    number += 1;\n  }\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>\n    Increment\n  </button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  },
  {
    "testName": "derived-by",
    "provider": "Google",
    "modelId": "gemini-2.5-pro-preview-03-25",
    "numSamples": 10,
    "numCorrect": 10,
    "pass1": 1,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('');\n\n  const stats = $derived.by(() => {\n    const trimmedText = text.trim();\n    const words = trimmedText === '' ? [] : trimmedText.split(/\\s+/);\n    const wordCount = words.length;\n    const charCount = text.length;\n    const isLong = wordCount > 15;\n    return {\n      wordCount,\n      charCount,\n      isLong\n    };\n  });\n\n  function clearText() {\n    text = '';\n  }\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <button data-testid=\"clear-button\" onclick={clearText}>Clear</button>\n  <div>\n    <p data-testid=\"word-count\">Words: {stats.wordCount}</p>\n    <p data-testid=\"char-count\">Characters: {stats.charCount}</p>\n    <p data-testid=\"length-indicator\">Status: {stats.isLong ? 'Long text' : 'Short text'}</p>\n  </div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('');\n\n  const stats = $derived.by(() => {\n    const words = text.trim().split(/\\s+/).filter(Boolean);\n    const wordCount = words.length;\n    const charCount = text.length;\n    const isLong = wordCount > 15;\n    return { wordCount, charCount, isLong };\n  });\n\n  function clearText() {\n    text = '';\n  }\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <button data-testid=\"clear-button\" onclick={clearText}>Clear</button>\n  <div>\n    <p data-testid=\"word-count\">Words: {stats.wordCount}</p>\n    <p data-testid=\"char-count\">Characters: {stats.charCount}</p>\n    <p data-testid=\"length-indicator\">Status: {stats.isLong ? 'Long text' : 'Short text'}</p>\n  </div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('');\n\n  const stats = $derived.by(() => {\n    const trimmedText = text.trim();\n    const words = trimmedText ? trimmedText.split(/\\s+/) : [];\n    const wordCount = words.length;\n    const charCount = text.length;\n    const isLong = wordCount > 15;\n    return { wordCount, charCount, isLong };\n  });\n\n  function clearText() {\n    text = '';\n  }\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} placeholder=\"Enter text here...\" />\n  <button data-testid=\"clear-button\" onclick={clearText}>Clear</button>\n  <div>\n    <p data-testid=\"word-count\">Words: {stats.wordCount}</p>\n    <p data-testid=\"char-count\">Characters: {stats.charCount}</p>\n    <p data-testid=\"length-indicator\">Status: {stats.isLong ? 'Long text' : 'Short text'}</p>\n  </div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('');\n\n  const stats = $derived.by(() => {\n    const trimmedText = text.trim();\n    const words = trimmedText ? trimmedText.split(/\\s+/).filter(Boolean) : [];\n    const wordCount = words.length;\n    const charCount = text.length;\n    const isLong = wordCount > 15;\n    return { wordCount, charCount, isLong };\n  });\n\n  function clearText() {\n    text = '';\n  }\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <button data-testid=\"clear-button\" onclick={clearText}>Clear</button>\n  <div>\n    <p data-testid=\"word-count\">Words: {stats.wordCount}</p>\n    <p data-testid=\"char-count\">Characters: {stats.charCount}</p>\n    <p data-testid=\"length-indicator\">Status: {stats.isLong ? 'Long text' : 'Short text'}</p>\n  </div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('');\n\n  const stats = $derived.by(() => {\n    const trimmedText = text.trim();\n    const words = trimmedText === '' ? [] : trimmedText.split(/\\s+/);\n    const wordCount = words.length;\n    const charCount = text.length;\n    const isLong = wordCount > 15;\n    return { wordCount, charCount, isLong };\n  });\n\n  function clearText() {\n    text = '';\n  }\n</script>\n\n<div>\n  <input\n    data-testid=\"text-input\"\n    type=\"text\"\n    bind:value={text}\n    placeholder=\"Enter some text...\"\n  />\n  <button data-testid=\"clear-button\" onclick={clearText}>Clear</button>\n  <div>\n    <p data-testid=\"word-count\">Words: {stats.wordCount}</p>\n    <p data-testid=\"char-count\">Characters: {stats.charCount}</p>\n    <p data-testid=\"length-indicator\">\n      Status: {stats.isLong ? 'Long text' : 'Short text'}\n    </p>\n  </div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('');\n\n  const stats = $derived.by(() => {\n    const trimmedText = text.trim();\n    const words = trimmedText === '' ? [] : trimmedText.split(/\\s+/);\n    const wordCount = words.length;\n    const charCount = text.length;\n    const isLong = wordCount > 15;\n    return { wordCount, charCount, isLong };\n  });\n\n  function clearText() {\n    text = '';\n  }\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <button data-testid=\"clear-button\" onclick={clearText}>Clear</button>\n  <div>\n    <p data-testid=\"word-count\">Words: {stats.wordCount}</p>\n    <p data-testid=\"char-count\">Characters: {stats.charCount}</p>\n    <p data-testid=\"length-indicator\">Status: {stats.isLong ? 'Long text' : 'Short text'}</p>\n  </div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('');\n\n  const stats = $derived.by(() => {\n    const words = text.trim().split(/\\s+/).filter(Boolean);\n    const wordCount = words.length;\n    const charCount = text.length;\n    const isLong = wordCount > 15;\n    return { wordCount, charCount, isLong };\n  });\n\n  function clearText() {\n    text = '';\n  }\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <button data-testid=\"clear-button\" onclick={clearText}>Clear</button>\n  <div>\n    <p data-testid=\"word-count\">Words: {stats.wordCount}</p>\n    <p data-testid=\"char-count\">Characters: {stats.charCount}</p>\n    <p data-testid=\"length-indicator\">Status: {stats.isLong ? 'Long text' : 'Short text'}</p>\n  </div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('');\n\n  const stats = $derived.by(() => {\n    const trimmedText = text.trim();\n    const words = trimmedText === '' ? [] : trimmedText.split(/\\s+/);\n    const wordCount = words.length;\n    const charCount = text.length;\n    const isLong = wordCount > 15;\n    return { wordCount, charCount, isLong };\n  });\n\n  function clearText() {\n    text = '';\n  }\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <button data-testid=\"clear-button\" onclick={clearText}>Clear</button>\n  <div>\n    <p data-testid=\"word-count\">Words: {stats.wordCount}</p>\n    <p data-testid=\"char-count\">Characters: {stats.charCount}</p>\n    <p data-testid=\"length-indicator\">Status: {stats.isLong ? 'Long text' : 'Short text'}</p>\n  </div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('');\n\n  const stats = $derived.by(() => {\n    const trimmedText = text.trim();\n    const words = trimmedText === '' ? [] : trimmedText.split(/\\s+/);\n    const wordCount = words.length;\n    const charCount = text.length;\n    const isLong = wordCount > 15;\n    return { wordCount, charCount, isLong };\n  });\n\n  function clearText() {\n    text = '';\n  }\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <button data-testid=\"clear-button\" onclick={clearText}>Clear</button>\n  <div>\n    <p data-testid=\"word-count\">Words: {stats.wordCount}</p>\n    <p data-testid=\"char-count\">Characters: {stats.charCount}</p>\n    <p data-testid=\"length-indicator\">Status: {stats.isLong ? 'Long text' : 'Short text'}</p>\n  </div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('');\n\n  const stats = $derived.by(() => {\n    const words = text.trim().split(/\\s+/).filter(Boolean);\n    const wordCount = words.length;\n    const charCount = text.length;\n    const isLong = wordCount > 15;\n    return {\n      wordCount,\n      charCount,\n      isLong\n    };\n  });\n\n  function clearText() {\n    text = '';\n  }\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} placeholder=\"Enter text here...\" />\n  <button data-testid=\"clear-button\" onclick={clearText}>Clear</button>\n  <div>\n    <p data-testid=\"word-count\">Words: {stats.wordCount}</p>\n    <p data-testid=\"char-count\">Characters: {stats.charCount}</p>\n    <p data-testid=\"length-indicator\">Status: {stats.isLong ? 'Long text' : 'Short text'}</p>\n  </div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  },
  {
    "testName": "each",
    "provider": "Google",
    "modelId": "gemini-2.5-pro-preview-03-25",
    "numSamples": 10,
    "numCorrect": 10,
    "pass1": 1,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let characters = $state([\"Jerry\", \"Elaine\", \"Kramer\"]);\n\n  function addGeorge() {\n    // Directly mutating the $state array triggers reactivity\n    characters.push(\"George\");\n  }\n</script>\n\n<div>\n  <ul data-testid=\"characters-list\">\n    {#each characters as character (character)}\n      <li data-testid=\"character\">{character}</li>\n    {/each}\n  </ul>\n  <button data-testid=\"add-george-button\" onclick={addGeorge}>Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let characters = $state([\"Jerry\", \"Elaine\", \"Kramer\"]);\n\n  function addGeorge() {\n    characters.push(\"George\");\n  }\n</script>\n\n<div>\n  <ul data-testid=\"characters-list\">\n    {#each characters as character (character)}\n      <li data-testid=\"character\">{character}</li>\n    {/each}\n  </ul>\n  <button data-testid=\"add-george-button\" onclick={addGeorge}>Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let characters = $state([\"Jerry\", \"Elaine\", \"Kramer\"]);\n\n  function addGeorge() {\n    characters.push(\"George\");\n    // Reassign to ensure reactivity if needed, though push should work with $state proxies\n    // characters = characters; // Not strictly necessary for simple push with Svelte 5 $state arrays\n  }\n</script>\n\n<div>\n  <ul data-testid=\"characters-list\">\n    {#each characters as character}\n      <li data-testid=\"character\">{character}</li>\n    {/each}\n  </ul>\n  <button onclick={addGeorge} data-testid=\"add-george-button\">Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let characters = $state([\"Jerry\", \"Elaine\", \"Kramer\"]);\n\n  function addGeorge() {\n    characters.push(\"George\");\n    // Svelte 5 automatically handles reactivity for array mutations\n    characters = characters; // No need for this reassignment in Svelte 5\n  }\n</script>\n\n<div>\n  <ul data-testid=\"characters-list\">\n    {#each characters as character (character)}\n      <li data-testid=\"character\">{character}</li>\n    {/each}\n  </ul>\n  <button onclick={addGeorge} data-testid=\"add-george-button\">Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let characters = $state([\"Jerry\", \"Elaine\", \"Kramer\"]);\n\n  function addGeorge() {\n    characters.push(\"George\");\n  }\n</script>\n\n<div>\n  <ul data-testid=\"characters-list\">\n    {#each characters as character}\n      <li data-testid=\"character\">{character}</li>\n    {/each}\n  </ul>\n  <button onclick={addGeorge} data-testid=\"add-george-button\">Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let characters = $state([\"Jerry\", \"Elaine\", \"Kramer\"]);\n\n  function addGeorge() {\n    characters.push(\"George\");\n  }\n</script>\n\n<div>\n  <ul data-testid=\"characters-list\">\n    {#each characters as character (character)}\n      <li data-testid=\"character\">{character}</li>\n    {/each}\n  </ul>\n  <button data-testid=\"add-george-button\" onclick={addGeorge}>Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let characters = $state([\"Jerry\", \"Elaine\", \"Kramer\"]);\n\n  function addGeorge() {\n    characters.push(\"George\");\n    // Reassignment is also fine: characters = [...characters, \"George\"];\n  }\n</script>\n\n<div>\n  <ul data-testid=\"characters-list\">\n    {#each characters as character (character)}\n      <li data-testid=\"character\">{character}</li>\n    {/each}\n  </ul>\n  <button data-testid=\"add-george-button\" onclick={addGeorge}>Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let characters = $state([\"Jerry\", \"Elaine\", \"Kramer\"]);\n\n  function addGeorge() {\n    // Check if George is already there to prevent duplicates, although not explicitly required\n    if (!characters.includes(\"George\")) {\n        characters.push(\"George\");\n    }\n  }\n</script>\n\n<div>\n  <ul data-testid=\"characters-list\">\n    {#each characters as character}\n      <li data-testid=\"character\">{character}</li>\n    {/each}\n  </ul>\n  <button data-testid=\"add-george-button\" onclick={addGeorge}>Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let characters = $state([\"Jerry\", \"Elaine\", \"Kramer\"]);\n\n  function addGeorge() {\n    characters.push(\"George\");\n  }\n</script>\n\n<div>\n  <ul data-testid=\"characters-list\">\n    {#each characters as character}\n      <li data-testid=\"character\">{character}</li>\n    {/each}\n  </ul>\n  <button data-testid=\"add-george-button\" onclick={addGeorge}>Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let characters = $state([\"Jerry\", \"Elaine\", \"Kramer\"]);\n\n  function addGeorge() {\n    // Prevent adding George multiple times if needed, though not specified\n    if (!characters.includes(\"George\")) {\n       characters.push(\"George\");\n       // Reassign to ensure reactivity if push wasn't enough (though $state proxies handle push)\n       characters = characters;\n    }\n  }\n</script>\n\n<div>\n  <ul data-testid=\"characters-list\">\n    {#each characters as character (character)}\n      <li data-testid=\"character\">{character}</li>\n    {/each}\n  </ul>\n  <button data-testid=\"add-george-button\" onclick={addGeorge}>Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  },
  {
    "testName": "effect",
    "provider": "Google",
    "modelId": "gemini-2.5-pro-preview-03-25",
    "numSamples": 10,
    "numCorrect": 10,
    "pass1": 1,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  const doubled = $derived(number * 2);\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $state(number * 2); // Initialize doubled\n\n  // Use $effect to update 'doubled' when 'number' changes\n  // Note: $derived would be the idiomatic Svelte 5 way for this calculation.\n  // Using $effect here specifically to fulfill the requirement of demonstrating $effect.\n  $effect(() => {\n    doubled = number * 2;\n  });\n\n  function increment() {\n    number += 1;\n  }\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  const doubled = $derived(number * 2);\n\n  function increment() {\n    number += 1;\n  }\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  const doubled = $derived(number * 2);\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $state(number * 2); // Initialize doubled\n\n  // Use $effect to update 'doubled' whenever 'number' changes, as requested.\n  // Note: $derived would typically be preferred for this kind of derived state.\n  $effect(() => {\n    doubled = number * 2;\n  });\n\n  function increment() {\n    number += 1;\n  }\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  const doubled = $derived(number * 2);\n\n  function increment() {\n    number += 1;\n  }\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $state(0); // Initialize doubled state\n\n  // Effect to calculate doubled when number changes\n  $effect(() => {\n    doubled = number * 2;\n  });\n\n  function increment() {\n    number += 1;\n  }\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  const doubled = $derived(number * 2);\n\n  function increment() {\n    number += 1;\n  }\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  const doubled = $derived(number * 2);\n\n  function increment() {\n    number += 1;\n  }\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $state(0); // Initialize doubled state\n\n  // Use $effect to update 'doubled' when 'number' changes\n  $effect(() => {\n    doubled = number * 2;\n  });\n\n  function increment() {\n    number += 1;\n  }\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  },
  {
    "testName": "hello-world",
    "provider": "Google",
    "modelId": "gemini-2.5-pro-preview-03-25",
    "numSamples": 10,
    "numCorrect": 10,
    "pass1": 1,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>\n\n<style>\n  .greeting {\n    color: blue;\n    text-align: center;\n    margin: 1rem;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>\n\n<style>\n  .greeting {\n    color: blue;\n    text-align: center;\n    margin: 10px;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<div data-testid=\"greeting\" class=\"greeting\">\n  Hello, World!\n</div>\n\n<style>\n  .greeting {\n    color: blue;\n    text-align: center;\n    margin: 1rem; /* Use rem for better accessibility/scaling */\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<div data-testid=\"greeting\" class=\"greeting\">\n  Hello, World!\n</div>\n\n<style>\n  .greeting {\n    color: blue;\n    text-align: center;\n    margin: 10px;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<div data-testid=\"greeting\" class=\"greeting\">\n  Hello, World!\n</div>\n\n<style>\n  .greeting {\n    color: blue;\n    text-align: center;\n    margin: 10px;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>\n\n<style>\n  .greeting {\n    color: blue;\n    text-align: center;\n    margin: 1rem;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>\n\n<style>\n  .greeting {\n    color: blue;\n    text-align: center;\n    margin: 10px;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>\n\n<style>\n  .greeting {\n    color: blue;\n    text-align: center;\n    margin: 1em;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<div data-testid=\"greeting\" class=\"greeting\">\n  Hello, World!\n</div>\n\n<style>\n  .greeting {\n    color: blue;\n    text-align: center;\n    margin: 10px;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>\n\n<style>\n  .greeting {\n    color: blue;\n    text-align: center;\n    margin: 1rem;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  },
  {
    "testName": "inspect",
    "provider": "Google",
    "modelId": "gemini-2.5-pro-preview-03-25",
    "numSamples": 10,
    "numCorrect": 0,
    "pass1": 0,
    "pass10": 0,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state(\"Hello world\");\n\n  // Basic inspection\n  $inspect(text);\n\n  // Inspection with a custom callback\n  $inspect(text).with(value => {\n    console.log(Custom inspection: Text is now \"${value}\");\n  });\n\n  // Trace inspection within an effect\n  $effect(() => {\n    // Read the state to establish dependency\n    const currentText = text;\n    console.log('Effect running due to text change...');\n    $inspect.trace(); // Log the trace leading to this effect\n  });\n\n  // Derived value (character count)\n  const charCount = $derived(text.length);\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <p data-testid=\"text-value\">Current text: {text}</p>\n  <p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "tmp/google/Component.svelte:11:23 Unexpected token\nhttps://svelte.dev/e/js_parse_error"
        ],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state(\"Hello world\");\n  const charCount = $derived(text.length);\n\n  // Basic inspection: logs the value whenever text changes\n  $inspect(text);\n\n  // Inspection with custom callback\n  $inspect(text).with(value => {\n    console.log('Custom Inspector: Text changed to ->', value);\n  });\n\n  // Effect that runs when 'text' changes, demonstrating trace\n  $effect(() => {\n    // This effect depends on text implicitly because it's read below\n    const currentText = text; // Reading text makes the effect dependent on it\n    console.log('Effect triggered by text change. Current value:', currentText);\n    // Trace dependencies causing this effect to run\n    $inspect.trace();\n  });\n\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <p data-testid=\"text-value\">Current text: {text}</p>\n  <p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "tmp/google/Component.svelte:21:4 `$inspect.trace(...)` must be the first statement of a function body\nhttps://svelte.dev/e/inspect_trace_invalid_placement"
        ],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<script>\n  // 1. Use $state for a text input starting with \"Hello world\"\n  let text = $state(\"Hello world\");\n\n  // 2. Use basic $inspect to log the input value\n  $inspect(text);\n\n  // 3. Implement $inspect(...).with to track updates with a custom callback\n  $inspect(text).with(value => {\n    console.log(Custom Inspector: Text updated to \"${value}\");\n  });\n\n  // 4. Implement $inspect.trace() inside an effect that runs when the input changes\n  $effect(() => {\n    // Reference 'text' to trigger the effect on change\n    const currentLength = text.length;\n    if (currentLength > 0) { // Avoid initial run log if not desired, or adjust logic\n        console.log(Effect triggered. Current text length: ${currentLength});\n        $inspect.trace();\n    }\n  });\n\n  // 5. Character count (derived implicitly in template)\n</script>\n\n<div>\n  <!-- 6. Input field -->\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n\n  <!-- 7. Display input value -->\n  <p data-testid=\"text-value\">Current text: {text}</p>\n\n  <!-- 8. Display character count -->\n  <p data-testid=\"char-count\">Character count: {text.length}</p>\n</div>",
        "success": false,
        "errors": [
          "tmp/google/Component.svelte:12:23 Unexpected token\nhttps://svelte.dev/e/js_parse_error"
        ],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state(\"Hello world\");\n\n  // Basic inspection - logs the value whenever it changes\n  $inspect(text);\n\n  // Inspection with a custom callback\n  $inspect(text).with(value => {\n    console.log(Text updated via custom inspector: ${value});\n  });\n\n  // Trace origin within an effect\n  $effect(() => {\n    // Effect runs when text changes. We use text to ensure dependency.\n    const currentLength = text.length;\n    console.log(Effect running due to text change (length: ${currentLength}). Tracing...);\n    $inspect.trace();\n  });\n\n  // Derived value for character count (implicitly derived in template)\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <p data-testid=\"text-value\">Current text: {text}</p>\n  <p data-testid=\"char-count\">Character count: {text.length}</p>\n</div>",
        "success": false,
        "errors": [
          "tmp/google/Component.svelte:11:21 Unexpected token\nhttps://svelte.dev/e/js_parse_error"
        ],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<script>\n  // 1. Use $state for text input\n  let text = $state(\"Hello world\");\n\n  // 2. Basic $inspect\n  $inspect(text);\n\n  // 3. $inspect(...).with\n  $inspect(text).with((value) => {\n    console.log('Custom inspector update:', value);\n  });\n\n  // 5. Display character count (derived value)\n  const charCount = $derived(text.length);\n\n  // 4. $inspect.trace() inside an effect\n  $effect(() => {\n    // Ensure effect depends on text\n    const currentText = text;\n    console.log('Effect triggered by text change. Current value:', currentText);\n    // Log the trace when the effect runs due to text change\n    $inspect.trace();\n  });\n</script>\n\n<div>\n  <!-- 6. Input field -->\n  <label>\n    Edit text:\n    <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  </label>\n\n  <!-- 7. Display input value -->\n  <p data-testid=\"text-value\">Current text: {text}</p>\n\n  <!-- 8. Display character count -->\n  <p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "tmp/google/Component.svelte:24:4 `$inspect.trace(...)` must be the first statement of a function body\nhttps://svelte.dev/e/inspect_trace_invalid_placement"
        ],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state(\"Hello world\");\n  const charCount = $derived(text.length);\n\n  // Basic inspection\n  $inspect(text);\n\n  // Inspection with custom callback\n  $inspect(text).with(value => {\n    console.log([Custom Inspector] Text updated to: \"${value}\");\n  });\n\n  // Effect with trace\n  $effect(() => {\n    // This effect runs whenever 'text' changes\n    console.log(Effect triggered by text change. Current value: \"${text}\");\n    $inspect.trace(); // Log the trace leading to this effect execution\n  });\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <p data-testid=\"text-value\">Current text: {text}</p>\n  <p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "tmp/google/Component.svelte:12:24 Unexpected token\nhttps://svelte.dev/e/js_parse_error"
        ],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state(\"Hello world\");\n  let charCount = $derived(text.length);\n\n  // Basic inspection: logs the value whenever it changes\n  $inspect(text);\n\n  // Inspection with custom callback\n  $inspect(text).with(value => {\n    console.log(Custom Log - Text changed to: \"${value}\");\n  });\n\n  // Effect that runs when text changes\n  $effect(() => {\n    // This effect depends on text\n    const currentText = text; // Read the state to establish dependency\n    console.log(Effect running because text changed. Current length: ${currentText.length});\n    // Trace the origin of this effect execution\n    $inspect.trace();\n  });\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <p data-testid=\"text-value\">Current text: {text}</p>\n  <p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "tmp/google/Component.svelte:12:23 Unexpected token\nhttps://svelte.dev/e/js_parse_error"
        ],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state(\"Hello world\");\n\n  // Basic inspection\n  $inspect(text);\n\n  // Inspection with a custom callback\n  $inspect(text).with((value) => {\n    console.log(Text changed via custom inspector: ${value});\n  });\n\n  // Derived value\n  const charCount = $derived(text.length);\n\n  // Effect using trace\n  $effect(() => {\n    // This effect runs whenever 'text' changes.\n    // We access 'text' indirectly here to ensure dependency tracking,\n    // although the main purpose is to demonstrate trace.\n    const currentLength = text.length;\n    console.log('Effect running due to text change, tracing dependencies...');\n    $inspect.trace();\n  });\n\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <p data-testid=\"text-value\">Current text: {text}</p>\n  <p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "tmp/google/Component.svelte:11:21 Unexpected token\nhttps://svelte.dev/e/js_parse_error"
        ],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state(\"Hello world\");\n\n  // Basic inspection\n  $inspect(text);\n\n  // Inspection with a custom callback\n  $inspect(text).with(value => {\n    console.log(Text updated (via .with): \"${value}\");\n  });\n\n  // Using trace inside an effect\n  $effect(() => {\n    // Read the state to make the effect dependent on it\n    const currentText = text;\n    console.log('Effect triggered by text change.');\n    // Trace the execution path leading to this effect run\n    $inspect.trace();\n  });\n\n  // Derived value (character count)\n  const charCount = $derived(text.length);\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <p data-testid=\"text-value\">Current text: {text}</p>\n  <p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "tmp/google/Component.svelte:11:21 Unexpected token\nhttps://svelte.dev/e/js_parse_error"
        ],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state(\"Hello world\");\n  const charCount = $derived(text.length);\n\n  // 1. Basic inspect\n  $inspect(text);\n\n  // 2. Inspect with custom callback\n  $inspect(text).with(value => {\n    console.log([Custom Inspector] Text changed to: \"${value}\");\n  });\n\n  // 3. Inspect.trace inside an effect\n  $effect(() => {\n    // Reference 'text' to make the effect depend on it\n    const currentText = text;\n    if (currentText) { // Avoid initial run log if not needed, or just log always\n        console.log([Effect] Text value is now: \"${currentText}\");\n        $inspect.trace(); // Log the stack trace leading to this effect run\n    }\n  });\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <p data-testid=\"text-value\">Current text: {text}</p>\n  <p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "tmp/google/Component.svelte:12:24 Unexpected token\nhttps://svelte.dev/e/js_parse_error"
        ],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  },
  {
    "testName": "props",
    "provider": "Google",
    "modelId": "gemini-2.5-pro-preview-03-25",
    "numSamples": 10,
    "numCorrect": 10,
    "pass1": 1,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let { name = \"World\", count: initialCount = 0, showDetails = false } = $props();\n\n  let count = $state(initialCount);\n\n  function increment() {\n    count++;\n  }\n</script>\n\n<div>\n  <h1 data-testid=\"name-display\">Hello, {name}!</h1>\n  <p data-testid=\"count-display\">Count: {count}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n\n  {#if showDetails}\n    <div data-testid=\"details\">\n      <p>Name is {name}</p>\n      <p>Count prop (initial) is {initialCount}</p>\n      <p>ShowDetails is {showDetails}</p>\n    </div>\n  {/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let { name = \"World\", count: initialCount = 0, showDetails = false } = $props();\n  let count = $state(initialCount);\n\n  function increment() {\n    count++;\n  }\n</script>\n\n<div>\n  <h1 data-testid=\"name-display\">Hello, {name}!</h1>\n  <p data-testid=\"count-display\">Count: {count}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n\n  {#if showDetails}\n    <div data-testid=\"details\">\n      <p>Initial Name is {name}</p>\n      <p>Initial Count is {initialCount}</p>\n      <p>ShowDetails is {showDetails}</p>\n    </div>\n  {/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let { name = \"World\", count: initialCount = 0, showDetails = false } = $props();\n  let count = $state(initialCount);\n\n  function increment() {\n    count++;\n  }\n</script>\n\n<div>\n  <h1 data-testid=\"name-display\">Hello, {name}!</h1>\n  <p data-testid=\"count-display\">Count: {count}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n\n  {#if showDetails}\n    <div data-testid=\"details\">\n      <p>Name is {name}</p>\n      <p>Initial Count is {initialCount}</p>\n      <p>ShowDetails is {showDetails}</p>\n    </div>\n  {/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let { name = 'World', count = 0, showDetails = false } = $props();\n\n  // Use $state to make the count mutable within the component\n  let internalCount = $state(count);\n\n  function increment() {\n    internalCount++;\n  }\n\n  // If the parent component updates the 'count' prop, reflect it in the internal state.\n  // This ensures the component reacts to external prop changes after initialization.\n  $effect(() => {\n      internalCount = count;\n  });\n\n</script>\n\n<div>\n  <h1 data-testid=\"name-display\">Hello, {name}!</h1>\n  <p data-testid=\"count-display\">Count: {internalCount}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n\n  {#if showDetails}\n    <div data-testid=\"details\">\n      <p>Name is {name}</p>\n      <p>Initial Count prop was {count}</p> <!-- Show the initial prop value -->\n      <p>ShowDetails is {showDetails}</p>\n    </div>\n  {/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let { name = 'World', count: initialCount = 0, showDetails = false } = $props();\n  let count = $state(initialCount);\n\n  function increment() {\n    count += 1;\n  }\n</script>\n\n<div>\n  <h1 data-testid=\"name-display\">Hello, {name}!</h1>\n  <p data-testid=\"count-display\">Count: {count}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n\n  {#if showDetails}\n    <div data-testid=\"details\">\n      <p>Name is {name}</p>\n      <p>Initial Count is {initialCount}</p>\n      <p>ShowDetails is {showDetails}</p>\n    </div>\n  {/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let { name = \"World\", count: initialCount = 0, showDetails = false } = $props();\n  let currentCount = $state(initialCount);\n\n  function increment() {\n    currentCount++;\n  }\n</script>\n\n<div>\n  <h1 data-testid=\"name-display\">Hello, {name}!</h1>\n  <p data-testid=\"count-display\">Count: {currentCount}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n\n  {#if showDetails}\n    <div data-testid=\"details\">\n      <p>Name is {name}</p>\n      <p>Initial Count is {initialCount}</p>\n      <p>ShowDetails is {showDetails}</p>\n    </div>\n  {/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let { name = \"World\", count: initialCount = 0, showDetails = false } = $props();\n  let currentCount = $state(initialCount);\n\n  function increment() {\n    currentCount++;\n  }\n</script>\n\n<div>\n  <h1 data-testid=\"name-display\">Hello, {name}!</h1>\n  <p data-testid=\"count-display\">Count: {currentCount}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n\n  {#if showDetails}\n    <div data-testid=\"details\">\n      <p>Name is {name}</p>\n      <p>Initial Count prop is {initialCount}</p>\n      <p>ShowDetails is {showDetails}</p>\n    </div>\n  {/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let { name = \"World\", count = 0, showDetails = false } = $props();\n  let currentCount = $state(count);\n\n  function increment() {\n    currentCount++;\n  }\n</script>\n\n<div>\n  <h1 data-testid=\"name-display\">Hello, {name}!</h1>\n  <p data-testid=\"count-display\">Count: {currentCount}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n\n  {#if showDetails}\n    <div data-testid=\"details\">\n      <p>Name is {name}</p>\n      <p>Initial Count prop was {count}</p>\n      <p>ShowDetails is {showDetails}</p>\n    </div>\n  {/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let { name = \"World\", count: initialCount = 0, showDetails = false } = $props();\n  let count = $state(initialCount);\n\n  function increment() {\n    count++;\n  }\n</script>\n\n<div>\n  <h1 data-testid=\"name-display\">Hello, {name}!</h1>\n  <p data-testid=\"count-display\">Count: {count}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n\n  {#if showDetails}\n    <div data-testid=\"details\">\n      <p>Name is {name}</p>\n      <p>Initial Count is {initialCount}</p>\n      <p>ShowDetails is {showDetails}</p>\n    </div>\n  {/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let { name = \"World\", count: initialCount = 0, showDetails = false } = $props();\n  let currentCount = $state(initialCount);\n\n  function increment() {\n    currentCount++;\n  }\n</script>\n\n<div>\n  <h1 data-testid=\"name-display\">Hello, {name}!</h1>\n  <p data-testid=\"count-display\">Count: {currentCount}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n\n  {#if showDetails}\n    <div data-testid=\"details\">\n      <p>Prop 'name' is: {name}</p>\n      <p>Prop 'count' (initial) is: {initialCount}</p>\n      <p>Prop 'showDetails' is: {showDetails}</p>\n    </div>\n  {/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  },
  {
    "testName": "snippets",
    "provider": "Google",
    "modelId": "gemini-2.5-pro-preview-03-25",
    "numSamples": 10,
    "numCorrect": 8,
    "pass1": 0.7999999999999999,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n  const books = $state([\"The Lord of the Rings\", \"To Kill a Mockingbird\", \"1984\"]);\n</script>\n\n{#snippet title(bookTitle)}\n  <span data-testid=\"book-title\">{bookTitle}</span>\n{/snippet}\n\n<ul>\n  {#each books as book}\n    <li data-testid=\"book-item\">\n      {@render title(book)}\n    </li>\n  {/each}\n</ul>",
        "success": true,
        "errors": [],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<script>\n  const books = $state([\n    \"The Lord of the Rings\",\n    \"To Kill a Mockingbird\",\n    \"1984\"\n  ]);\n</script>\n\n{#snippet title(bookTitle)}\n  <span data-testid=\"book-title\">{bookTitle}</span>\n{/snippet}\n\n<ul>\n  {#each books as book}\n    <li data-testid=\"book-item\">\n      {@render title(book)}\n    </li>\n  {/each}\n</ul>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<script>\n  // Hardcoded array of book titles\n  const bookTitles = [\"The Lord of the Rings\", \"To Kill a Mockingbird\", \"1984\"];\n</script>\n\n{#snippet title(bookTitle)}\n  <span data-testid=\"book-title\">{bookTitle}</span>\n{/snippet}\n\n<ul>\n  {#each bookTitles as currentTitle}\n    <li data-testid=\"book-item\">\n      {@render title(currentTitle)}\n    </li>\n  {/each}\n</ul>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<script>\n  const books = [\n    \"The Lord of the Rings\",\n    \"To Kill a Mockingbird\",\n    \"1984\"\n  ];\n</script>\n\n{#snippet title(bookTitle)}\n  <span data-testid=\"book-title\">{bookTitle}</span>\n{/snippet}\n\n<ul>\n  {#each books as book}\n    <li data-testid=\"book-item\">\n      {@render title(book)}\n    </li>\n  {/each}\n</ul>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<script>\n  const books = $state([\n    \"The Lord of the Rings\",\n    \"To Kill a Mockingbird\",\n    \"1984\"\n  ]);\n</script>\n\n{#snippet title(bookTitle)}\n  <span data-testid=\"book-title\">{bookTitle}</span>\n{/snippet}\n\n<ul>\n  {#each books as book}\n    <li data-testid=\"book-item\">\n      {@render title(book)}\n    </li>\n  {/each}\n</ul>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<script>\n  const books = $state([\n    'The Lord of the Rings',\n    'To Kill a Mockingbird',\n    '1984',\n  ]);\n</script>\n\n{#snippet title(bookTitle)}\n  <span data-testid=\"book-title\">{bookTitle}</span>\n{/snippet}\n\n<ul>\n  {#each books as book}\n    <li data-testid=\"book-item\">\n      {@render title(book)}\n    </li>\n  {/each}\n</ul>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<script>\n  const bookTitles = $state([\n    \"The Lord of the Rings\",\n    \"To Kill a Mockingbird\",\n    \"1984\"\n  ]);\n</script>\n\n{#snippet title(bookTitle)}\n  <span data-testid=\"book-title\">{bookTitle}</span>\n{/snippet}\n\n<ul>\n  {#each bookTitles as title}\n    <li data-testid=\"book-item\">\n      {@render title(title)}\n    </li>\n  {/each}\n</ul>",
        "success": false,
        "errors": [
          "snippet is not a function\n\n\tin Component.svelte\n",
          "snippet is not a function\n\n\tin Component.svelte\n",
          "snippet is not a function\n\n\tin Component.svelte\n"
        ],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<script>\n  const books = $state([\n    \"The Lord of the Rings\",\n    \"To Kill a Mockingbird\",\n    \"1984\"\n  ]);\n</script>\n\n{#snippet title(bookTitle)}\n  <span data-testid=\"book-title\">{bookTitle}</span>\n{/snippet}\n\n<ul>\n  {#each books as book}\n    <li data-testid=\"book-item\">\n      {@render title(book)}\n    </li>\n  {/each}\n</ul>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<script>\n  const bookTitles = $state([\"The Lord of the Rings\", \"To Kill a Mockingbird\", \"1984\"]);\n\n  {#snippet title(bookTitle)}\n    <span data-testid=\"book-title\">{bookTitle}</span>\n  {/snippet}\n</script>\n\n<ul>\n  {#each bookTitles as book}\n    <li data-testid=\"book-item\">\n      {@render title(book)}\n    </li>\n  {/each}\n</ul>",
        "success": false,
        "errors": [
          "tmp/google/Component.svelte:6:3 Unexpected token\nhttps://svelte.dev/e/js_parse_error"
        ],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<script>\n  const books = [\"The Lord of the Rings\", \"To Kill a Mockingbird\", \"1984\"];\n</script>\n\n{#snippet title(bookTitle)}\n  <span data-testid=\"book-title\">{bookTitle}</span>\n{/snippet}\n\n<ul>\n  {#each books as book}\n    <li data-testid=\"book-item\">\n      {@render title(book)}\n    </li>\n  {/each}\n</ul>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  },
  {
    "testName": "counter",
    "provider": "Google",
    "modelId": "gemini-2.5-flash-preview-04-17",
    "numSamples": 10,
    "numCorrect": 10,
    "pass1": 1,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let count = $state(0);\n\n  function increment() {\n    count++;\n  }\n\n  function decrement() {\n    count--;\n  }\n</script>\n\n<div class=\"counter\">\n  <button data-testid=\"decrement-button\" onclick={decrement}>-</button>\n  <span data-testid=\"count-value\">{count}</span>\n  <button data-testid=\"increment-button\" onclick={increment}>+</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let count = $state(0);\n\n  function increment() {\n    count++;\n  }\n\n  function decrement() {\n    count--;\n  }\n</script>\n\n<div class=\"counter\">\n  <button onclick={decrement} data-testid=\"decrement-button\">-</button>\n  <span data-testid=\"count-value\">{count}</span>\n  <button onclick={increment} data-testid=\"increment-button\">+</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let count = $state(0);\n</script>\n\n<div class=\"counter\">\n  <button data-testid=\"decrement-button\" onclick={() => count--}>-</button>\n  <span data-testid=\"count-value\">{count}</span>\n  <button data-testid=\"increment-button\" onclick={() => count++}>+</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let count = $state(0);\n\n  function increment() {\n    count++;\n  }\n\n  function decrement() {\n    count--;\n  }\n</script>\n\n<div class=\"counter\">\n  <button onclick={decrement} data-testid=\"decrement-button\">-</button>\n  <span data-testid=\"count-value\">{count}</span>\n  <button onclick={increment} data-testid=\"increment-button\">+</button>\n</div>\n\n<style>\n  .counter {\n    display: flex;\n    align-items: center;\n    gap: 8px;\n  }\n\n  button {\n    padding: 4px 8px;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let count = $state(0);\n\n  function increment() {\n    count++;\n  }\n\n  function decrement() {\n    count--;\n  }\n</script>\n\n<div class=\"counter\">\n  <button onclick={decrement} data-testid=\"decrement-button\">-</button>\n  <span data-testid=\"count-value\">{count}</span>\n  <button onclick={increment} data-testid=\"increment-button\">+</button>\n</div>\n\n<style>\n  .counter {\n    display: flex;\n    align-items: center;\n    gap: 10px;\n    padding: 10px;\n    border: 1px solid #ccc;\n    border-radius: 4px;\n    font-family: sans-serif;\n  }\n\n  .counter button {\n    padding: 5px 10px;\n    font-size: 1em;\n    cursor: pointer;\n  }\n\n  .counter span {\n    font-size: 1.2em;\n    min-width: 20px;\n    text-align: center;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let count = $state(0);\n\n  function increment() {\n    count++;\n  }\n\n  function decrement() {\n    count--;\n  }\n</script>\n\n<div class=\"counter\">\n  <button onclick={decrement} data-testid=\"decrement-button\">-</button>\n  <span data-testid=\"count-value\">{count}</span>\n  <button onclick={increment} data-testid=\"increment-button\">+</button>\n</div>\n\n<style>\n  .counter {\n    display: flex;\n    align-items: center;\n    gap: 0.5rem;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet count = $state(0);\n\n\tfunction decrement() {\n\t\tcount -= 1;\n\t}\n\n\tfunction increment() {\n\t\tcount += 1;\n\t}\n</script>\n\n<div class=\"counter\">\n\t<button onclick={decrement} data-testid=\"decrement-button\">-</button>\n\t<span data-testid=\"count-value\">{count}</span>\n\t<button onclick={increment} data-testid=\"increment-button\">+</button>\n</div>\n\n<style>\n\t.counter {\n\t\tdisplay: flex;\n\t\talign-items: center;\n\t\tgap: 8px;\n\t}\n\n\tbutton {\n\t\tpadding: 8px 16px;\n\t\tfont-size: 1rem;\n\t\tcursor: pointer;\n\t}\n\n\tspan {\n\t\tfont-size: 1.2rem;\n\t\tfont-weight: bold;\n\t}\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let count = $state(0);\n</script>\n\n<div class=\"counter\">\n  <button data-testid=\"decrement-button\" onclick={() => count--}>-</button>\n  <span data-testid=\"count-value\">{count}</span>\n  <button data-testid=\"increment-button\" onclick={() => count++}>+</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let count = $state(0);\n\n  function increment() {\n    count++;\n  }\n\n  function decrement() {\n    count--;\n  }\n</script>\n\n<div class=\"counter\">\n  <button onclick={decrement} data-testid=\"decrement-button\">-</button>\n  <span data-testid=\"count-value\">{count}</span>\n  <button onclick={increment} data-testid=\"increment-button\">+</button>\n</div>\n\n<style>\n  /* Add your styles for the .counter class here */\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet count = $state(0);\n\n\tfunction increment() {\n\t\tcount++;\n\t}\n\n\tfunction decrement() {\n\t\tcount--;\n\t}\n</script>\n\n<div class=\"counter\">\n\t<button onclick={decrement} data-testid=\"decrement-button\">-</button>\n\t<span data-testid=\"count-value\">{count}</span>\n\t<button onclick={increment} data-testid=\"increment-button\">+</button>\n</div>\n\n<style>\n\t.counter {\n\t\tdisplay: flex;\n\t\talign-items: center;\n\t\tgap: 0.5em;\n\t\tfont-size: 1.2em;\n\t}\n\n\tbutton {\n\t\tpadding: 0.5em 1em;\n\t\tfont-size: 1em;\n\t}\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  },
  {
    "testName": "derived",
    "provider": "Google",
    "modelId": "gemini-2.5-flash-preview-04-17",
    "numSamples": 10,
    "numCorrect": 10,
    "pass1": 1,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  const doubled = $derived(number * 2);\n\n  function increment() {\n    number++;\n  }\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  const doubled = $derived(number * 2);\n\n  function increment() {\n    number++;\n  }\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button onclick={increment} data-testid=\"increment-button\">Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  const doubled = $derived(number * 2);\n\n  function increment() {\n    number++;\n  }\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  const doubled = $derived(number * 2);\n\n  function increment() {\n    number++;\n  }\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  const doubled = $derived(number * 2);\n\n  function increment() {\n    number++;\n  }\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  const doubled = $derived(number * 2);\n\n  function increment() {\n    number++;\n  }\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  const doubled = $derived(number * 2);\n\n  function increment() {\n    number++;\n  }\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  const doubled = $derived(number * 2);\n\n  function increment() {\n    number++;\n  }\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  const doubled = $derived(number * 2);\n\n  function increment() {\n    number++;\n  }\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  const doubled = $derived(number * 2);\n\n  function increment() {\n    number += 1;\n  }\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  },
  {
    "testName": "derived-by",
    "provider": "Google",
    "modelId": "gemini-2.5-flash-preview-04-17",
    "numSamples": 10,
    "numCorrect": 10,
    "pass1": 1,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('');\n\n  const { wordCount, charCount, isLong } = $derived.by(() => {\n    const words = text.trim().split(/\\s+/).filter(word => word.length > 0);\n    const wordCount = words.length;\n    const charCount = text.length;\n    const isLong = wordCount > 15;\n    return { wordCount, charCount, isLong };\n  });\n\n  function clearText() {\n    text = '';\n  }\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <button data-testid=\"clear-button\" onclick={clearText}>Clear</button>\n  <div>\n    <p data-testid=\"word-count\">Words: {wordCount}</p>\n    <p data-testid=\"char-count\">Characters: {charCount}</p>\n    <p data-testid=\"length-indicator\">Status: {isLong ? 'Long text' : 'Short text'}</p>\n  </div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('');\n\n  const { wordCount, charCount, isLong } = $derived.by(() => {\n    const words = text.trim().split(/\\s+/).filter(word => word.length > 0);\n    const wordCount = words.length;\n    const charCount = text.length;\n    const isLong = wordCount > 15;\n    return { wordCount, charCount, isLong };\n  });\n\n  function clearText() {\n    text = '';\n  }\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <button data-testid=\"clear-button\" onclick={clearText}>Clear</button>\n  <div>\n    <p data-testid=\"word-count\">Words: {wordCount}</p>\n    <p data-testid=\"char-count\">Characters: {charCount}</p>\n    <p data-testid=\"length-indicator\">Status: {isLong ? 'Long text' : 'Short text'}</p>\n  </div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('');\n\n  const { wordCount, charCount, isLong } = $derived.by(() => {\n    const words = text.trim().split(/\\s+/).filter(word => word.length > 0);\n    const wordCount = words.length;\n    const charCount = text.length;\n    const isLong = wordCount > 15;\n\n    return { wordCount, charCount, isLong };\n  });\n\n  function clearText() {\n    text = '';\n  }\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <button data-testid=\"clear-button\" onclick={clearText}>Clear</button>\n  <div>\n    <p data-testid=\"word-count\">Words: {wordCount}</p>\n    <p data-testid=\"char-count\">Characters: {charCount}</p>\n    <p data-testid=\"length-indicator\">Status: {isLong ? 'Long text' : 'Short text'}</p>\n  </div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('');\n\n  const derivedStats = $derived.by(() => {\n    const words = text.trim().split(/\\s+/).filter(Boolean);\n    const wordCount = words.length;\n    const charCount = text.length;\n    const isLong = wordCount > 15;\n\n    return {\n      wordCount,\n      charCount,\n      isLong,\n    };\n  });\n\n  function clearText() {\n    text = '';\n  }\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <button data-testid=\"clear-button\" onclick={clearText}>Clear</button>\n  <div>\n    <p data-testid=\"word-count\">Words: {derivedStats.wordCount}</p>\n    <p data-testid=\"char-count\">Characters: {derivedStats.charCount}</p>\n    <p data-testid=\"length-indicator\">Status: {derivedStats.isLong ? 'Long text' : 'Short text'}</p>\n  </div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet text = $state('');\n\n\tconst { wordCount, charCount, isLong } = $derived.by(() => {\n\t\tconst words = text.trim().split(/\\s+/).filter(Boolean);\n\t\tconst wordCount = words.length;\n\t\tconst charCount = text.length;\n\t\tconst isLong = wordCount > 15;\n\n\t\treturn {\n\t\t\twordCount,\n\t\t\tcharCount,\n\t\t\tisLong\n\t\t};\n\t});\n\n\tfunction clearText() {\n\t\ttext = '';\n\t}\n</script>\n\n<div>\n\t<input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n\t<button data-testid=\"clear-button\" onclick={clearText}>Clear</button>\n\t<div>\n\t\t<p data-testid=\"word-count\">Words: {wordCount}</p>\n\t\t<p data-testid=\"char-count\">Characters: {charCount}</p>\n\t\t<p data-testid=\"length-indicator\">Status: {isLong ? 'Long text' : 'Short text'}</p>\n\t</div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('');\n\n  const analysis = $derived.by(() => {\n    const charCount = text.length;\n    const words = text.trim().split(/\\s+/).filter(word => word.length > 0);\n    const wordCount = words.length;\n    const isLong = wordCount > 15;\n\n    return {\n      charCount,\n      wordCount,\n      isLong\n    };\n  });\n\n  function clearText() {\n    text = '';\n  }\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <button data-testid=\"clear-button\" onclick={clearText}>Clear</button>\n  <div>\n    <p data-testid=\"word-count\">Words: {analysis.wordCount}</p>\n    <p data-testid=\"char-count\">Characters: {analysis.charCount}</p>\n    <p data-testid=\"length-indicator\">Status: {analysis.isLong ? 'Long text' : 'Short text'}</p>\n  </div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('');\n\n  const derivedStats = $derived.by(() => {\n    const charCount = text.length;\n    const words = text.trim().split(/\\s+/).filter(word => word.length > 0);\n    const wordCount = words.length;\n    const isLong = wordCount > 15;\n\n    return {\n      wordCount,\n      charCount,\n      isLong\n    };\n  });\n\n  function clearText() {\n    text = '';\n  }\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <button data-testid=\"clear-button\" onclick={clearText}>Clear</button>\n  <div>\n    <p data-testid=\"word-count\">Words: {derivedStats.wordCount}</p>\n    <p data-testid=\"char-count\">Characters: {derivedStats.charCount}</p>\n    <p data-testid=\"length-indicator\">Status: {derivedStats.isLong ? 'Long text' : 'Short text'}</p>\n  </div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('');\n\n  const derivedStats = $derived.by(() => {\n    const words = text.trim().split(/\\s+/).filter(word => word.length > 0);\n    const wordCount = words.length;\n    const charCount = text.length;\n    const isLong = wordCount > 15;\n\n    return {\n      wordCount,\n      charCount,\n      isLong\n    };\n  });\n\n  function clearText() {\n    text = '';\n  }\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <button data-testid=\"clear-button\" onclick={clearText}>Clear</button>\n  <div>\n    <p data-testid=\"word-count\">Words: {derivedStats.wordCount}</p>\n    <p data-testid=\"char-count\">Characters: {derivedStats.charCount}</p>\n    <p data-testid=\"length-indicator\">Status: {derivedStats.isLong ? 'Long text' : 'Short text'}</p>\n  </div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet text = $state('');\n\n\tconst { wordCount, charCount, isLong } = $derived.by(() => {\n\t\tconst words = text.trim().split(/\\s+/).filter(word => word.length > 0);\n\t\tconst wordCount = words.length;\n\t\tconst charCount = text.length;\n\t\tconst isLong = wordCount > 15;\n\n\t\treturn { wordCount, charCount, isLong };\n\t});\n\n\tfunction clearText() {\n\t\ttext = '';\n\t}\n</script>\n\n<div>\n\t<input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n\t<button data-testid=\"clear-button\" onclick={clearText}>Clear</button>\n\t<div>\n\t\t<p data-testid=\"word-count\">Words: {wordCount}</p>\n\t\t<p data-testid=\"char-count\">Characters: {charCount}</p>\n\t\t<p data-testid=\"length-indicator\">Status: {isLong ? 'Long text' : 'Short text'}</p>\n\t</div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('');\n\n  const { wordCount, charCount, isLong } = $derived.by(() => {\n    const wordCount = text.trim() === '' ? 0 : text.trim().split(/\\s+/).length;\n    const charCount = text.length;\n    const isLong = wordCount > 15;\n\n    return {\n      wordCount,\n      charCount,\n      isLong\n    };\n  });\n\n  function clearText() {\n    text = '';\n  }\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <button data-testid=\"clear-button\" onclick={clearText}>Clear</button>\n  <div>\n    <p data-testid=\"word-count\">Words: {wordCount}</p>\n    <p data-testid=\"char-count\">Characters: {charCount}</p>\n    <p data-testid=\"length-indicator\">Status: {isLong ? 'Long text' : 'Short text'}</p>\n  </div>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  },
  {
    "testName": "each",
    "provider": "Google",
    "modelId": "gemini-2.5-flash-preview-04-17",
    "numSamples": 10,
    "numCorrect": 10,
    "pass1": 1,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let characters = $state([\"Jerry\", \"Elaine\", \"Kramer\"]);\n\n  function addGeorge() {\n    characters.push(\"George\");\n  }\n</script>\n\n<div>\n  <ul data-testid=\"characters-list\">\n    {#each characters as character}\n      <li data-testid=\"character\">{character}</li>\n    {/each}\n  </ul>\n  <button onclick={addGeorge} data-testid=\"add-george-button\">Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet characters = $state(['Jerry', 'Elaine', 'Kramer']);\n\n\tfunction addGeorge() {\n\t\tcharacters.push('George');\n\t}\n</script>\n\n<div>\n\t<ul data-testid=\"characters-list\">\n\t\t{#each characters as character}\n\t\t\t<li data-testid=\"character\">{character}</li>\n\t\t{/each}\n\t</ul>\n\t<button data-testid=\"add-george-button\" onclick={addGeorge}>Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet characters = $state(['Jerry', 'Elaine', 'Kramer']);\n\n\tfunction addGeorge() {\n\t\tcharacters.push('George');\n\t}\n</script>\n\n<div>\n\t<ul data-testid=\"characters-list\">\n\t\t{#each characters as character}\n\t\t\t<li data-testid=\"character\">{character}</li>\n\t\t{/each}\n\t</ul>\n\t<button onclick={addGeorge} data-testid=\"add-george-button\">Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let characters = $state(['Jerry', 'Elaine', 'Kramer']);\n\n  function addGeorge() {\n    characters.push('George');\n  }\n</script>\n\n<div>\n  <ul data-testid=\"characters-list\">\n    {#each characters as character}\n      <li data-testid=\"character\">{character}</li>\n    {/each}\n  </ul>\n  <button data-testid=\"add-george-button\" onclick={addGeorge}>Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet characters = $state(['Jerry', 'Elaine', 'Kramer']);\n\n\tfunction addGeorge() {\n\t\tcharacters = [...characters, 'George'];\n\t}\n</script>\n\n<div>\n\t<ul data-testid=\"characters-list\">\n\t\t{#each characters as character}\n\t\t\t<li data-testid=\"character\">{character}</li>\n\t\t{/each}\n\t</ul>\n\t<button data-testid=\"add-george-button\" onclick={addGeorge}>Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let characters = $state([\"Jerry\", \"Elaine\", \"Kramer\"]);\n\n  function addGeorge() {\n    characters.push(\"George\");\n  }\n</script>\n\n<div>\n  <ul data-testid=\"characters-list\">\n    {#each characters as character}\n      <li data-testid=\"character\">{character}</li>\n    {/each}\n  </ul>\n  <button onclick={addGeorge} data-testid=\"add-george-button\">Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let characters = $state(['Jerry', 'Elaine', 'Kramer']);\n\n  function addGeorge() {\n    characters.push('George');\n  }\n</script>\n\n<div>\n  <ul data-testid=\"characters-list\">\n    {#each characters as character}\n      <li data-testid=\"character\">{character}</li>\n    {/each}\n  </ul>\n  <button data-testid=\"add-george-button\" onclick={addGeorge}>Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet characters = $state(['Jerry', 'Elaine', 'Kramer']);\n\n\tfunction addGeorge() {\n\t\tcharacters.push('George');\n\t}\n</script>\n\n<div>\n\t<ul data-testid=\"characters-list\">\n\t\t{#each characters as character}\n\t\t\t<li data-testid=\"character\">{character}</li>\n\t\t{/each}\n\t</ul>\n\t<button data-testid=\"add-george-button\" onclick={addGeorge}>Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let characters = $state(['Jerry', 'Elaine', 'Kramer']);\n\n  function addGeorge() {\n    characters.push('George');\n  }\n</script>\n\n<div>\n  <ul data-testid=\"characters-list\">\n    {#each characters as character}\n      <li data-testid=\"character\">{character}</li>\n    {/each}\n  </ul>\n  <button onclick={addGeorge} data-testid=\"add-george-button\">Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let characters = $state([\"Jerry\", \"Elaine\", \"Kramer\"]);\n\n  function addGeorge() {\n    characters.push(\"George\");\n  }\n</script>\n\n<div>\n  <ul data-testid=\"characters-list\">\n    {#each characters as character}\n      <li data-testid=\"character\">{character}</li>\n    {/each}\n  </ul>\n  <button data-testid=\"add-george-button\" onclick={addGeorge}>Add George</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  },
  {
    "testName": "effect",
    "provider": "Google",
    "modelId": "gemini-2.5-flash-preview-04-17",
    "numSamples": 10,
    "numCorrect": 9,
    "pass1": 0.9,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  const doubled = $derived(number * 2);\n\n  function increment() {\n    number++;\n  }\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet number = $state(5);\n\tlet doubled = $state(0);\n\n\t$effect(() => {\n\t\tdoubled = number * 2;\n\t});\n\n\tfunction increment() {\n\t\tnumber++;\n\t}\n</script>\n\n<div>\n\t<p data-testid=\"number-value\">Number: {number}</p>\n\t<p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n\t<button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $state(0);\n\n  $effect(() => {\n    // Calculate the doubled value as a side effect of number changing\n    doubled = number * 2;\n  });\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  const doubled = $derived(number * 2);\n\n  // Use $effect for a side effect triggered by the state changes\n  // (e.g., logging, although the requirement was phrased ambiguously)\n  $effect(() => {\n    // This effect runs whenever number or doubled changes\n    // console.log('Number or doubled changed:', number, doubled);\n    // The requirement was confusingly worded about using $effect to \"calculate\",\n    // but $derived is for calculation and $effect is for side effects.\n    // This fulfills the spirit of using $effect with the relevant state.\n  });\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $state(0);\n\n  $effect(() => {\n    doubled = number * 2;\n  });\n\n  function increment() {\n    number++;\n  }\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $state(0);\n\n  $effect(() => {\n    doubled = number * 2;\n  });\n\n  function increment() {\n    number++;\n  }\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<script>\n  import { $state, $effect } from 'svelte';\n\n  let number = $state(5);\n  let doubled = $state(0);\n\n  $effect(() => {\n    // This effect calculates the doubled value and updates the state\n    doubled = number * 2;\n  });\n\n  function increment() {\n    number++;\n  }\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button onclick={increment} data-testid=\"increment-button\">Increment</button>\n</div>",
        "success": false,
        "errors": [
          "tmp/google/Component.svelte:4:11 The $ prefix is reserved, and cannot be used for variables and imports\nhttps://svelte.dev/e/dollar_prefix_invalid"
        ],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  let doubled = $state(0);\n\n  $effect(() => {\n    doubled = number * 2;\n  });\n\n  function increment() {\n    number++;\n  }\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet number = $state(5);\n\tconst doubled = $derived(number * 2);\n\n\tfunction increment() {\n\t\tnumber++;\n\t}\n</script>\n\n<div>\n\t<p data-testid=\"number-value\">Number: {number}</p>\n\t<p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n\t<button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let number = $state(5);\n  const doubled = $derived(number * 2);\n\n  $effect(() => {\n    console.log('Number changed:', number);\n  });\n</script>\n\n<div>\n  <p data-testid=\"number-value\">Number: {number}</p>\n  <p data-testid=\"doubled-value\">Doubled: {doubled}</p>\n  <button data-testid=\"increment-button\" onclick={() => number++}>Increment</button>\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  },
  {
    "testName": "hello-world",
    "provider": "Google",
    "modelId": "gemini-2.5-flash-preview-04-17",
    "numSamples": 10,
    "numCorrect": 10,
    "pass1": 1,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>\n\n<style>\n\t.greeting {\n\t\tcolor: blue;\n\t\ttext-align: center;\n\t\tmargin: 10px;\n\t}\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>\n\n<style>\n\t.greeting {\n\t\tcolor: blue;\n\t\ttext-align: center;\n\t\tmargin: 10px;\n\t}\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>\n\n<style>\n\t.greeting {\n\t\tcolor: blue;\n\t\ttext-align: center;\n\t\tmargin: 10px;\n\t}\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>\n\n<style>\n\t.greeting {\n\t\tcolor: blue;\n\t\ttext-align: center;\n\t\tmargin: 10px;\n\t}\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>\n\n<style>\n\t.greeting {\n\t\tcolor: blue;\n\t\ttext-align: center;\n\t\tmargin: 10px;\n\t}\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>\n\n<style>\n  .greeting {\n    color: blue;\n    text-align: center;\n    margin: 10px;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>\n\n<style>\n  .greeting {\n    color: blue;\n    text-align: center;\n    margin: 10px;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>\n\n<style>\n  .greeting {\n    color: blue;\n    text-align: center;\n    margin: 10px;\n  }\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>\n\n<style>\n\t.greeting {\n\t\tcolor: blue;\n\t\ttext-align: center;\n\t\tmargin: 10px;\n\t}\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<div data-testid=\"greeting\" class=\"greeting\">Hello, World!</div>\n\n<style>\n\t.greeting {\n\t\tcolor: blue;\n\t\ttext-align: center;\n\t\tmargin: 20px;\n\t}\n</style>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  },
  {
    "testName": "inspect",
    "provider": "Google",
    "modelId": "gemini-2.5-flash-preview-04-17",
    "numSamples": 10,
    "numCorrect": 0,
    "pass1": 0,
    "pass10": 0,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('Hello world');\n\n  // Basic inspect (will log the initial value and subsequent changes)\n  $inspect(text);\n\n  // Inspect with a custom callback\n  $inspect(text).with(value => {\n    console.log('Text updated via .with callback:', value);\n  });\n\n  // Effect that runs when text changes, demonstrating $inspect.trace()\n  $effect(() => {\n    console.log('Effect triggered by text change');\n    $inspect.trace(); // Trace the reactive dependency chain\n  });\n\n  // Derived value for character count\n  const charCount = $derived(text.length);\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <p data-testid=\"text-value\">Current text: {text}</p>\n  <p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "tmp/google/Component.svelte:17:4 `$inspect.trace(...)` must be the first statement of a function body\nhttps://svelte.dev/e/inspect_trace_invalid_placement"
        ],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('Hello world');\n\n  const charCount = $derived(text.length);\n\n  // Basic inspection\n  $inspect(text);\n\n  // Inspection with a custom callback\n  $inspect(text).with(value => console.log('Text updated to:', value));\n\n  // Trace inspection within an effect\n  $effect(() => {\n    // Access text to make the effect react to it\n    console.log('Effect reacting to text change. Tracing...');\n    $inspect.trace();\n  });\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <p data-testid=\"text-value\">Current text: {$state.raw(text)}</p>\n  <p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "tmp/google/Component.svelte:18:4 `$inspect.trace(...)` must be the first statement of a function body\nhttps://svelte.dev/e/inspect_trace_invalid_placement"
        ],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state(\"Hello world\");\n\n  // Basic $inspect to log the value\n  $inspect(text);\n\n  // Track updates with a custom label\n  $inspect(text).with('Input Text');\n\n  // $inspect.trace() inside an effect that runs when text changes\n  $effect(() => {\n    // This effect runs whenever 'text' changes\n    console.log('Text changed effect triggered');\n    $inspect.trace(); // Log trace information\n  });\n\n  // Derived value for character count\n  const charCount = $derived(text.length);\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <p data-testid=\"text-value\">Current text: {text}</p>\n  <p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "tmp/google/Component.svelte:16:4 `$inspect.trace(...)` must be the first statement of a function body\nhttps://svelte.dev/e/inspect_trace_invalid_placement"
        ],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state('Hello world');\n\n  // 2. Basic $inspect to log the input value\n  $inspect(text);\n\n  // 3. $inspect(...).with to track updates with a custom callback\n  $inspect(text).with((value) => {\n    console.log('Text updated via .with:', value);\n  });\n\n  // 4. $inspect.trace() inside an effect that runs when the input changes\n  $effect(() => {\n    // $inspect.trace(); // uncomment to see trace in console\n    console.log('Effect triggered by text change.');\n  });\n\n  // 5. Derived value for character count\n  const charCount = $derived(text.length);\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <p data-testid=\"text-value\">Current text: {text}</p>\n  <p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"Hello world\"\u001b[39m\nReceived:\n\u001b[31m  Current text: Hello world\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"Testing $inspect\"\u001b[39m\nReceived:\n\u001b[31m  Current text: Testing $inspect\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"!@#$%^&*()\"\u001b[39m\nReceived:\n\u001b[31m  Current text: !@#$%^&*()\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"\"\u001b[39m\nReceived:\n\u001b[31m  Current text:\u001b[39m"
        ],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<script>\n  import { $inspect } from 'svelte/internal'; // Assuming $inspect is internal or needs import for usage like this\n\n  let text = $state(\"Hello world\");\n\n  const charCount = $derived(text.length);\n\n  // Demonstrate basic $inspect\n  $inspect(text);\n\n  // Demonstrate $inspect with a custom callback\n  $inspect(text).with((value, prevValue) => {\n    console.log('Text updated:', value, '(previously:', prevValue, ')');\n  });\n\n  // Demonstrate $inspect.trace() within an effect\n  $effect(() => {\n    console.log('Text state changed, tracing reactivity:');\n    $inspect.trace();\n  });\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <p data-testid=\"text-value\">Current text: {text}</p>\n  <p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "tmp/google/Component.svelte:4:11 The $ prefix is reserved, and cannot be used for variables and imports\nhttps://svelte.dev/e/dollar_prefix_invalid"
        ],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<script>\n  import '$inspect';\n\n  let text = $state('Hello world');\n  const charCount = $derived(text.length);\n\n  // Basic inspect\n  $inspect(text);\n\n  // Inspect with custom callback\n  $inspect(text).with(value => console.log('Text updated via .with:', value));\n\n  // Inspect trace inside an effect\n  $effect(() => {\n    console.log('Text state changed:', text);\n    // This will log the reactivity trace leading to this effect run\n    $inspect.trace();\n  });\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value=\"{text}\" />\n  <p data-testid=\"text-value\">Current text: {text}</p>\n  <p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "tmp/google/Component.svelte:19:4 `$inspect.trace(...)` must be the first statement of a function body\nhttps://svelte.dev/e/inspect_trace_invalid_placement"
        ],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let text = $state(\"Hello world\");\n\n  // Basic $inspect to log the value\n  $inspect(text);\n\n  // $inspect.with to track updates with a custom callback\n  $inspect(text).with(() => {\n    console.log('$inspect.with: text updated:', text);\n  });\n\n  // $inspect.trace() inside an effect that runs when text changes\n  $effect(() => {\n    // Access text to ensure this effect reacts to changes in text\n    console.log('$effect: text value is now:', text);\n    // Trace the reactivity\n    $inspect.trace();\n  });\n\n  // Derived value for character count\n  const charCount = $derived(text.length);\n</script>\n\n<div>\n  <input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <p data-testid=\"text-value\">Current text: {text}</p>\n  <p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "tmp/google/Component.svelte:19:4 `$inspect.trace(...)` must be the first statement of a function body\nhttps://svelte.dev/e/inspect_trace_invalid_placement"
        ],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<script>\n  import { page } from '$app/state'; // Example import, not used in the task but good practice to show one exists\n\n  let text = $state('Hello world');\n  const charCount = $derived(text.length);\n\n  // 2. Basic $inspect\n  // This will log the value of text whenever it changes\n  const _ = $inspect(text);\n\n  // 3. $inspect(...).with\n  // This will log the value and details when text changes, using a custom callback\n  $inspect(text).with((value, changed) => {\n    console.log('$inspect.with callback:', value, changed);\n  });\n\n  // 4. $inspect.trace() inside an effect\n  // This effect runs when text changes and traces its dependencies\n  $effect(() => {\n    console.log('Effect running due to text change:', text);\n    // Trace the reactive dependencies that caused this effect to run\n    console.log('Tracing dependencies:');\n    $inspect.trace();\n    console.log('--- Trace End ---');\n  });\n\n</script>\n\n<div>\n  <label for=\"text-input\">Enter text:</label>\n  <input id=\"text-input\" data-testid=\"text-input\" type=\"text\" bind:value={text} />\n  <p data-testid=\"text-value\">Current text: {text}</p>\n  <p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "tmp/google/Component.svelte:25:4 `$inspect.trace(...)` must be the first statement of a function body\nhttps://svelte.dev/e/inspect_trace_invalid_placement"
        ],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<script>\n\timport { $state, $derived, $effect } from 'svelte/compiler'; // Runes are NOT imported. Correcting this.\n\n\tlet text = $state('Hello world');\n\tconst charCount = $derived(text.length);\n\n\t// Implement $inspect.trace() inside an effect -\n\t// The $inspect.trace rune is for the template.\n\t// Demonstrating an effect that runs when the input changes and shows tracking status.\n\t$effect(() => {\n\t\tconsole.log('Effect triggered by text change. Current text:', text);\n\t\tconsole.log('Effect tracking status:', $effect.tracking());\n\t});\n\n\t// The $inspect, $inspect(...).with, and $inspect.trace runes are used directly in the template.\n\t// They provide debugging information in the browser's developer tools.\n\n</script>\n\n<!-- Basic $inspect rune -->\n{@inspect text}\n\n<!-- $inspect rune with a custom callback for updates -->\n{@inspect text.with(value => console.log('Text updated via .with callback:', value))}\n\n<!-- $inspect.trace rune to show dependency tracking -->\n{@inspect.trace text}\n\n<div>\n\t<input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n\t<p data-testid=\"text-value\">Current text: {text}</p>\n\t<p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "tmp/google/Component.svelte:4:10 The $ prefix is reserved, and cannot be used for variables and imports\nhttps://svelte.dev/e/dollar_prefix_invalid"
        ],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet text = $state('Hello world');\n\tconst charCount = $derived(text.length);\n\n\t// Basic inspect\n\t$inspect(text);\n\n\t// Inspect with custom callback\n\t$inspect(text).with((value) => {\n\t\tconsole.log('Text updated via .with:', value);\n\t});\n\n\t// Inspect trace inside an effect\n\t$effect(() => {\n\t\t$inspect.trace();\n\t\tconsole.log('Effect triggered by text change');\n\t});\n</script>\n\n<div>\n\t<input data-testid=\"text-input\" type=\"text\" bind:value={text} />\n\t<p data-testid=\"text-value\">Current text: {text}</p>\n\t<p data-testid=\"char-count\">Character count: {charCount}</p>\n</div>",
        "success": false,
        "errors": [
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"Hello world\"\u001b[39m\nReceived:\n\u001b[31m  Current text: Hello world\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"Testing $inspect\"\u001b[39m\nReceived:\n\u001b[31m  Current text: Testing $inspect\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"!@#$%^&*()\"\u001b[39m\nReceived:\n\u001b[31m  Current text: !@#$%^&*()\u001b[39m",
          "\u001b[2mexpect(\u001b[22m\u001b[31melement\u001b[39m\u001b[2m).toHaveTextContent()\u001b[22m\n\nExpected element to have text content:\n\u001b[32m  Current text: \"\"\u001b[39m\nReceived:\n\u001b[31m  Current text:\u001b[39m"
        ],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  },
  {
    "testName": "props",
    "provider": "Google",
    "modelId": "gemini-2.5-flash-preview-04-17",
    "numSamples": 10,
    "numCorrect": 10,
    "pass1": 1,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let { name = \"World\", count = 0, showDetails = false } = $props();\n\n  let reactiveCount = $state(count);\n\n  function increment() {\n    reactiveCount++;\n  }\n</script>\n\n<div>\n  <h1 data-testid=\"name-display\">Hello, {name}!</h1>\n  <p data-testid=\"count-display\">Count: {reactiveCount}</p>\n  <button onclick={increment} data-testid=\"increment-button\">Increment</button>\n\n  {#if showDetails}\n    <div data-testid=\"details\">\n      <p>Name is {name}</p>\n      <p>Count is {count}</p>\n      <p>ShowDetails is {showDetails}</p>\n    </div>\n  {/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let {\n    name = \"World\",\n    count: initialCount = 0,\n    showDetails = false\n  } = $props();\n\n  let currentCount = $state(initialCount);\n\n  function increment() {\n    currentCount++;\n  }\n</script>\n\n<div>\n  <h1 data-testid=\"name-display\">Hello, {name}!</h1>\n  <p data-testid=\"count-display\">Count: {currentCount}</p>\n  <button onclick={increment} data-testid=\"increment-button\">Increment</button>\n\n  {#if showDetails}\n    <div data-testid=\"details\">\n      <p>Name is {name}</p>\n      <p>Count is {currentCount}</p>\n      <p>ShowDetails is {showDetails}</p>\n    </div>\n  {/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let { name = \"World\", count = 0, showDetails = false } = $props();\n\n  let reactiveCount = $state(count);\n\n  function increment() {\n    reactiveCount++;\n  }\n</script>\n\n<div>\n  <h1 data-testid=\"name-display\">Hello, {name}!</h1>\n  <p data-testid=\"count-display\">Count: {reactiveCount}</p>\n  <button onclick={increment} data-testid=\"increment-button\">Increment</button>\n\n  {#if showDetails}\n    <div data-testid=\"details\">\n      <p>Name is {name}</p>\n      <p>Initial Count is {count}</p>\n      <p>ShowDetails is {showDetails}</p>\n    </div>\n  {/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet { name = 'World', count = 0, showDetails = false } = $props();\n\n\tlet localCount = $state(count);\n\n\tfunction increment() {\n\t\tlocalCount++;\n\t}\n</script>\n\n<div>\n\t<h1 data-testid=\"name-display\">Hello, {name}!</h1>\n\t<p data-testid=\"count-display\">Count: {localCount}</p>\n\t<button onclick={increment} data-testid=\"increment-button\">Increment</button>\n\n\t{#if showDetails}\n\t\t<div data-testid=\"details\">\n\t\t\t<p>Name is {name}</p>\n\t\t\t<p>Count is {localCount}</p>\n\t\t\t<p>ShowDetails is {showDetails}</p>\n\t\t</div>\n\t{/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let { name = \"World\", count = 0, showDetails = false } = $props();\n\n  let currentCount = $state(count);\n\n  function incrementCount() {\n    currentCount++;\n  }\n</script>\n\n<div>\n  <h1 data-testid=\"name-display\">Hello, {name}!</h1>\n  <p data-testid=\"count-display\">Count: {currentCount}</p>\n  <button data-testid=\"increment-button\" onclick={incrementCount}>Increment</button>\n\n  {#if showDetails}\n  <div data-testid=\"details\">\n    <p>Name is {name}</p>\n    <p>Count is {count}</p>\n    <p>ShowDetails is {showDetails}</p>\n  </div>\n  {/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let { name = \"World\", count: initialCount = 0, showDetails = false } = $props();\n\n  let count = $state(initialCount);\n\n  function increment() {\n    count++;\n  }\n</script>\n\n<div>\n  <h1 data-testid=\"name-display\">Hello, {name}!</h1>\n  <p data-testid=\"count-display\">Count: {count}</p>\n  <button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n\n  {#if showDetails}\n    <div data-testid=\"details\">\n      <p>Name is {name}</p>\n      <p>Count is {count}</p>\n      <p>ShowDetails is {showDetails}</p>\n    </div>\n  {/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let { name = 'World', count = 0, showDetails = false } = $props();\n\n  let localCount = $state(count);\n\n  function increment() {\n    localCount++;\n  }\n</script>\n\n<div>\n  <h1 data-testid=\"name-display\">Hello, {name}!</h1>\n  <p data-testid=\"count-display\">Count: {localCount}</p>\n  <button onclick={increment} data-testid=\"increment-button\">Increment</button>\n\n  {#if showDetails}\n    <div data-testid=\"details\">\n      <p>Name is {name}</p>\n      <p>Count is {count}</p>\n      <p>ShowDetails is {showDetails}</p>\n    </div>\n  {/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet { name = 'World', count = 0, showDetails = false } = $props();\n\n\tlet localCount = $state(count);\n\n\tfunction increment() {\n\t\tlocalCount++;\n\t}\n</script>\n\n<div>\n\t<h1 data-testid=\"name-display\">Hello, {name}!</h1>\n\t<p data-testid=\"count-display\">Count: {localCount}</p>\n\t<button data-testid=\"increment-button\" onclick={increment}>Increment</button>\n\n\t{#if showDetails}\n\t\t<div data-testid=\"details\">\n\t\t\t<p>Name is {name}</p>\n\t\t\t<p>Count is {count}</p>\n\t\t\t<p>ShowDetails is {showDetails}</p>\n\t\t</div>\n\t{/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let { name = 'World', count = 0, showDetails = false } = $props();\n  let internalCount = $state(count);\n</script>\n\n<div>\n  <h1 data-testid=\"name-display\">Hello, {name}!</h1>\n  <p data-testid=\"count-display\">Count: {internalCount}</p>\n  <button data-testid=\"increment-button\" onclick={() => internalCount++}>Increment</button>\n\n  {#if showDetails}\n    <div data-testid=\"details\">\n      <p>Name is {name}</p>\n      <p>Initial Count is {count}</p>\n      <p>ShowDetails is {showDetails}</p>\n    </div>\n  {/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tlet { name = 'World', count = 0, showDetails = false } = $props();\n\n\t// Use $state for the internal count that can be updated\n\tlet internalCount = $state(count);\n\n\tfunction increment() {\n\t\tinternalCount++;\n\t}\n</script>\n\n<div>\n\t<h1 data-testid=\"name-display\">Hello, {name}!</h1>\n\t<p data-testid=\"count-display\">Count: {internalCount}</p>\n\t<button onclick={increment} data-testid=\"increment-button\">Increment</button>\n\n\t{#if showDetails}\n\t\t<div data-testid=\"details\">\n\t\t\t<p>Name is {name}</p>\n\t\t\t<p>Count is {internalCount}</p>\n\t\t\t<p>ShowDetails is {showDetails}</p>\n\t\t</div>\n\t{/if}\n</div>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  },
  {
    "testName": "snippets",
    "provider": "Google",
    "modelId": "gemini-2.5-flash-preview-04-17",
    "numSamples": 10,
    "numCorrect": 9,
    "pass1": 0.9,
    "pass10": 1,
    "context": {
      "used": true,
      "content": "<SYSTEM>This is the abridged developer documentation for Svelte and SvelteKit.</SYSTEM>\n\n# Svelte documentation\n\n## Svelte\n\nYou **MUST** use the Svelte 5 API unless explicitly tasked to write Svelte 4 syntax. If you don't know about the API yet, below is the most important information about it. Other syntax not explicitly listed like `{#if ...}` blocks stay the same, so you can reuse your Svelte 4 knowledge for these.\n\n- to mark something a state you use the `$state` rune, e.g. instead of `let count = 0` you do `let count = $state(0)`\n- to mark something as a derivation you use the `$derived` rune, e.g. instead of `$: double = count * 2` you do `const double = $derived(count * 2)`\n- to create a side effect you use the `$effect` rune, e.g. instead of `$: console.log(double)`you do`$effect(() => console.log(double))`\n- to create component props you use the `$props` rune, e.g. instead of `export let foo = true; export let bar;` you do `let { foo = true, bar } = $props();`\n- when listening to dom events do not use colons as part of the event name anymore, e.g. instead of `<button on:click={...} />` you do `<button onclick={...} />`\n\n### What are runes?\n\n- Runes are built-in Svelte keywords (prefixed with `$`) that control the compiler. For example, you write `let message = $state('hello');` in a `.svelte` file.\n- Do **NOT** treat runes like regular functions or import them; instead, use them as language keywords.  \n  _In Svelte 4, this syntax did not exist—you relied on reactive declarations and stores; now runes are an integral part of the language._\n\n### $state\n\n- `$state` creates reactive variables that update the UI automatically. For example:\n  ```svelte\n  <script>\n    let count = $state(0);\n  </script>\n  <button onclick={() => count++}>Clicked: {count}</button>\n  ```\n- Do **NOT** complicate state management by wrapping it in custom objects; instead, update reactive variables directly.  \n  _In Svelte 4, you created state with let, e.g. `let count = 0;`, now use the $state rune, e.g. `let count = $state(0);`._\n- Arrays and objects become deeply reactive proxies. For example:\n  ```js\n  let todos = $state([{ done: false, text: 'add more todos' }]);\n  todos[0].done = !todos[0].done;\n  ```\n- Do **NOT** destructure reactive proxies (e.g., `let { done } = todos[0];`), as this breaks reactivity; instead, access properties directly.\n- Use `$state` in class fields for reactive properties. For example:\n  ```js\n  class Todo {\n  \tdone = $state(false);\n  \ttext = $state('');\n  \treset = () => {\n  \t\tthis.text = '';\n  \t\tthis.done = false;\n  \t};\n  }\n  ```\n\n### $state.raw\n\n- `$state.raw` creates shallow state where mutations are not tracked. For example:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\n// Instead of mutating:\n// person.age += 1;  // NO effect\nperson = { name: 'Heraclitus', age: 50 }; // Correct way to update\n```\n\n- Do **NOT** attempt to mutate properties on raw state; instead, reassign the entire object to trigger updates.\n\n### $state.snapshot\n\n- `$state.snapshot` produces a plain object copy of reactive state. For example:\n\n```svelte\n<script>\n  let counter = $state({ count: 0 });\n  function logSnapshot() {\n    console.log($state.snapshot(counter));\n  }\n</script>\n```\n\n- **ONLY** use this if you are told there's a problem with passing reactive proxies to external APIs.\n\n### Passing state into functions\n\n- Pass-by-Value Semantics: Use getter functions to ensure functions access the current value of reactive state. For example:\n  ```js\n  function add(getA, getB) {\n  \treturn () => getA() + getB();\n  }\n  let a = 1,\n  \tb = 2;\n  let total = add(\n  \t() => a,\n  \t() => b\n  );\n  console.log(total());\n  ```\n- Do **NOT** assume that passing a reactive state variable directly maintains live updates; instead, pass getter functions.  \n  _In Svelte 4, you often used stores with subscribe methods; now prefer getter functions with `$state` / `$derived` instead._\n\n### $derived\n\n- `$derived` computes reactive values based on dependencies. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  let doubled = $derived(count * 2);\n</script>\n<button onclick={() => count++}>{doubled}</button>\n```\n\n- Do **NOT** introduce side effects in derived expressions; instead, keep them pure.  \n  _In Svelte 4 you used `$:` for this, e.g. `$: doubled = count * 2;`, now use the $derived rune instead, e.g `let doubled = $derived(count * 2);`._\n\n#### $derived.by\n\n- Use `$derived.by` for multi-line or complex logic. For example:\n\n```svelte\n<script>\n  let numbers = $state([1, 2, 3]);\n  let total = $derived.by(() => {\n    let sum = 0;\n    for (const n of numbers) sum += n;\n    return sum;\n  });\n</script>\n```\n\n- Do **NOT** force complex logic into a single expression; instead, use `$derived.by` to keep code clear.\n\n#### Overriding derived values\n\n- You can reassign a derived value for features like optimistic UI. It will go back to the `$derived` value once an update in its dependencies happen. For example:\n\n```svelte\n<script>\n  let post = $props().post;\n  let likes = $derived(post.likes);\n  async function onclick() {\n    likes += 1;\n    try { await post.like(); } catch { likes -= 1; }\n  }\n</script>\n```\n\n- Do **NOT** try to override derived state via effects; instead, reassign directly when needed.  \n  _In Svelte 4 you could use `$:` for that, e.g. `$: likes = post.likes; likes = 1`, now use the `$derived` instead, e.g. `let likes = $derived(post.likes); likes = 1;`._\n\n### $effect\n\n- `$effect` executes functions when reactive state changes. For example:\n\n```svelte\n<script>\n  let size = $state(50);\n  $effect(() => {\n    console.log('Size changed:', size);\n  });\n</script>\n```\n\n- Do **NOT** use `$effect` for state synchronization; instead, use it only for side effects like logging or DOM manipulation.  \n  _In Svelte 4, you used reactive statements (`$:`) for similar tasks, .e.g `$: console.log(size)`; now use the `$effect` rune instead, e.g. `$effect(() => console.log(size))` ._\n\n#### Understanding lifecycle (for $effect)\n\n- Effects run after the DOM updates and can return teardown functions. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  $effect(() => {\n    const interval = setInterval(() => { count += 1; }, 1000);\n    return () => clearInterval(interval);\n  });\n</script>\n```\n\n- **Directive:** Do **NOT** ignore cleanup; instead, always return a teardown function when needed.\n\n#### $effect.pre\n\n- `$effect.pre` works like `$effect` with the only difference that it runs before the DOM updates. For example:\n\n```svelte\n<script>\n  let div = $state();\n  $effect.pre(() => {\n    if (div) console.log('Running before DOM update');\n  });\n</script>\n```\n\n- Do **NOT** use `$effect.pre` for standard post-update tasks; instead, reserve it for pre-DOM manipulation like autoscrolling.\n\n#### $effect.tracking\n\n- `$effect.tracking` indicates if code is running inside a reactive context. For example:\n\n```svelte\n<script>\n  $effect(() => {\n    console.log('Inside effect, tracking:', $effect.tracking());\n  });\n</script>\n```\n\n- Do **NOT** misuse tracking information outside its intended debugging context; instead, use it to enhance reactive debugging.  \n  _In Svelte 4, no equivalent existed; now this feature offers greater insight into reactivity._\n\n#### $effect.root\n\n- `$effect.root` creates a non-tracked scope for nested effects with manual cleanup. For example:\n\n```svelte\n<script>\n  let count = $state(0);\n  const cleanup = $effect.root(() => {\n    $effect(() => {\n      console.log('Count is:', count);\n    });\n    return () => console.log('Root effect cleaned up');\n  });\n</script>\n```\n\n- Do **NOT** expect root effects to auto-cleanup; instead, manage their teardown manually.  \n  _In Svelte 4, manual cleanup required explicit lifecycle hooks; now `$effect.root` centralizes this control._\n\n### $props\n\n- Use `$props` to access component inputs. For example:\n\n```svelte\n<script>\n  let { adjective } = $props();\n</script>\n<p>This component is {adjective}</p>\n```\n\n- Do **NOT** mutate props directly; instead, use callbacks or bindable props to communicate changes.  \n  _In Svelte 4, props were declared with `export let foo`; now you use `$props` rune, e.g. `let { foo } = $props()`._\n- Declare fallback values via destructuring. For example:\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n- Rename props to avoid reserved keywords. For example:\n\n```js\nlet { super: trouper } = $props();\n```\n\n- Use rest syntax to collect all remaining props. For example:\n\n```js\nlet { a, b, ...others } = $props();\n```\n\n#### $props.id()\n\n- Generate a unique ID for the component instance. For example:\n\n```svelte\n<script>\n  const uid = $props.id();\n</script>\n<label for=\"{uid}-firstname\">First Name:</label>\n<input id=\"{uid}-firstname\" type=\"text\" />\n```\n\n- Do **NOT** manually generate or guess IDs; instead, rely on `$props.id()` for consistency.\n\n### $bindable\n\n- Mark props as bindable to allow two-way data flow. For example, in `FancyInput.svelte`:\n\n```svelte\n<script>\n  let { value = $bindable() } = $props();\n</script>\n<input bind:value={value} />\n```\n\n- Do **NOT** overuse bindable props; instead, default to one-way data flow unless bi-directionality is truly needed.  \n  _In Svelte 4, all props were implicitly bindable; in Svelte 5 `$bindable` makes this explicit._\n\n### $host\n\n- Only available inside custom elements. Access the host element for custom event dispatching. For example:\n\n```svelte\n<script>\n  function dispatch(type) {\n    $host().dispatchEvent(new CustomEvent(type));\n  }\n</script>\n<button onclick={() => dispatch('increment')}>Increment</button>\n```\n\n- Do **NOT** use this unless you are explicitly tasked to create a custom element using Svelte components\n\n### {#snippet ...}\n\n- **Definition & Usage:**  \n  Snippets allow you to define reusable chunks of markup with parameters inside your component.  \n  _Example:_\n  ```svelte\n  {#snippet figure(image)}\n    <figure>\n      <img src={image.src} alt={image.caption} width={image.width} height={image.height} />\n      <figcaption>{image.caption}</figcaption>\n    </figure>\n  {/snippet}\n  ```\n- **Parameterization:**  \n  Snippets accept multiple parameters with optional defaults and destructuring, but rest parameters are not allowed.  \n  _Example with parameters:_\n  ```svelte\n  {#snippet name(param1, param2)}\n    <!-- snippet markup here -->\n  {/snippet}\n  ```\n\n### Snippet scope\n\n- **Lexical Visibility:**  \n  Snippets can be declared anywhere and reference variables from their outer lexical scope, including script or block-level declarations.  \n  _Example:_\n  ```svelte\n  <script>\n    let { message = \"it's great to see you!\" } = $props();\n  </script>\n  {#snippet hello(name)}\n    <p>hello {name}! {message}!</p>\n  {/snippet}\n  {@render hello('alice')}\n  ```\n- **Scope Limitations:**  \n  Snippets are only accessible within their lexical scope; siblings and child blocks share scope, but nested snippets cannot be rendered outside.  \n  _Usage caution:_ Do **NOT** attempt to render a snippet outside its declared scope.\n\n### Passing snippets to components\n\n- **As Props:**  \n  Within a template, snippets are first-class values that can be passed to components as props.  \n  _Example:_\n  ```svelte\n  <script>\n    import Table from './Table.svelte';\n    const fruits = [\n      { name: 'apples', qty: 5, price: 2 },\n      { name: 'bananas', qty: 10, price: 1 }\n    ];\n  </script>\n  {#snippet header()}\n    <th>fruit</th>\n    <th>qty</th>\n    <th>price</th>\n    <th>total</th>\n  {/snippet}\n  {#snippet row(d)}\n    <td>{d.name}</td>\n    <td>{d.qty}</td>\n    <td>{d.price}</td>\n    <td>{d.qty * d.price}</td>\n  {/snippet}\n  <Table data={fruits} {header} {row} />\n  ```\n- **Slot-like Behavior:**  \n  Snippets declared inside component tags become implicit props (akin to slots) for the component.  \n  _Svelte 4 used slots for this, e.g. `<Component><p slot=\"x\" let:y>hi {y}</p></Component>`; now use snippets instead, e.g. `<Component>{#snippet x(y)}<p>hi {y}</p>{/snippet}</Component>`._\n- **Content Fallback:**  \n  Content not wrapped in a snippet declaration becomes the `children` snippet, rendering as fallback content.  \n  _Example:_\n  ```svelte\n  <!-- App.svelte -->\n  <Button>click me</Button>\n  <!-- Button.svelte -->\n  <script>\n    let { children } = $props();\n  </script>\n  <button>{@render children()}</button>\n  ```\n\n### Typing snippets\n\n- Snippets implement the `Snippet` interface, enabling strict type checking in TypeScript or JSDoc.  \n  _Example:_\n\n```svelte\n<script lang=\"ts\">\n  import type { Snippet } from 'svelte';\n  interface Props {\n    data: any[];\n    children: Snippet;\n    row: Snippet<[any]>;\n  }\n  let { data, children, row }: Props = $props();\n</script>\n```\n\n### {@render ...}\n\n- Use the {@render ...} tag to invoke and render a snippet, passing parameters as needed.  \n  _Example:_\n  ```svelte\n  {#snippet sum(a, b)}\n    <p>{a} + {b} = {a + b}</p>\n  {/snippet}\n  {@render sum(1, 2)}\n  ```\n- Do **NOT** call snippets without parentheses when parameters are required; instead, always invoke the snippet correctly.  \n  _In Svelte 4, you used slots for this, e.g. `<slot name=\"sum\" {a} {b} />`; now use `{@render}` instead, e.g. `{@render sum(a,b)}`._\n\n### <svelte:boundary>\n\n- Use error boundary tags to prevent rendering errors in a section from crashing the whole app.\n  _Example:_\n\n  ```svelte\n  <svelte:boundary onerror={(error, reset) => console.error(error)}>\n    <FlakyComponent />\n  </svelte:boundary>\n  ```\n\n- **Failed Snippet for Fallback UI:**  \n  Providing a `failed` snippet renders fallback content when an error occurs and supplies a `reset` function.  \n  _Example:_\n\n  ```svelte\n  <svelte:boundary>\n    <FlakyComponent />\n    {#snippet failed(error, reset)}\n      <button onclick={reset}>Oops! Try again</button>\n    {/snippet}\n  </svelte:boundary>\n  ```\n\n### class\n\n- Svelte 5 allows objects for conditional class assignment using truthy keys. It closely follows the `clsx` syntax  \n  _Example:_\n\n```svelte\n<script>\n  let { cool } = $props();\n</script>\n<div class={{ cool, lame: !cool }}>Content</div>\n```\n\n\n# SvelteKit documentation\n\n## Project types\n\nSvelteKit supports all rendering modes: SPA, SSR, SSG, and you can mix them within one project.\n\n## Setup\n\nScaffold a new SvelteKit project using `npx sv create` then follow the instructions. Do NOT use `npm create svelte` anymore, this command is deprecated.\n\nA SvelteKit project needs a `package.json` with the following contents at minimum:\n\n```json\n{\n\t\"devDependencies\": {\n\t\t\"@sveltejs/adapter-auto\": \"^6.0.0\",\n\t\t\"@sveltejs/kit\": \"^2.0.0\",\n\t\t\"@sveltejs/vite-plugin-svelte\": \"^5.0.0\",\n\t\t\"svelte\": \"^5.0.0\",\n\t\t\"vite\": \"^6.0.0\"\n\t}\n}\n```\n\nDo NOT put any of the `devDependencies` listed above into `dependencies`, keep them all in `devDependencies`.\n\nIt also needs a `vite.config.js` with the following at minimum:\n\n```js\nimport { defineConfig } from 'vite';\nimport { sveltekit } from '@sveltejs/kit/vite';\n\nexport default defineConfig({\n\tplugins: [sveltekit()]\n});\n```\n\nIt also needs a `svelte.config.js` with the following at minimum:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nexport default {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n```\n\n## Project structure\n\n- **`src/` directory:**\n  - `lib/` for shared code (`$lib`), `lib/server/` for server‑only modules (`$lib/server`), `params/` for matchers, `routes/` for your pages/components, plus `app.html`, `error.html`, `hooks.client.js`, `hooks.server.js`, and `service-worker.js`.\n  - Do **NOT** import server‑only code into client files\n- **Top‑level assets & configs:**\n  - `static/` for public assets; `tests/` (if using Playwright); config files: `package.json` (with `@sveltejs/kit`, `svelte`, `vite` as devDeps), `svelte.config.js`, `tsconfig.json` (or `jsconfig.json`, extending `.svelte-kit/tsconfig.json`), and `vite.config.js`.\n  - Do **NOT** forget `\"type\": \"module\"` in `package.json` if using ESM.\n- **Build artifacts:**\n  - `.svelte-kit/` is auto‑generated and safe to ignore or delete; it will be recreated on `dev`/`build`.\n  - Do **NOT** commit `.svelte-kit/` to version control.\n\n## Routing\n\n- **Filesystem router:** `src/routes` maps directories to URL paths: Everything with a `+page.svelte` file inside it becomes a visitable URL, e.g. `src/routes/hello/+page.svelte` becomes `/hello`. `[param]` folders define dynamic segments. Do NOT use other file system router conventions, e.g. `src/routes/hello.svelte` does NOT become available als URL `/hello`\n- **Route files:** Prefix with `+`: all run server‑side; only non‑`+server` run client‑side; `+layout`/`+error` apply recursively.\n- **Best practice:** Do **not** hard‑code routes in code; instead rely on the filesystem convention.\n\n### +page.svelte\n\n- Defines UI for a route, SSR on first load and CSR thereafter\n- Do **not** fetch data inside the component; instead use a `+page.js` or `+page.server.js` `load` function; access its return value through `data` prop via `let { data } = $props()` (typed with `PageProps`).\n\n```svelte\n<script lang=\"ts\">\n  import type { PageProps } from './$types';\n  let { data }: PageProps = $props();\n</script>\n<h1>{data.title}</h1>\n```\n\n### +page.js\n\n- Load data for pages via `export function load({ params })` (typed `PageLoad`), return value is put into `data` prop in component\n- Can export `prerender`, `ssr`, and `csr` consts here to influence how page is rendered.\n- Do **not** include private logic (DB or env vars), can **not** export `actions` from here; if needed, use `+page.server.js`.\n\n```js\nimport type { PageLoad } from './$types';\n\nexport const load: PageLoad = () => {\n  return {\n    title: 'Hello world!',\n  };\n}\n```\n\n### +page.server.js\n\n- `export async function load(...)` (typed `PageServerLoad`) to access databases or private env; return serializable data.\n- Can also export `actions` for `<form>` handling on the server.\n\n### +error.svelte\n\n- Add `+error.svelte` in a route folder to render an error page, can use `page.status` and `page.error.message` from `$app/state`.\n- SvelteKit walks up routes to find the closest boundary; falls back to `src/error.html` if none.\n\n### +layout.svelte\n\n- Place persistent elements (nav, footer) and include `{@render children()}` to render page content. Example:\n\n```svelte\n<script>\n    import { LayoutProps } from './$types';\n    let { children, data } = $props();\n</script>\n\n<p>Some Content that is shared for all pages below this layout</p>\n<!-- child layouts/page goes here -->\n{@render children()}\n```\n\n- Create subdirectory `+layout.svelte` to scope UI to nested routes, inheriting parent layouts.\n- Use layouts to avoid repeating common markup; do **not** duplicate UI in every `+page.svelte`.\n\n### +layout.js / +layout.server.js\n\n- In `+layout.js` or `+layout.server.js` export `load()` (typed `LayoutLoad`) to supply `data` to the layout and its children; set `prerender`, `ssr`, `csr`.\n- Use `+layout.server.js` (typed `LayoutServerLoad`) for server-only things like DB or env access.\n- Do **not** perform server‑only operations in `+layout.js`; use the server variant.\n\n```js\nimport type { LayoutLoad } from './$types';\n\nexport const load: LayoutLoad = () => {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\n### +server.js (Endpoints)\n\n- Export HTTP handlers (`GET`, `POST`, etc.) in `+server.js` under `src/routes`; receive `RequestEvent`, return `Response` or use `json()`, `error()`, `redirect()` (exported from `@sveltejs/kit`).\n- export `fallback` to catch all other methods.\n\n```js\nimport type { RequestHandler } from './$types';\n\nexport const GET: RequestHandler = ({ url }) => {\n\treturn new Response('hello world');\n}\n```\n\n### $types\n\n- SvelteKit creates `$types.d.ts` with `PageProps`, `LayoutProps`, `RequestHandler`, `PageLoad`, etc., for type‑safe props and loaders.\n- Use them inside `+page.svelte`/`+page.server.js`/`+page.js`/`+layout.svelte`/`+layout.server.js`/`+layout.js` by importing from `./$types`\n\n### Other files\n\n- Any non‑`+` files in route folders are ignored by the router, use this to your advantage to colocate utilities or components.\n- For cross‑route imports, place modules under `src/lib` and import via `$lib`.\n\n## Loading data\n\n### Page data\n\n- `+page.js` exports a `load` (`PageLoad`) whose returned object is available in `+page.svelte` via `let { data } = $props()` (e.g. when you do `return { foo }` from `load` it is available within `let { data } = $props()` in `+page.svelte` as `data.foo`)\n- Universal loads run on SSR and CSR; private or DB‑backed loads belong in `+page.server.js` (`PageServerLoad`) and must return devalue‑serializable data.\n\nExample:\n\n```js\n// file: src/routes/foo/+page.js\nexport async function load({ fetch }) {\n\tconst result = await fetch('/data/from/somewhere').then((r) => r.json());\n\treturn { result }; // return property \"result\"\n}\n```\n\n```svelte\n<!-- file: src/routes/foo/+page.svelte -->\n<script>\n  // \"data\" prop contains property \"result\"\n  let { data } = $props();\n</script>\n{data.result}\n```\n\n### Layout data\n\n- `+layout.js` or `+layout.server.js` exports a `load` (`LayoutLoad`/`LayoutServerLoad`)\n- Layout data flows downward: child layouts and pages see parent data in their `data` prop.\n- Data loading flow (interaction of load function and props) works the same as for `+page(.server).js/svelte`\n\n### page.data\n\n- The `page` object from `$app/state` gives access to all data from `load` functions via `page.data`, usable in any layout or page.\n- Ideal for things like `<svelte:head><title>{page.data.title}</title></svelte:head>`.\n- Types come from `App.PageData`\n- earlier Svelte versions used `$app/stores` for the same concepts, do NOT use `$app/stores` anymore unless prompted to do so\n\n### Universal vs. server loads\n\n- Universal (`+*.js`) run on server first, then in browser; server (`+*.server.js`) always run server‑side and can use secrets, cookies, DB, etc.\n- Both receive `params`, `route`, `url`, `fetch`, `setHeaders`, `parent`, `depends`; server loads additionally get `cookies`, `locals`, `platform`, `request`.\n- Use server loads for private data or non‑serializable items; universal loads for public APIs or returning complex values (like constructors).\n\n### Load function arguments\n\n- `url` is a `URL` object (no `hash` server‑side); `route.id` shows the route pattern; `params` map path segments to values.\n- Query parameters via `url.searchParams` trigger reruns when they change.\n- Use these to branch logic and fetch appropriate data in `load`.\n\n## Making Fetch Requests\n\nUse the provided `fetch` function for enhanced features:\n\n```js\n// src/routes/items/[id]/+page.js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\treturn { item };\n}\n```\n\n## Headers and Cookies\n\nSet response headers using `setHeaders`:\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch(url);\n\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nAccess cookies in server load functions using `cookies`:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nDo not set `set-cookie` via `setHeaders`; use `cookies.set()` instead.\n\n## Using Parent Data\n\nAccess data from parent load functions:\n\n```js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n## Errors and Redirects\n\nRedirect users using `redirect`:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\nThrow expected errors using `error`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUnexpected exceptions trigger `handleError` hook and a 500 response.\n\n## Streaming with Promises\n\nServer load functions can stream promises as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\n```svelte\n<h1>{data.post.title}</h1>\n<div>{@html data.post.content}</div>\n\n{#await data.comments}\n  Loading comments...\n{:then comments}\n  {#each comments as comment}\n    <p>{comment.content}</p>\n  {/each}\n{:catch error}\n  <p>error loading comments: {error.message}</p>\n{/await}\n```\n\n## Rerunning Load Functions\n\nLoad functions rerun when:\n\n- Referenced params or URL properties change\n- A parent load function reran and `await parent()` was called\n- A dependency was invalidated with `invalidate(url)` or `invalidateAll()`\n\nManually invalidate load functions:\n\n```js\n// In load function\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\t// ...\n}\n\n// In component\nimport { invalidate } from '$app/navigation';\nfunction rerunLoadFunction() {\n\tinvalidate('app:random');\n}\n```\n\n## Dependency Tracking\n\nExclude from dependency tracking with `untrack`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Implications for authentication\n\n- Layout loads don’t automatically rerun on CSR; guards in `+layout.server.js` require child pages to await the parent.\n- To avoid missed auth checks and waterfalls, use hooks like `handle` for global protection or per‑page server loads.\n\n### Using getRequestEvent\n\n- `getRequestEvent()` retrieves the current server `RequestEvent`, letting shared functions (e.g. `requireLogin()`) access `locals`, `url`, etc., without parameter passing.\n\n## Using forms\n\n### Form actions\n\n- A `+page.server.js` can export `export const actions: Actions = { default: async (event) => {…} }`; `<form method=\"POST\">` in `+page.svelte` posts to the default action without any JS. `+page.js` or `+layout.js` or `+layout.server.js` can NOT export `actions`\n- Name multiple actions (`login`, `register`) in `actions`, invoke with `action=\"?/register\"` or `button formaction=\"?/register\"`; do NOT use `default` name in this case.\n- Each action gets `{ request, cookies, params }`, uses `await request.formData()`, sets cookies or DB state, and returns an object that appears on the page as `form` (typed via `PageProps`).\n\nExample: Define a default action in `+page.server.js`:\n\n```js\n// file: src/routes/login/+page.server.js\nimport type { Actions } from './$types';\n\nexport const actions: Actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nUse it with a simple form:\n\n```svelte\n<!-- file: src/routes/login/+page.svelte -->\n<form method=\"POST\">\n\t<label>\n\t\tEmail\n\t\t<input name=\"email\" type=\"email\">\n\t</label>\n\t<label>\n\t\tPassword\n\t\t<input name=\"password\" type=\"password\">\n\t</label>\n\t<button>Log in</button>\n</form>\n```\n\n### Validation errors\n\n- Return `fail(400, { field, error: true })` from an action to send back status and data; display via `form?.field` and repopulate inputs with `value={form?.field ?? ''}`.\n- Use `fail` instead of throwing so the nearest `+error.svelte` isn’t invoked and the user can correct their input.\n- `fail` payload must be JSON‑serializable.\n\n### Redirects\n\n- In an action, call `redirect(status, location)` to send a 3xx redirect; this throws and bypasses form re-render.\n- Client-side, use `goto()` from `$app/navigation` for programmatic redirects.\n\n### Loading data after actions\n\n- After an action completes (unless redirected), SvelteKit reruns `load` functions and re‑renders the page, merging the action’s return value into `form`.\n- The `handle` hook runs once before the action; if you modify cookies in your action, you must also update `event.locals` there to keep `load` in sync.\n- Do NOT assume `locals` persists automatically; set `event.locals` inside your action when auth state changes.\n\n### Progressive enhancement\n\n- Apply `use:enhance` from `$app/forms` to `<form>` to intercept submissions, prevent full reloads, update `form`, `page.form`, `page.status`, reset the form, invalidate all data, handle redirects, render errors, and restore focus. Do NOT use onsubmit event for progressive enhancement\n- To customize, provide a callback that runs before submit and returns a handler; use `update()` for default logic or `applyAction(result)` to apply form data without full invalidation.\n- You can also write your own `onsubmit` listener using `fetch`, then `deserialize` the response and `applyAction`/`invalidateAll`; do NOT use `JSON.parse` for action responses.\n\n```svelte\n<script>\n  import type { PageProps } from './$types';\n\timport { enhance } from '$app/forms';\n\tlet { form } = $props();\n</script>\n\n<form method=\"POST\" use:enhance>\n\t<!-- form content -->\n</form>\n```\n\n## Page options\n\n#### prerender\n\n- Set `export const prerender = true|false|'auto'` in page or layout modules; `true` generates static HTML, `false` skips, `'auto'` includes in SSR manifest.\n- Applies to pages **and** `+server.js` routes (inherit parent flags); dynamic routes need `entries()` or `config.kit.prerender.entries` to tell the crawler which parameter values to use.\n- Do NOT prerender pages that use form actions or rely on `url.searchParams` server‑side.\n\n#### entries\n\n- In a dynamic route’s `+page(.server).js` or `+server.js`, export `export function entries(): Array<Record<string,string>>` (can be async) to list parameter sets for prerendering.\n- Overrides default crawling to ensure dynamic pages (e.g. `/blog/[slug]`) are generated.\n- Do NOT forget to pair `entries()` with `export const prerender = true`.\n\n### ssr\n\n- `export const ssr = false` disables server-side rendering, sending only an HTML shell and turning the page into a client-only SPA.\n- Use sparingly (e.g. when using browser‑only globals); do NOT set both `ssr` and `csr` to `false` or nothing will render.\n\n#### csr\n\n- `export const csr = false` prevents hydration, omits JS bundle, disables `<script>`s, form enhancements, client routing, and HMR.\n- Ideal for purely static pages (e.g. marketing or blog posts); do NOT disable CSR on pages requiring interactivity.\n\n## State management\n\n- Avoid shared server variables—servers are stateless and shared across users. Authenticate via cookies and persist to a database instead of writing to in‑memory globals.\n- Keep `load` functions pure: no side‑effects or global store writes. Return data from `load` and pass it via `data` or `page.data`.\n- For shared client‑only state across components, use Svelte’s context API (`setContext`/`getContext`) or URL parameters for persistent filters; snapshots for ephemeral UI state tied to navigation history.\n\n## Building your app\n\n- Build runs in two phases: Vite compiles and prerenders (if enabled), then an adapter tailors output for your deployment target.\n- Guard any code that should not execute at build time with `import { building } from '$app/environment'; if (!building) { … }`.\n- Preview your production build locally with `npm run preview` (Node‑only, no adapter hooks).\n\n## Adapters\n\n- Adapters transform the built app into deployable assets for various platforms (Cloudflare, Netlify, Node, static, Vercel, plus community adapters).\n- Configure in `svelte.config.js` under `kit.adapter = adapter(opts)`, importing the adapter module and passing its options.\n- Some adapters expose a `platform` object (e.g. Cloudflare’s `env`); access it via `event.platform` in hooks and server routes.\n\n## Single‑page apps\n\n- Turn your app into a fully CSR SPA by setting `export const ssr = false;` in the root `+layout.js`.\n- For static hosting, use `@sveltejs/adapter-static` with a `fallback` HTML (e.g. `200.html`) so client routing can handle unknown paths.\n- You can still prerender select pages by enabling `prerender = true` and `ssr = true` in their individual `+page.js` or `+layout.js` modules.\n\n## Advanced routing\n\n- Rest parameters (`[...file]`) capture an unknown number of segments (e.g. `src/routes/hello/[...path]` catches all routes under `/hello`) and expose them as a single string; use a catch‑all route `+error.svelte` to render nested custom 404 pages.\n- Optional parameters (`[[lang]]`) make a segment optional, e.g. for `[[lang]]/home` both `/home` and `/en/home` map to the same route; cannot follow a rest parameter.\n- Matchers in `src/params/type.js` let you constrain `[param=type]` (e.g. only “apple” or “orange”), falling back to other routes or a 404 if the test fails.\n\n### Advanced layouts\n\n- Group directories `(app)` or `(marketing)` apply a shared layout without affecting URLs.\n- Break out of the inherited layout chain per page with `+page@segment.svelte` (e.g. `+page@(app).svelte`) or per layout with `+layout@.svelte`.\n- Use grouping judiciously: overuse can complicate nesting; sometimes simple composition or wrapper components suffice.\n\n## Hooks\n\n### Server hooks\n\n- `handle({ event, resolve })`: runs on every request; mutate `event.locals`, bypass routing, or call `resolve(event, { transformPageChunk, filterSerializedResponseHeaders, preload })` to customize HTML, headers, and asset preloading.\n- `handleFetch({ event, request, fetch })`: intercepts server‑side `fetch` calls to rewrite URLs, forward cookies on cross‑origin, or route internal requests directly to handlers.\n- `init()`: runs once at server startup for async setup (e.g. database connections).\n\n### Shared hooks\n\n- `handleError({ error, event, status, message })`: catches unexpected runtime errors on server or client; log via Sentry or similar, return a safe object (e.g. `{ message: 'Oops', errorId }`) for `$page.error`.\n\n### Universal hooks\n\n- `reroute({ url, fetch? })`: map incoming `url.pathname` to a different route ID (without changing the address bar), optionally async and using `fetch`.\n- `transport`: define `encode`/`decode` for custom types (e.g. class instances) to serialize them across server/client boundaries in loads and actions.\n\n## Errors\n\n- Expected errors thrown with `error(status, message|object)` set the response code, render the nearest `+error.svelte` with `page.error`, and let you pass extra props (e.g. `{ code: 'NOT_FOUND' }`).\n- Unexpected exceptions invoke the `handleError` hook, are logged internally, and expose a generic `{ message: 'Internal Error' }` to users; customize reporting or user‑safe messages in `handleError`.\n- Errors in server handlers or `handle` return JSON or your `src/error.html` fallback based on `Accept` headers; errors in `load` render component boundaries as usual. Type‑safe shapes via a global `App.Error` interface.\n\n## Link options\n\nThe following are HTML attributes you can put on any HTML element.\n\n- `data-sveltekit-preload-data=\"hover\"|\"tap\"` preloads `load` on link hover (`touchstart`) or immediate tap; use `\"tap\"` for fast‑changing data.\n- `data-sveltekit-preload-code=\"eager\"|\"viewport\"|\"hover\"|\"tap\"` preloads JS/CSS aggressively or on scroll/hover/tap to improve load times.\n- `data-sveltekit-reload` forces full-page reload; `data-sveltekit-replacestate` uses `replaceState`; `data-sveltekit-keepfocus` retains focus; `data-sveltekit-noscroll` preserves scroll position; disable any by setting the value to `\"false\"`.\n\n## Server-only modules\n\n- `$env/static/private` and `$env/dynamic/private` can only be imported into server‑only files (`hooks.server.js`, `+page.server.js`); prevents leaking secrets to the client.\n- `$app/server` (e.g. the `read()` API) is likewise restricted to server‑side code.\n- Make your own modules server‑only by naming them `*.server.js` or placing them in `src/lib/server/`; any public‑facing import chain to these files triggers a build error.\n\n## Shallow routing\n\n- Use `pushState(path, state)` or `replaceState('', state)` from `$app/navigation` to create history entries without full navigation; read/write `page.state` from `$app/state`.\n- Ideal for UI like modals: `if (page.state.showModal) <Modal/>` and dismiss with `history.back()`.\n- To embed a route’s page component without navigation, preload data with `preloadData(href)` then `pushState`, falling back to `goto`; note SSR and initial load have empty `page.state`, and shallow routing requires JS.\n\n## Images\n\n- Vite’s asset handling inlines small files, adds hashes, and lets you `import logo from '...png'` for use in `<img src={logo}>`.\n- Install `@sveltejs/enhanced-img` and add `enhancedImages()` to your Vite config; use `<enhanced:img src=\"...jpg\" alt=\"…\"/>` to auto‑generate `<picture>` tags with AVIF/WebP, responsive `srcset`/`sizes`, and intrinsic dimensions.\n- For CMS or dynamic images, leverage a CDN with Svelte libraries like `@unpic/svelte`; always supply high‑resolution originals (2×), specify `sizes` for LCP images, set `fetchpriority=\"high\"`, constrain layout via CSS to avoid CLS, and include meaningful `alt` text.\n\n## Reference docs\n\n### Imports from `@sveltejs/kit`\n\n- **error**: throw an HTTP error and halt request processing\n\n  ```js\n  import { error } from '@sveltejs/kit';\n  export function load() {\n  \terror(404, 'Not found');\n  }\n  ```\n\n- **fail**: return a form action failure without throwing\n\n  ```js\n  import { fail } from '@sveltejs/kit';\n  export const actions = {\n  \tdefault: async ({ request }) => {\n  \t\tconst data = await request.formData();\n  \t\tif (!data.get('name')) return fail(400, { missing: true });\n  \t}\n  };\n  ```\n\n- **isActionFailure**: type‑guard for failures from `fail`\n\n  ```js\n  import { isActionFailure } from '@sveltejs/kit';\n  if (isActionFailure(result)) {\n  \t/* handle invalid form */\n  }\n  ```\n\n- **isHttpError**: type‑guard for errors from `error`\n\n  ```js\n  import { isHttpError } from '@sveltejs/kit';\n  try {\n  \t/* … */\n  } catch (e) {\n  \tif (isHttpError(e, 404)) console.log('Not found');\n  }\n  ```\n\n- **isRedirect**: type‑guard for redirects from `redirect`\n\n  ```js\n  import { redirect, isRedirect } from '@sveltejs/kit';\n  try {\n  \tredirect(302, '/login');\n  } catch (e) {\n  \tif (isRedirect(e)) console.log('Redirecting');\n  }\n  ```\n\n- **json**: build a JSON `Response`\n\n  ```js\n  import { json } from '@sveltejs/kit';\n  export function GET() {\n  \treturn json({ hello: 'world' });\n  }\n  ```\n\n- **normalizeUrl** _(v2.18+)_: strip internal suffixes/trailing slashes\n\n  ```js\n  import { normalizeUrl } from '@sveltejs/kit';\n  const { url, denormalize } = normalizeUrl('/foo/__data.json');\n  url.pathname; // /foo\n  ```\n\n- **redirect**: throw a redirect response\n\n  ```js\n  import { redirect } from '@sveltejs/kit';\n  export function load() {\n  \tredirect(303, '/dashboard');\n  }\n  ```\n\n- **text**: build a plain‑text `Response`\n\n  ```js\n  import { text } from '@sveltejs/kit';\n  export function GET() {\n  \treturn text('Hello, text!');\n  }\n  ```\n\n### Imports from `@sveltejs/kit/hooks`\n\n- **sequence**: compose multiple `handle` hooks into one, merging their options\n\n  ```js\n  import { sequence } from '@sveltejs/kit/hooks';\n  export const handle = sequence(handleOne, handleTwo);\n  ```\n\n### Imports from `$app/forms`\n\n- **applyAction**: apply an `ActionResult` to update `page.form` and `page.status`\n\n  ```js\n  import { applyAction } from '$app/forms';\n  // inside enhance callback:\n  await applyAction(result);\n  ```\n\n- **deserialize**: parse a serialized form action response back into `ActionResult`\n\n  ```js\n  import { deserialize } from '$app/forms';\n  const result = deserialize(await response.text());\n  ```\n\n- **enhance**: progressively enhance a `<form>` for AJAX submissions\n\n  ```svelte\n  <script>\n    import { enhance } from '$app/forms';\n  </script>\n  <form use:enhance on:submit={handle}>\n  ```\n\n### Imports from `$app/navigation`\n\n- **afterNavigate**: run code after every client‑side navigation. Needs to be called at component initialization\n\n  ```js\n  import { afterNavigate } from '$app/navigation';\n  afterNavigate(({ type, to }) => console.log('navigated via', type));\n  ```\n\n- **beforeNavigate**: intercept and optionally cancel upcoming navigations. Needs to be called at component initialization\n\n  ```js\n  import { beforeNavigate } from '$app/navigation';\n  beforeNavigate(({ cancel }) => {\n  \tif (!confirm('Leave?')) cancel();\n  });\n  ```\n\n- **disableScrollHandling**: disable automatic scroll resetting after navigation\n\n  ```js\n  import { disableScrollHandling } from '$app/navigation';\n  disableScrollHandling();\n  ```\n\n- **goto**: programmatically navigate within the app\n\n  ```svelte\n  <script>\n    import { goto } from '$app/navigation';\n    function navigate() {\n      goto('/dashboard', { replaceState: true });\n    }\n  </script>\n    <button onclick={navigate}>navigate</button>\n  ```\n\n- **invalidate**: re‑run `load` functions that depend on a given URL or custom key\n\n  ```js\n  import { invalidate } from '$app/navigation';\n  await invalidate('/api/posts');\n  ```\n\n- **invalidateAll**: re‑run every `load` for the current page\n\n  ```js\n  import { invalidateAll } from '$app/navigation';\n  await invalidateAll();\n  ```\n\n- **onNavigate**: hook invoked immediately before client‑side navigations. Needs to be called at component initialization\n\n  ```js\n  import { onNavigate } from '$app/navigation';\n  onNavigate(({ to }) => console.log('about to go to', to.url));\n  ```\n\n- **preloadCode**: import route modules ahead of navigation (no data fetch)\n\n  ```js\n  import { preloadCode } from '$app/navigation';\n  await preloadCode('/about');\n  ```\n\n- **preloadData**: load both code and data for a route ahead of navigation\n\n  ```js\n  import { preloadData } from '$app/navigation';\n  const result = await preloadData('/posts/1');\n  ```\n\n- **pushState**: create a shallow‑routing history entry with custom state\n\n  ```js\n  import { pushState } from '$app/navigation';\n  pushState('', { modalOpen: true });\n  ```\n\n- **replaceState**: replace the current history entry with new custom state\n\n  ```js\n  import { replaceState } from '$app/navigation';\n  replaceState('', { modalOpen: false });\n  ```\n\n### Imports from `$app/paths`\n\n- **assets**: the absolute URL prefix for static assets (`config.kit.paths.assets`)\n\n  ```js\n  import { assets } from '$app/paths';\n  console.log(`<img src=\"${assets}/logo.png\">`);\n  ```\n\n- **base**: the base path for your app (`config.kit.paths.base`)\n\n  ```svelte\n  <a href=\"{base}/about\">About Us</a>\n  ```\n\n- **resolveRoute**: interpolate a route ID with parameters to form a pathname\n\n  ```js\n  import { resolveRoute } from '$app/paths';\n  resolveRoute('/blog/[slug]/[...rest]', {\n  \tslug: 'hello',\n  \trest: '2024/updates'\n  });\n  // → \"/blog/hello/2024/updates\"\n  ```\n\n### Imports from `$app/server`\n\n- **getRequestEvent** _(v2.20+)_: retrieve the current server `RequestEvent`\n\n  ```js\n  import { getRequestEvent } from '$app/server';\n  export function load() {\n  \tconst event = getRequestEvent();\n  \tconsole.log(event.url);\n  }\n  ```\n\n- **read** _(v2.4+)_: read a static asset imported by Vite as a `Response`\n\n  ```js\n  import { read } from '$app/server';\n  import fileUrl from './data.txt';\n  const res = read(fileUrl);\n  console.log(await res.text());\n  ```\n\n- **navigating**: a read‑only object describing any in‑flight navigation (or `null`)\n\n  ```svelte\n  <script>\n    import { navigating } from '$app/state';\n    console.log(navigating.from, navigating.to);\n  </script>\n  ```\n\n### Imports from `$app/state`\n\n- **page**: read‑only reactive info about the current page (`url`, `params`, `data`, etc.)\n\n  ```svelte\n  <script>\n    import { page } from '$app/state';\n    const path = $derived(page.url.pathname);\n  </script>\n  {path}\n  ```\n\n- **updated**: reactive flag for new app versions; call `updated.check()` to poll immediately\n\n  ```svelte\n  <script>\n    import { updated } from '$app/state';\n    $effect(() => {\n      if (updated.current) {\n        alert('A new version is available. Refresh?');\n      }\n    })\n  </script>\n  ```\n\n### Imports from `$env/dynamic/private`\n\n- **env (dynamic/private)**: runtime private env vars (`process.env…`), not exposed to client\n\n  ```js\n  import { env } from '$env/dynamic/private';\n  console.log(env.SECRET_API_KEY);\n  ```\n\n### Imports from `$env/dynamic/public`\n\n- **env (dynamic/public)**: runtime public env vars (`PUBLIC_…`), safe for client use\n\n  ```js\n  import { env } from '$env/dynamic/public';\n  console.log(env.PUBLIC_BASE_URL);\n  ```\n\n### Imports from `$env/static/private`\n\n- **$env/static/private**: compile‑time private env vars, dead‑code eliminated\n\n  ```js\n  import { DATABASE_URL } from '$env/static/private';\n  console.log(DATABASE_URL);\n  ```\n\n### Imports from `$env/static/public`\n\n- **$env/static/public**: compile‑time public env vars (`PUBLIC_…`), safe on client\n\n  ```js\n  import { PUBLIC_WS_ENDPOINT } from '$env/static/public';\n  console.log(PUBLIC_WS_ENDPOINT);\n  ```\n\n### `$lib` alias\n\nAlias for `src/lib` folder, e.g.\n\n```svelte\n<script>\n  import Button from '$lib/Button.svelte';\n</script>\n<Button>Click me</Button>\n```\n\nmeans that there's a component at `src/lib/Button.svelte`.\n"
    },
    "samples": [
      {
        "index": 0,
        "code": "<svelte:options runes={true} />\n\n<script>\n  const books = [\"The Lord of the Rings\", \"To Kill a Mockingbird\", \"1984\"];\n</script>\n\n{#snippet title(bookTitle)}\n  <span data-testid=\"book-title\">{bookTitle}</span>\n{/snippet}\n\n<ul>\n  {#each books as book}\n    <li data-testid=\"book-item\">{@render title(book)}</li>\n  {/each}\n</ul>",
        "success": true,
        "errors": [],
        "temperature": 0.2
      },
      {
        "index": 1,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let books = [\n    \"The Lord of the Rings\",\n    \"To Kill a Mockingbird\",\n    \"1984\"\n  ];\n</script>\n\n{#snippet title(bookTitle)}\n  <span data-testid=\"book-title\">{bookTitle}</span>\n{/snippet}\n\n<ul>\n  {#each books as book}\n    <li data-testid=\"book-item\">{@render title(book)}</li>\n  {/each}\n</ul>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 2,
        "code": "<svelte:options runes={true} />\n\n<script>\n  const books = [\n    \"The Lord of the Rings\",\n    \"To Kill a Mockingbird\",\n    \"1984\"\n  ];\n</script>\n\n{#snippet title(bookTitle)}\n  <span data-testid=\"book-title\">{bookTitle}</span>\n{/snippet}\n\n<ul>\n  {#each books as book}\n    <li data-testid=\"book-item\">{@render title(book)}</li>\n  {/each}\n</ul>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 3,
        "code": "<svelte:options runes={true} />\n\n<script>\n  const books = [\n    \"The Lord of the Rings\",\n    \"To Kill a Mockingbird\",\n    \"1984\"\n  ];\n</script>\n\n{#snippet title(bookTitle)}\n  <span data-testid=\"book-title\">{bookTitle}</span>\n{/snippet}\n\n<ul>\n  {#each books as book}\n    <li data-testid=\"book-item\">{@render title(book)}</li>\n  {/each}\n</ul>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 4,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let books = $state([\n    \"The Lord of the Rings\",\n    \"To Kill a Mockingbird\",\n    \"1984\"\n  ]);\n\n  {#snippet title(bookTitle)}\n    <span data-testid=\"book-title\">{bookTitle}</span>\n  {/snippet}\n</script>\n\n<ul>\n  {#each books as book}\n    <li data-testid=\"book-item\">\n      {@render title(book)}\n    </li>\n  {/each}\n</ul>",
        "success": false,
        "errors": [
          "tmp/google/Component.svelte:10:3 Unexpected token\nhttps://svelte.dev/e/js_parse_error"
        ],
        "temperature": 0.8
      },
      {
        "index": 5,
        "code": "<svelte:options runes={true} />\n\n<script>\n  const books = [\"The Lord of the Rings\", \"To Kill a Mockingbird\", \"1984\"];\n</script>\n\n{#snippet title(bookTitle)}\n  <span data-testid=\"book-title\">{bookTitle}</span>\n{/snippet}\n\n<ul>\n  {#each books as book}\n    <li data-testid=\"book-item\">\n      {@render title(book)}\n    </li>\n  {/each}\n</ul>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 6,
        "code": "<svelte:options runes={true} />\n\n<script>\n  const books = [\n    \"The Lord of the Rings\",\n    \"To Kill a Mockingbird\",\n    \"1984\"\n  ];\n</script>\n\n{#snippet title(bookTitle)}\n  <span data-testid=\"book-title\">{bookTitle}</span>\n{/snippet}\n\n<ul>\n  {#each books as book}\n    <li data-testid=\"book-item\">\n      {@render title(book)}\n    </li>\n  {/each}\n</ul>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 7,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let books = $state([\"The Lord of the Rings\", \"To Kill a Mockingbird\", \"1984\"]);\n</script>\n\n{#snippet title(bookTitle)}\n  <span data-testid=\"book-title\">{bookTitle}</span>\n{/snippet}\n\n<ul>\n  {#each books as book}\n    <li data-testid=\"book-item\">{@render title(book)}</li>\n  {/each}\n</ul>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 8,
        "code": "<svelte:options runes={true} />\n\n<script>\n  let books = $state([\"The Lord of the Rings\", \"To Kill a Mockingbird\", \"1984\"]);\n</script>\n\n{#snippet title(bookTitle)}\n  <span data-testid=\"book-title\">{bookTitle}</span>\n{/snippet}\n\n<ul>\n  {#each books as book}\n    <li data-testid=\"book-item\">{@render title(book)}</li>\n  {/each}\n</ul>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      },
      {
        "index": 9,
        "code": "<svelte:options runes={true} />\n\n<script>\n\tconst bookTitles = [\"The Lord of the Rings\", \"To Kill a Mockingbird\", \"1984\"];\n</script>\n\n{#snippet title(bookTitle)}\n\t<span data-testid=\"book-title\">{bookTitle}</span>\n{/snippet}\n\n<ul>\n\t{#each bookTitles as bookTitle}\n\t\t<li data-testid=\"book-item\">{@render title(bookTitle)}</li>\n\t{/each}\n</ul>",
        "success": true,
        "errors": [],
        "temperature": 0.8
      }
    ],
    "version": "v1"
  }
]
